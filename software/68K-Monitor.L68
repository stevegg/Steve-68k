00FDFFFE Starting Address
Assembler used: EASy68K Editor/Assembler v5.9.0
Created On: 2/8/2021 12:55:14 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Program Number: 68K Monitor for S100Computers.com
00000000                             3  * Written by    : John Monahan
00000000                             4  * Date Created  : 11/11/2011
00000000                             5  * Description   : Basic monitor for 68K S-100 board
00000000                             6  *
00000000                             7  *   'A=Memmap    C=XMODEM(Bin) D=Disp RAM    E=Echo        F=Fill RAM'
00000000                             8  *   'G=Goto RAM  H=Math        I=Time        K=Menu        L=Test Ints'
00000000                             9  *   'M=Move RAM  N=IDE Menu    Q=Port I/O    U=Serial Test S=Subs RAM'
00000000                            10  *   'T=Type RAM  V=Verify RAM  X=Signals     Y=Patch       Z=Back to Z80'
00000000                            11  *
00000000                            12  *-----------------------------------------------------------
00000000                            13  ;           V1.5    03/07/2012              ;Corrected line length display of RAM (D & T Commands)
00000000                            14  ;           V1.6    03/07/2012              ;Added initilization of Interrupt routines in low RAM
00000000                            15  ;           V1.7    03/08/2012              ;Add test interrupts routine, "L" CMD.
00000000                            16  ;           V1.8    03/09/2012              ;Code to switch back to Z80, and hardware signals analysis
00000000                            17  ;           V1.9    03/18/2012              ;Added IDE Board Diagnostic Section
00000000                            18  ;           V1.91   03/27/2012              ;Substitute RAM redone
00000000                            19  ;           V2.0    04/02/2012              ;Added IDE Menu Items and Y command
00000000                            20  ;           V2.1    04/26/2013              ;Fixed numerous small bugs, RAM display map,D,F,M X commands etc
00000000                            21  ;           V2.2    04/27/2013              ;Display RAM (D CMD) also displays ASCII
00000000                            22  ;           V2.3    04/23/2014              ;Allow output to 16 bit ports (>0FFH), DMA1* port switch is now 00EEH
00000000                            23  ;           V2.4    04/30/2014              ;Cleanup console I/O routines, add serial port I/O
00000000                            24  ;           V2.5    05/2/2014               ;Added XMODEM .bin file download capabilities over serial port
00000000                            25  ;           V2.6    06/12/2014              ;Corrected QO/QI port bug
00000000                            26  ;           V3.0    7/27/2020               ;Damian Wildie corrections and addition of working IDE/CF card menu
00000000                            27  ;           V3.1    2/1/2021                ;Corrected numerous small errors. Sec Writes corercted, Cleaned up menu options. 
00000000                            28  ;           V3.11    2/1/2021               ;Made commands the same as for 68030 Monitor.. 
00000000                            29  ;           V3.12   2/8/2021                ;Corrections to Drive ID info
00000000                            30  ;
00000000                            31  ;
00000000                            32  ;
00000000                            33  ;Programming a Wellon VP-290 with 28C256 EEPROMS.
00000000                            34  ;Assemble and make a S68 file (Project Menu for EASy68K)
00000000                            35  ;Load first, even byte in dropdown menu for "File Mode"
00000000                            36  ;For "From File Address(Hex) enter FD0000 (Note "To Buffer Address (HEX) is 0)
00000000                            37  ;File Size is 8000 (for X28C256's)
00000000                            38  ;For "Auto Format Detect" use Motorola S
00000000                            39  ;Repeat, for second EEPROM using Odd Bytes for "File Mode"
00000000                            40  ;(Note for the 68030 Board only one PROM is needed).
00000000                            41  ;
00000000                            42  ;
00000000  =00000007                 43  BELL        EQU     $07
00000000  =00000020                 44  BLANK       EQU     $20
00000000  =0000000D                 45  CR          EQU     $0D 
00000000  =0000000A                 46  LF          EQU     $0A
00000000  =0000001B                 47  ESC         EQU     $1B
00000000  =00000009                 48  TAB         EQU     $09
00000000  =00000001                 49  SOH         EQU     1                       ; For Modem etc.
00000000  =00000004                 50  EOT         EQU     4
00000000  =00000006                 51  ACK         EQU     6
00000000  =00000015                 52  NAK         EQU     $15
00000000                            53  
00000000                            54              ;Note, only one of the following 3 equates can be 1
00000000  =00000000                 55  SIMMULATOR  EQU     0                       ;Set to 1 if using EASy68K Simmulator (Console I/O will be via software interrupts)
00000000  =00000000                 56  S100_TEST   EQU     0                       ;Set to 1 if using S100 RAM (We will not use INT's for console I/O)
00000000  =00000001                 57  ROM_CODE    EQU     1                       ;Set to 1 for ROM code (We will not use INT's for console I/O)
00000000                            58              
00000000                            59  
00000000                            60  ;Propeller Console IO S-100 board or SD SYSTEMS VIDIO BOARD FOR CONSOLE I/O(<---These must configured for your hardware)
00000000                            61  
00000000  =00FF0000                 62  KEYSTAT     EQU     $00FF0000               
00000000  =00FF0001                 63  KEYIN       EQU     $00FF0001               ;Console input port. Normally the Propeller Driven S-100 Console-IO Board
00000000  =00FF0001                 64  KEYOUT      EQU     $00FF0001               ;Console output port. Normally the Propeller Driven S-100 Console-IO Board
00000000                            65  
00000000                            66  
00000000                            67  
00000000                            68  ;-------------- THIS IS MY PORT TO OUTPUT DATA TO HP 4050T LASAR PRINTER  (IMSAI 8PIO Board)
00000000                            69  
00000000  =00FF0005                 70  PRINTER_STATUS      EQU     $00FF0005       ;IN, HP PARRELL PORT
00000000  =00FF0005                 71  PRINTER_OUT EQU     $00FF0005               ;OUT
00000000  =00FF0004                 72  PRINTER_STROBE      EQU     $00FF0004       ;OUT
00000000  =00FF0005                 73  DIAG_LEDS   EQU     $00FF0005               ;OUT (Will use this port initially for diagnostic LED display)
00000000                            74  
00000000                            75  
00000000                            76  ;-------------- S100Computers Serial I/O BOARD PORT ASSIGNMENTS  (A0-AC)
00000000                            77  
00000000  =00FF00A0                 78  BCTL        EQU     $00FF00A0               ;CHANNEL B CONTROL PORT ASSIGNMENTS OF THE ZILOG SCC CHIP  
00000000  =00FF00A1                 79  ACTL        EQU     $00FF00A1               ;CHANNEL A CONTROL (Base Port)
00000000  =00FF00A2                 80  BDTA        EQU     $00FF00A2               ;CHANNEL B DATA
00000000  =00FF00A3                 81  ADTA        EQU     $00FF00A3               ;CHANNEL A DATA
00000000  =00000008                 82  MODEM_ERR_LIMIT     EQU     8               ;Max number of Modem serial port re-reads aborting (See XMODEM_BIN)
00000000  =00001F40                 83  SERIAL_RETRYS       EQU     8000            ;Default number of times to try reading serial port before aborting. Not critical.
00000000  =000003E8                 84  SPEAKER_DELAY       EQU     1000            ;Slight delay for speak sysnthesizer
00000000                            85  ;
00000000  =00FF00A8                 86  PortA_8255  EQU     $00FF00A8               ;A port of 8255 ;<--- Adjust as necessary
00000000  =00FF00A9                 87  PortB_8255  EQU     $00FF00A9               ;B port of 8255
00000000  =00FF00AA                 88  PortC_8255  EQU     $00FF00AA               ;C Port of 8255
00000000  =00FF00AB                 89  PortCtrl_8255       EQU     $00FF00AB       ;8255 configuration port
00000000                            90  
00000000  =00000098                 91  AinBout8255cfg      EQU     %10011000       ;Set 8255 ports:- A input, B output, 
00000000                            92              ;C(bits 0-3) output, (bits 4-7)input
00000000                            93  
00000000  =00FF00AC                 94  USB_DATA    EQU     $00FF00AC               ;PORT ASSIGNEMENT FOR DLP-USB Controller chip
00000000  =00FF00AA                 95  USB_STATUS  EQU     $00FF00AA               ;Status port for USB port (Port C of 8255, bits 6,7)
00000000                            96  
00000000  =00000080                 97  USB_RXE     EQU     $80                     ;If Bit 7 = 0, data available to recieve by S-100 Computer
00000000  =00000040                 98  USB_TXE     EQU     $40                     ;If Bit 6 = 0 data CAN be written for transmission to PC
00000000                            99  
00000000  =00FF00EF                100  IOBYTE      EQU     $00FF00EF               ;IOBYTE Port on S100Computers SMB Board.
00000000                           101  
00000000                           102  ; BIT MAP OF PORT 0EFH:- X X X X  X X X X      (11111111=NORMAL CONFIG)
00000000                           103  ;            | | | |  | | | |..For Z80 Monitor,0=CONSOLE DATA TO PRINTER ALSO
00000000                           104  ;            | | | |  | | |....For 8086 Monitor,0=Force MSDOS Consol output to CGA/VGA Board instead of Propeller board
00000000                           105  ;            | | | |  | |......For 8086 Monitor,0=Do not initilize extra ROMS
00000000                           106  ;            | | | |  |........For 8086 Monitor,0=Debug data for all MSDOS 10H & 15H INT's to Serial Port and external display
00000000                           107  ;            | | | |...........Unused       
00000000                           108  ;            | | |-------------For Monitor,         0=Consol Output,(not input), via ACIA Serial port on S100Computers Serial-IO Board
00000000                           109  ;            | |...............For CPM3,        0=Force reformat of Memory disk upon any CPM3 cold re-boot
00000000                           110  ;                                            |
00000000                           111  ;            |.................For CPM3,        0=Write protect Memory disk for CPM3
00000000                           112  ;                       For 8086 Monitor    0=Prevent doing a JMPF to 500H after 8086 reset (to CPM86 boot)
00000000                           113  ;           Normally a test is made to see if the CPM86 Boot is already in RAM at 500H
00000000                           114  ;           If it is, a 8086 reset will bypass the monitor and go directly there. 
00000000                           115  ;           (see Init: in 8086 Monitor)
00000000                           116  ;
00000000                           117  ;           Note if IOBYTE = 00xxxxxx,      This will force the 8086 hardware diagnostic test after reset. 
00000000                           118  ;                                                               (See code at FFFF0H in this 8086 monitor)
00000000                           119  
00000000                           120  
00000000                           121  
00000000                           122  ;------------ S100Computers MSDOS BOARD PORT ASSIGNMENTS  
00000000                           123  
00000000  =00000020                124  NS_EOI      equ     $20                     ;Non specific end of interrupt command
00000000  =00FF0020                125  MASTER_PIC_PORT     equ     $00FF0020       ;Hardware port the 8259A is assigned (two ports 20H & 21H)
00000000                           126  
00000000  =00000017                127  MasterICW1  equ     %00010111               ;EDGE triggered, 4 bytes, single Master,ICW4 needed
00000000  =00000008                128  MasterICW2  equ     $8                      ;Base address for 8259A Int Table (IBM-PC uses 8X4 = 20H)
00000000  =00000000                129  MasterICW3  equ     $0                      ;No slave
00000000  =00000003                130  MasterICW4  equ     %00000011               ;No special mode, non buffer, Auto EOI, 8086.  ;<<<<,
00000000                           131  
00000000  =00FF0070                132  CMOS_PORT   EQU     $00FF0070               ;Base Port for CMOS Chip
00000000  =00FF000D                133  CMOS_VALID  EQU     $00FF000D               ;To check DS12887 CMOS chip is present and OK (Note AT-BIOS uses 0EH)
00000000  =00FF000A                134  CMOS_REGA   EQU     $00FF000A               ;CMOS REGISTER A
00000000                           135  
00000000  =00FF0040                136  TIMER       EQU     $00FF0040               ;Base port of 8254
00000000  =00FF0043                137  TIM_CTL     EQU     $00FF0043
00000000  =00000018                138  COUNTS_SEC  EQU     $18
00000000  =00000444                139  COUNTS_MIN  EQU     1092
00000000  =00000007                140  COUNTS_HOUR EQU     $07                     ;Seems this value is used with AT/CMOS chip (was 65543 on PC)
00000000                           141  
00000000  =00000080                142  UPDATE_TIMEREQU     $80
00000000                           143  
00000000  =00000000                144  CMOS_SECONDSEQU     $0                      ;RAM offsets for CMOS Registers
00000000  =00000002                145  CMOS_MINUTESEQU     $2
00000000  =00000004                146  CMOS_HOURS  EQU     $4
00000000                           147  
00000000                           148  
00000000                 TRUE      149     IFEQ SIMMULATOR  ;If SIMMULATOR = 0 (Normal EEPROM)
00000000  =00F40000                150  Patch_RAM   EQU    $00F40000                ;Location of Patch code area
00000000                           151     ENDC
00000000                           152  
00000000                 FALSE     153     IFNE SIMMULATOR  ;If SIMMULATOR = 1 (For testing here within EASy68K & S100 RAM)
00000000                           154     ENDC     
00000000                           155    
00000000                           156              
00000000                           157  ;-------------- S100Computers IDE BOARD PORT ASSIGNMENTS  (30-34H)
00000000                           158  
00000000                           159  ;Ports for 8255 chip. Change these to specify where the 8255 is addressed,
00000000                           160  ;and which of the 8255's ports are connected to which IDE signals.
00000000                           161  ;The first three control which 8255 ports have the IDE control signals,
00000000                           162  ;upper and lower data bytes.  The forth one is for mode setting for the
00000000                           163  ;8255 to configure its ports, which must correspond to the way that
00000000                           164  ;the first three lines define which ports are connected.
00000000                           165  
00000000  =00FF0030                166  IDEportA    EQU     $00FF0030               ;lower 8 bits of IDE interface
00000000  =00FF0031                167  IDEportB    EQU     $00FF0031               ;upper 8 bits of IDE interface
00000000  =00FF0032                168  IDEportC    EQU     $00FF0032               ;control lines for IDE interface
00000000  =00FF0033                169  IDECtrlPort EQU     $00FF0033               ;8255 configuration port
00000000  =00FF0034                170  IDEDrivePortEQU     $00FF0034               ;To select the 1st or 2nd CF card/drive
00000000                           171  
00000000  =00000080                172  IDE_Reset_Delay     EQU     $80             ;Time delay for reset/initilization (~66 uS, with 8MHz 8086, 1 I/O wait state)
00000000                           173  
00000000  =00000092                174  READcfg8255 EQU     %10010010               ;Set 8255 IDEportC out, IDEportA/B input
00000000  =00000080                175  WRITEcfg8255EQU     %10000000               ;Set all three 8255 ports output
00000000                           176  
00000000                           177  ;IDE control lines for use with IDEportC.  
00000000                           178  
00000000  =00000001                179  IDEa0line   EQU     $01                     ;direct from 8255 to IDE interface
00000000  =00000002                180  IDEa1line   EQU     $02                     ;direct from 8255 to IDE interface
00000000  =00000004                181  IDEa2line   EQU     $04                     ;direct from 8255 to IDE interface
00000000  =00000008                182  IDEcs0line  EQU     $08                     ;inverter between 8255 and IDE interface
00000000  =00000010                183  IDEcs1line  EQU     $10                     ;inverter between 8255 and IDE interface
00000000  =00000020                184  IDEwrline   EQU     $20                     ;inverter between 8255 and IDE interface
00000000  =00000040                185  IDErdline   EQU     $40                     ;inverter between 8255 and IDE interface
00000000  =00000080                186  IDErstline  EQU     $80                     ;inverter between 8255 and IDE interface
00000000                           187  ;
00000000                           188  ;Symbolic constants for the IDE Drive registers, this makes the
00000000                           189  ;code more readable than always specifying the address pins
00000000                           190  
00000000  =00000008                191  REGdata     EQU     IDEcs0line
00000000  =00000009                192  REGerr      EQU     IDEcs0line+IDEa0line
00000000  =0000000A                193  REGseccnt   EQU     IDEcs0line+IDEa1line
00000000  =0000000B                194  REGsector           EQU     IDEcs0line+IDEa1line+IDEa0line
00000000  =0000000C                195  REGcylinderLSB      EQU     IDEcs0line+IDEa2line
00000000  =0000000D                196  REGcylinderMSB      EQU     IDEcs0line+IDEa2line+IDEa0line
00000000  =0000000E                197  REGshd      EQU     IDEcs0line+IDEa2line+IDEa1line;(0EH)
00000000  =0000000F                198  REGcommand  EQU     IDEcs0line+IDEa2line+IDEa1line+IDEa0line;(0FH)
00000000  =0000000F                199  REGstatus   EQU     IDEcs0line+IDEa2line+IDEa1line+IDEa0line
00000000  =00000016                200  REGcontrol  EQU     IDEcs1line+IDEa2line+IDEa1line
00000000  =00000017                201  REGastatus  EQU     IDEcs1line+IDEa2line+IDEa1line+IDEa0line
00000000                           202  
00000000                           203  ;IDE Command Constants.  These should never change.
00000000                           204  
00000000  =00000010                205  COMMANDrecalEQU     $10
00000000  =00000020                206  COMMANDread EQU     $20
00000000  =00000030                207  COMMANDwriteEQU     $30
00000000  =00000091                208  COMMANDinit EQU     $91
00000000  =000000EC                209  COMMANDid   EQU     $EC
00000000  =000000E0                210  COMMANDspindown     EQU     $E0
00000000  =000000E1                211  COMMANDspinup       EQU     $E1
00000000                           212  ;
00000000                           213  ; IDE Status Register:
00000000                           214  ;  bit 7: Busy      1=busy, 0=not busy
00000000                           215  ;  bit 6: Ready     1=ready for command, 0=not ready yet
00000000                           216  ;  bit 5: DF1=fault occured on the IDE drive
00000000                           217  ;  bit 4: DSC       1=seek complete
00000000                           218  ;  bit 3: DRQ       1=data request ready, 0=not ready to xfer yet
00000000                           219  ;  bit 2: CORR      1=correctable error occured
00000000                           220  ;  bit 1: IDX       vendor specific
00000000                           221  ;  bit 0: ERR       1=error occured
00000000                           222  
00000000  =000000FF                223  MAXSEC      EQU      $FF                    ;Sectors per track for CF my Memory drive, Kingston CF 8G. 
00000000                           224              ;Note on the origional CPM3 CF cards it was 0-3CH
00000000                           225              ;for a total of 61 sectors/track.
00000000  =0000003E                226  DOS_MAXSEC          EQU      $3E            ;For MS-DOS BIOS Setting "Hard Disk" to Custom type (CF Card, 63 Sectors/track)
00000000  =00000010                227  DOS_MAXHEADSEQU      $10                    ;16 head(s)
00000000  =000000FF                228  DOS_MAXCYL_LEQU      $FF                    ;Low Byte maximum cylinder (sent via INT 13H's in CH)
00000000  =00000400                229  DOS_MAXCYL  EQU      1024                   ;Max cylinders
00000000  =000000FF                230  DOS_MAXSEC_CYL      EQU      $FF            ;3FH, maximum sector number (bits 5-0)+ two Cyl High Bits (Sectors numbered 1....x)
00000000                           231  
00000000                           232  
00000000                           233  
00000000                           234  ;--------------Other Hardware Equates --------------------------------------------------------- 
00000000                           235  
00000000  =00000080                236  HOLD_STATE  EQU      $80                    ;Set Keyboard flag to indicate a Pause is required
00000000  =0000007F                237  NO_HOLD_STATE       EQU      $7F            ;To clear the above flag
00000000                           238  
00000000  =00FF00EE                239  SW68K       EQU      $00FF00EE              ;OUTPUT TO THIS PORT 02H, SWITCHES THE 68000 CPU BACK to the Z80 in hardware
00000000                           240              ;In my system using the V2 SMB.
00000000                           241  
00000000                           242  
00000000                           243  ;------------------ START --------------------------------------------------------------------------------
00000000                           244  
00000000                           245  
00000000                 TRUE      246     IFNE ROM_CODE    ;If ROM_CODE = 1 (Use with ROM)
00FD0000                           247              ORG     $00FD0000
00FD0000                           248              
00FD0000= 00FD8100                 249              DC.L    $00FD8100               ;SSP = FD8100H
00FD0004= 00FD0020                 250              DC.L    $00FD0020               ;PC = FD1020H  
00FD0008                           251  
00FD0020                           252              ORG     $00FD0020               ;Will start monitor here in ROM
00FD0020                           253     ENDC
00FD0020                           254     
00FD0020                 FALSE     255     IFNE SIMMULATOR  ;If SIMMULATOR = 1 (Use for testing in EASy68K simulator)
00FD0020                           256     ENDC     
00FD0020                           257   
00FD0020                 FALSE     258       IFNE S100_TEST ;If SIMMULATOR = 1 (Use for testing, for S100 RAM use the ROM stack)
00FD0020                           259     ENDC     
00FD0020                           260  
00FD0020                           261     
00FD0020  207C 00FF0000            262              MOVE.L  #KEYSTAT,A0             ;Point to status Port 0H (CRT, Propeller Console IO Board)
00FD0026  227C 00FF0001            263              MOVE.L  #KEYIN,A1               ;Point to hardware Port 01H (CRT, Propeller Console IO Board)
00FD002C                           264  START:      
00FD002C  45F9 00FD1FC4            265              LEA     Signon,A2               ;Show we are alive
00FD0032  6100 1D6E                266              BSR     PRINT_STRING
00FD0036                           267      
00FD0036  6100 1E68                268              BSR     SERIAL_INITILIZE_A      ;Initilize Consoel-IO board Serial Port A
00FD003A  6100 1E7E                269              BSR     SERIAL_INITILIZE_B      ;Initilize Consoel-IO board Serial Port B
00FD003E  45F9 00FD2108            270              LEA     SMSG,A2                 
00FD0044                           271  ;           BSR     SPEAK_STRING            ;Speak out signon the message
00FD0044                           272  
00FD0044  6100 056A                273              BSR     LOW_RAM_INITILIZE       ;Initilize low RAM Int Vectors (for all modes)
00FD0048                           274   
00FD0048                           275              ;Initilize HIGH RAM to 0  (Used by IDE Routines)
00FD0048  45F9 00FD8100            276              LEA     BeginRAM,A2             ;START OF WORK RAM (PAST STACK)
00FD004E  203C 0000041C            277              MOVE.L  #(EndRAM-BeginRAM),D0   ;BYTES TO ZERO
00FD0054  4281                     278              CLR.L   D1
00FD0056                           279              
00FD0056  14C1                     280  ZERO_RAM:   MOVE.B  D1,(A2)+                ;ZERO MEMORY
00FD0058  5380                     281              SUBQ.L  #1,D0
00FD005A  66FA                     282              BNE     ZERO_RAM
00FD005C                           283     
00FD005C                           284     
00FD005C  45F9 00FD1FF4            285  loop:       LEA     Prompt,A2               ;Show CR,LF,'>'
00FD0062  6100 1D3E                286              BSR     PRINT_STRING
00FD0066  4281                     287              CLR.L   D1                      ;Just to be on the safe side
00FD0068  6100 1C62                288              BSR     GETCHAR                 ;Get a menu character (WITH ECHO)
00FD006C  C23C 007F                289              AND.B   #$7F,D1                 ;Just to be safe, strip any potential parity bit
00FD0070  6100 1D66                290              BSR     TOUPPER                 ;Lower case to Upper case for lookup table
00FD0074                           291              
00FD0074  B23C 0041                292              CMP.B   #'A',D1
00FD0078  6D00 001C                293              BLT     ERR
00FD007C  B23C 005A                294              CMP.B   #'Z',D1
00FD0080  6E00 0014                295              BGT     ERR
00FD0084  0401 0041                296              SUB.B   #'A',D1
00FD0088  E589                     297              LSL.L   #2,D1                   ;X4 for offset into table
00FD008A  45F9 00FD1ED4            298              LEA     ctable,A2               ;Start of cmd table
00FD0090  2672 1000                299              MOVE.L  (A2,D1),A3              ;Add X4 offset
00FD0094  4ED3                     300              JMP     (A3)
00FD0096                           301              
00FD0096                           302  ;-----------------------------------------------------------------------------------------------------
00FD0096  B23C 000D                303  ERR:        CMP.B   #CR,D1                  ;If CR just return
00FD009A  67C0                     304              BEQ     loop
00FD009C  2F01                     305              MOVE.L  D1,-(A7)                ;> Save D1
00FD009E  45F9 00FD2140            306              LEA     BadCmdMsg,A2            ;Non menu selection
00FD00A4  6100 1CFC                307              BSR     PRINT_STRING
00FD00A8  2E1F                     308              MOVE.L  (A7)+,D7                ;Put D1 in D7
00FD00AA  6100 1B4A                309              BSR     PUTLONG_D7
00FD00AE  45F9 00FD307C            310              LEA     H_MSG_CRLF,A2           ;H, then CR,LF
00FD00B4  6100 1CEC                311              BSR     PRINT_STRING
00FD00B8  60A2                     312              BRA     loop                    ;Back to start for next command
00FD00BA                           313              
00FD00BA                           314  ;------------------------------------------------------------------------------------------------------
00FD00BA                           315  SHOW_MENU:  ;Display this monitors commands on CRT
00FD00BA  45F9 00FD1FF8            316              LEA     Menu,A2                 ;Menu string
00FD00C0  6100 1CE0                317              BSR     PRINT_STRING
00FD00C4  6096                     318              BRA     loop                    ;Back to start for next command
00FD00C6                           319              
00FD00C6                           320  
00FD00C6                           321  ;------------------------------------------------------------------------------------------------------
00FD00C6  267C 00000000            322  MEM_MAP:    MOVE.L  #0,A3                   ;A Command.   Do Memory Map. Pointer to RAM area A3=0
00FD00CC  6100 1CE4                323  NEWLINE:    BSR     CRLF
00FD00D0  2E0B                     324              MOVE.L  A3,D7
00FD00D2  6100 1B22                325              BSR     PUTLONG_D7              ;Print long value of D7
00FD00D6  7640                     326              MOVE.L  #64,D3                  ;64 characters across per line
00FD00D8  7AFF                     327              MOVE.L  #$FFFFFFFF,D5
00FD00DA                           328              
00FD00DA  123C 0020                329              MOVE.B  #BLANK,D1
00FD00DE  6100 1BBA                330              BSR     PUTCHAR
00FD00E2                           331              
00FD00E2  2213                     332  START1:     MOVE.L  (A3),D1                 ;Is there RAM/ROM there
00FD00E4  4681                     333              NOT.L   D1
00FD00E6  2681                     334              MOVE.L  D1,(A3)                 ;See if we can flip bits
00FD00E8  2C13                     335              MOVE.L  (A3),D6
00FD00EA  BC81                     336              CMP.L   D1,D6
00FD00EC  6600 000E                337              BNE     NOT_RAM
00FD00F0  4681                     338              NOT.L   D1                      ;Put back origional data
00FD00F2  2681                     339              MOVE.L  D1,(A3)
00FD00F4  123C 0052                340              MOVE.B  #'R',D1
00FD00F8  6000 0016                341              BRA     DONE_TEST
00FD00FC                           342              
00FD00FC  2213                     343  NOT_RAM:    MOVE.L  (A3),D1                 ;Is there RAM/ROM there
00FD00FE  B285                     344              CMP.L   D5,D1                   ;Chances are it is empty if FFFFF's!
00FD0100  6700 000A                345              BEQ     EMPTY
00FD0104  123C 0070                346              MOVE.B  #'p',D1
00FD0108  6000 0006                347              BRA     DONE_TEST
00FD010C  123C 002E                348  EMPTY:      MOVE.B  #'.',D1
00FD0110  6100 1B88                349  DONE_TEST:  BSR     PUTCHAR
00FD0114                           350              
00FD0114  D7FC 00002000            351              ADD.L   #$2000,A3               ;No matter what point to next 2K byte section
00FD011A                           352              
00FD011A  5383                     353              SUBQ.L  #1,D3
00FD011C  4A83                     354              TST.L   D3                      ;Have we done 32X2 characters across
00FD011E  67AC                     355              BEQ     NEWLINE
00FD0120                           356              
00FD0120  280B                     357              MOVE.L  A3,D4
00FD0122  B8BC 00FE0000            358              CMP.L   #$00FE0000,D4           ;Have we done all the RAM area
00FD0128  6FB8                     359              BLE     START1
00FD012A  6000 FF30                360              BRA     LOOP                    ;Back to start of menu
00FD012E                           361  
00FD012E                           362  
00FD012E                           363  ;-----------------------------------------------------------------------------------------------------
00FD012E                           364  
00FD012E                           365  DISPLAY_RAM:;D Command. Display Bytes in RAM
00FD012E  6100 1A16                366              BSR     GETLONG_D7              ;Get start address
00FD0132  B43C 002C                367              CMP.B   #',',D2                 ;Is it valid
00FD0136  6600 1CB6                368              BNE     ERROR
00FD013A  2647                     369              MOVE.L  D7,A3                   ;Save in A3
00FD013C                           370              
00FD013C  6100 1A08                371              BSR     GETLONG_D7              ;End address
00FD0140  B43C 000D                372              CMP.B   #CR,D2                  ;Is it valid
00FD0144  6600 1CA8                373              BNE     ERROR
00FD0148  2847                     374              MOVE.L  D7,A4                   ;Save in A4
00FD014A                           375              
00FD014A  B9CB                     376              CMP.L   A3,A4
00FD014C  6700 FF0E                377              BEQ     LOOP                    ;If the same nothing to display
00FD0150  6C00 0008                378              BGE     PARMS_OK
00FD0154  2A4B                     379              MOVE.L  A3,A5                   ;Else swap values
00FD0156  264C                     380              MOVE.L  A4,A3
00FD0158  384D                     381              MOVE    A5,A4
00FD015A                           382  
00FD015A  528C                     383  PARMS_OK:   ADD.L   #1,A4                   ;End + 1
00FD015C  2F0B                     384  PARMS_OK5:  MOVE.L  A3,-(A7)                ;Save A3
00FD015E  2F0C                     385              MOVE.L  A4,-(A7)                ;Save A4
00FD0160                           386              
00FD0160  6100 1C50                387  PARMS_OK2:  BSR     CRLF                    ;New line
00FD0164  2E0B                     388              MOVE.L  A3,D7
00FD0166  6100 1A8E                389              BSR     PUTLONG_D7              ;Show current address
00FD016A  6100 1C62                390              BSR     SPACE
00FD016E  183C 0010                391              MOVE.B  #16,D4                  ;Count of characters across
00FD0172                           392  
00FD0172  1C13                     393  PARMS_OK1:  MOVE.B  (A3),D6                 ;Get RAM byte to D6
00FD0174  6100 1AC2                394              BSR     PUTBYTE_D6              ;Show Byte value
00FD0178  6100 1C54                395              BSR     SPACE
00FD017C                           396  
00FD017C  528B                     397              ADDQ.L  #1,A3                   ;Shift pointer up one
00FD017E  5304                     398              SUBQ.B  #1,D4                   ;Have we done 16 characters across
00FD0180  4A04                     399              TST.B   D4
00FD0182  66EE                     400              BNE     PARMS_OK1               ;Not 16 across, then next byte
00FD0184                           401              
00FD0184  285F                     402              MOVE.L  (A7)+,A4                ;Next Show ASCII for this line, Back to origional RAM location
00FD0186  265F                     403              MOVE.L  (A7)+,A3                ;Were stored above
00FD0188  6100 1C44                404              BSR     SPACE
00FD018C  6100 1C40                405              BSR     SPACE
00FD0190  183C 0010                406              MOVE.B  #16,D4                  ;Count of characters across
00FD0194                           407              
00FD0194  1213                     408  PARMS_OK4:  MOVE.B  (A3),D1                 ;Get RAM byte to D1
00FD0196  B23C 0020                409              CMP.B   #' ',D1
00FD019A  6D00 001E                410              BLT     PRINT_DOT
00FD019E  B23C 007F                411              CMP.B   #$7F,D1
00FD01A2  6C00 0016                412              BGE     PRINT_DOT
00FD01A6  6100 1AF2                413  PARMS_OK6   BSR     PUTCHAR                 ;Print character
00FD01AA                           414  
00FD01AA  528B                     415              ADDQ.L  #1,A3
00FD01AC  5304                     416              SUBQ.B  #1,D4                   
00FD01AE  4A04                     417              TST.B   D4                      ;Have we done 16 characters across
00FD01B0  66E2                     418              BNE     PARMS_OK4
00FD01B2                           419              
00FD01B2  B9CB                     420              CMP.L   A3,A4                   ;Are we done wit total data display yet
00FD01B4  6F00 FEA6                421              BLE     LOOP
00FD01B8  60A2                     422              BRA     PARMS_OK5
00FD01BA                           423              
00FD01BA                           424  PRINT_DOT:
00FD01BA  123C 002E                425              MOVE.B  #'.',D1
00FD01BE  60E6                     426              BRA     PARMS_OK6
00FD01C0                           427              
00FD01C0                           428              
00FD01C0                           429  ;----------------------------------------------------------------------------------------------------
00FD01C0                           430  
00FD01C0                           431  FILL_RAM:   ;F Command. Fill RAM with one byte value
00FD01C0  6100 1984                432              BSR     GETLONG_D7              ;Get start address
00FD01C4  B43C 002C                433              CMP.B   #',',D2                 ;Is it valid
00FD01C8  6600 1C24                434              BNE     ERROR
00FD01CC  2647                     435              MOVE.L  D7,A3                   ;Save in A3
00FD01CE                           436              
00FD01CE  6100 1976                437              BSR     GETLONG_D7              ;End address
00FD01D2  B43C 002C                438              CMP.B   #',',D2                 ;Is it valid
00FD01D6  6600 1C16                439              BNE     ERROR
00FD01DA  2847                     440              MOVE.L  D7,A4                   ;Save in A4
00FD01DC                           441              
00FD01DC  B9CB                     442              CMP.L   A3,A4
00FD01DE  6700 FE7C                443              BEQ     LOOP                    ;If the same nothing to display
00FD01E2  6C00 0008                444              BGE     FILL_OK
00FD01E6  2A4B                     445              MOVE.L  A3,A5                   ;Else swap values
00FD01E8  264C                     446              MOVE.L  A4,A3
00FD01EA  384D                     447              MOVE    A5,A4
00FD01EC                           448  
00FD01EC  528C                     449  FILL_OK:    ADD.L   #1,A4                   ;End + 1
00FD01EE  6100 199E                450              BSR     GETBYTE_D7              ;get Hex value in D7 (0-FF)
00FD01F2  B43C 000D                451              CMP.B   #CR,D2                  ;Is it valid
00FD01F6  6600 1BF6                452              BNE     ERROR
00FD01FA                           453  
00FD01FA  1687                     454  FILL_OK1:   MOVE.B  D7,(A3)                 ;D7 to RAM 
00FD01FC  528B                     455              ADDQ.L  #1,A3
00FD01FE  B9CB                     456              CMP.L   A3,A4                   ;Are we done yet
00FD0200  6F00 FE5A                457              BLE     LOOP
00FD0204  60F4                     458              BRA     FILL_OK1
00FD0206                           459              
00FD0206                           460  
00FD0206                           461  
00FD0206                           462              
00FD0206                           463  ;----------------------------------------------------------------------------------------------------
00FD0206                           464  
00FD0206                           465  SUBS_RAM:   ;S Command. Substitute RAM with one byte values
00FD0206  6100 193E                466              BSR     GETLONG_D7              ;Get start address
00FD020A  B43C 000D                467              CMP.B   #CR,D2                  ;Is it valid
00FD020E  6600 1BDE                468              BNE     ERROR
00FD0212  2647                     469              MOVE.L  D7,A3                   ;--- Save in A3 (also leave in A7)
00FD0214                           470              
00FD0214  6100 1B9C                471  SUBS_RAM2:  BSR     CRLF                    ;New line
00FD0218  2E0B                     472              MOVE.L  A3,D7
00FD021A  6100 19DA                473              BSR     PUTLONG_D7              ;Show current address
00FD021E  123C 0020                474              MOVE.B  #BLANK,D1
00FD0222  6100 1A76                475              BSR     PUTCHAR
00FD0226                           476              
00FD0226  183C 0008                477              MOVE.B  #8,D4                   ;Count of characters across
00FD022A                           478  
00FD022A  1C13                     479  SUBS_RAM3:  MOVE.B  (A3),D6
00FD022C  6100 1A0A                480              BSR     PUTBYTE_D6              ;Display current byte
00FD0230                           481              
00FD0230  6100 195C                482              BSR     GETBYTE_D7              ;Get new Hex value in D7 (0-FF) 
00FD0234  B43C 001B                483              CMP.B   #ESC,D2                 ;If ESC then we are done
00FD0238  6700 FE22                484              BEQ     LOOP
00FD023C  B43C 000D                485              CMP.B   #CR,D2                  ;Also CR we are done
00FD0240  6700 FE1A                486              BEQ     LOOP
00FD0244  4A03                     487              TST.B   D3                      ;Is byte count = 0 from GETBYTE_D7 above then no update
00FD0246  6700 0008                488              BEQ     SUBS_RAM1               ;Is already on screen
00FD024A                           489              
00FD024A  1687                     490              MOVE.B  D7,(A3)                 ;Substitute in the byte
00FD024C  6000 000E                491              BRA     SUBS_RAM4
00FD0250                           492              
00FD0250  123C 0020                493  SUBS_RAM1:  MOVE.B  #' ',D1
00FD0254  6100 1A44                494              BSR     PUTCHAR
00FD0258  6100 1A40                495              BSR     PUTCHAR
00FD025C  6100 1A3C                496  SUBS_RAM4:  BSR     PUTCHAR
00FD0260                           497  
00FD0260  528B                     498              ADDQ.L  #1,A3                   ;Next byte
00FD0262  5304                     499              SUBQ.B  #1,D4
00FD0264  66C4                     500              BNE     SUBS_RAM3
00FD0266  60AC                     501              BRA     SUBS_RAM2
00FD0268                           502              
00FD0268                           503  
00FD0268                           504  ;----------------------------------------------------------------------------------------------------
00FD0268                           505  
00FD0268                           506  MOVE_RAM:   ;M Command. Move RAM
00FD0268  6100 18DC                507              BSR     GETLONG_D7              ;Get start address
00FD026C  B43C 002C                508              CMP.B   #',',D2                 ;Is it valid
00FD0270  6600 1B7C                509              BNE     ERROR
00FD0274  2647                     510              MOVE.L  D7,A3                   ;Save in A3
00FD0276                           511              
00FD0276  6100 18CE                512              BSR     GETLONG_D7              ;End address
00FD027A  B43C 002C                513              CMP.B   #',',D2                 ;Is it valid
00FD027E  6600 1B6E                514              BNE     ERROR
00FD0282  2847                     515              MOVE.L  D7,A4                   ;Save in A4
00FD0284                           516              
00FD0284  B9CB                     517              CMP.L   A3,A4
00FD0286  6700 FDD4                518              BEQ     LOOP                    ;If the same nothing to display
00FD028A  6C00 0008                519              BGE     MOVE_OK
00FD028E  2A4B                     520              MOVE.L  A3,A5                   ;Else swap values
00FD0290  264C                     521              MOVE.L  A4,A3
00FD0292  384D                     522              MOVE    A5,A4
00FD0294                           523  
00FD0294  528C                     524  MOVE_OK:    ADD.L   #1,A4                   ;End + 1
00FD0296  6100 18AE                525              BSR     GETLONG_D7              ;End address
00FD029A  B43C 000D                526              CMP.B   #CR,D2                  ;Is it valid
00FD029E  6600 1B4E                527              BNE     ERROR
00FD02A2  2A47                     528              MOVE.L  D7,A5                   ;Save in A5
00FD02A4                           529  
00FD02A4  1ADB                     530  MOVE_OK1:   MOVE.B  (A3)+,(A5)+
00FD02A6  B9CB                     531              CMP.L   A3,A4
00FD02A8  6CFA                     532              BGE     MOVE_OK1
00FD02AA  6000 FDB0                533              BRA     LOOP
00FD02AE                           534              
00FD02AE                           535  
00FD02AE                           536  ;----------------------------------------------------------------------------------------------------
00FD02AE                           537  
00FD02AE                           538  QUERY_PORT:
00FD02AE  4281                     539              CLR.L   D1                      ;Just to be on the safe side
00FD02B0  6100 1A1A                540              BSR     GETCHAR                 ;get a menu character
00FD02B4  6100 1B22                541              BSR     TOUPPER                 ;Lower case to Upper case
00FD02B8                           542  
00FD02B8  B23C 0049                543              CMP.B   #'I',D1                 ;Is it a port input request
00FD02BC  6700 000E                544              BEQ     QUERY_IN
00FD02C0  B23C 004F                545              CMP.B   #'O',D1                 ;Is it a port output request
00FD02C4  6700 0078                546              BEQ     QUERY_OUT
00FD02C8  6000 1B24                547              BRA     ERROR                   ;Must be an error
00FD02CC                           548  
00FD02CC  6100 1878                549  QUERY_IN:   BSR     GETLONG_D7              ;Get (Byte only) Port Hex value in D7 (0-FF) 
00FD02D0  4A03                     550              TST.B   D3                      ;Byte count > 0
00FD02D2  6700 FD88                551              BEQ     LOOP
00FD02D6  B43C 001B                552              CMP.B   #ESC,D2                 ;If ESC then we abort
00FD02DA  6700 FD80                553              BEQ     LOOP
00FD02DE  B43C 000D                554              CMP.B   #CR,D2                  ;If CR then we also abort
00FD02E2  6600 1B0A                555              BNE     ERROR
00FD02E6  1C07                     556              MOVE.B  D7,D6                   ;store in D6 (also in D7)
00FD02E8                           557              
00FD02E8  45F9 00FD2173            558              LEA     PortMsg,A2              ;'Port xx'
00FD02EE  6100 1AB2                559              BSR     PRINT_STRING
00FD02F2  6100 1944                560              BSR     PUTBYTE_D6              ;Display Port value
00FD02F6  123C 0048                561              MOVE.B  #'H',D1                 ;'H'
00FD02FA  6100 199E                562              BSR     PUTCHAR
00FD02FE  123C 003D                563              MOVE.B  #'=',D1                 ;'='
00FD0302  6100 1996                564              BSR     PUTCHAR
00FD0306                           565              
00FD0306  2C3C 00FF0000            566              MOVE.L  #$00FF0000,D6           ;Point to Port RAM area
00FD030C  8C07                     567              OR.B    D7,D6                   ;OR in the hardware value
00FD030E  2446                     568              MOVE.L  D6,A2                   ;A2 now has port address
00FD0310  1C12                     569              MOVE.B  (A2),D6                 ;Get value at port
00FD0312                           570              
00FD0312  6100 1924                571              BSR     PUTBYTE_D6              ;Display Byte value
00FD0316  123C 0048                572              MOVE.B  #'H',D1                 ;'H'
00FD031A  6100 197E                573              BSR     PUTCHAR
00FD031E  123C 0020                574              MOVE.B  #' ',D1                 ;' '
00FD0322  6100 1976                575              BSR     PUTCHAR
00FD0326  123C 0028                576              MOVE.B  #'(',D1                 ;'('
00FD032A  6100 196E                577              BSR     PUTCHAR
00FD032E  6100 1938                578              BSR     PUTBITS_D6
00FD0332  123C 0029                579              MOVE.B  #')',D1                 ;')'
00FD0336  6100 1962                580              BSR     PUTCHAR
00FD033A  6000 FD20                581              BRA     LOOP
00FD033E                           582  
00FD033E                           583              
00FD033E                           584  QUERY_OUT:  
00FD033E  6100 1806                585              BSR     GETLONG_D7              ;Get Port value (value in D7, 0-FFFF) 
00FD0342  4A03                     586              TST.B   D3                      ;Byte count > 0
00FD0344  6700 FD16                587              BEQ     LOOP
00FD0348  B43C 001B                588              CMP.B   #ESC,D2                 ;If ESC then we abort
00FD034C  6700 FD0E                589              BEQ     LOOP
00FD0350  B43C 002C                590              CMP.B   #',',D2                 ;If CR then we also abort
00FD0354  6600 1A98                591              BNE     ERROR
00FD0358  2807                     592              MOVE.L  D7,D4                   ;<<< Store (WORD) port # in D4 
00FD035A                           593              
00FD035A  6100 1832                594              BSR     GETBYTE_D7              ;Get data in D7 (0-FF) 
00FD035E  4A03                     595              TST.B   D3                      ;Byte count > 0
00FD0360  6700 FCFA                596              BEQ     LOOP
00FD0364  B43C 001B                597              CMP.B   #ESC,D2                 ;If ESC then we are done
00FD0368  6700 FCF2                598              BEQ     LOOP
00FD036C  B43C 000D                599              CMP.B   #CR,D2                  ;If CR then we are done
00FD0370  6600 FCEA                600              BNE     LOOP
00FD0374  2A07                     601              MOVE.L  D7,D5                   ;<<< Store data (BYTE) to send to port in D5 
00FD0376                           602              
00FD0376  45F9 00FD217B            603              LEA     PortMsg2,A2             ;'Send to Port xxxx'
00FD037C  6100 1A24                604              BSR     PRINT_STRING
00FD0380  2C04                     605              MOVE.L  D4,D6
00FD0382  6100 1882                606              BSR     PUTWORD_D6              ;Display Port value (as a word)
00FD0386  123C 0048                607              MOVE.B  #'H',D1                 ;'H'
00FD038A  6100 190E                608              BSR     PUTCHAR
00FD038E  123C 002D                609              MOVE.B  #'-',D1                 ;'-'
00FD0392  6100 1906                610              BSR     PUTCHAR
00FD0396  123C 003E                611              MOVE.B  #'>',D1                 ;'>'
00FD039A  6100 18FE                612              BSR     PUTCHAR
00FD039E                           613              
00FD039E                           614              
00FD039E  1C05                     615              MOVE.B  D5,D6
00FD03A0  6100 1896                616              BSR     PUTBYTE_D6              ;Display Byte value
00FD03A4  123C 0048                617              MOVE.B  #'H',D1                 ;'H'
00FD03A8  6100 18F0                618              BSR     PUTCHAR
00FD03AC                           619  
00FD03AC  2C3C 00FF0000            620              MOVE.L  #$00FF0000,D6           ;Point to Port RAM area
00FD03B2  8C04                     621              OR.B    D4,D6                   ;OR in the hardware value
00FD03B4  2446                     622              MOVE.L  D6,A2                   ;A2 now has port address
00FD03B6  1485                     623              MOVE.B  D5,(A2)                 ;Send actual data to port
00FD03B8  6000 FCA2                624              BRA     LOOP
00FD03BC                           625  
00FD03BC                           626  
00FD03BC                           627  ;-----------------------------------------------------------------------------------------------------
00FD03BC                           628  
00FD03BC                           629  ASCII_RAM:  ;T Command. Display ASCII in RAM
00FD03BC                           630              
00FD03BC  6100 1788                631              BSR     GETLONG_D7              ;Get start address
00FD03C0  B43C 002C                632              CMP.B   #',',D2                 ;Is it valid
00FD03C4  6600 1A28                633              BNE     ERROR
00FD03C8  2647                     634              MOVE.L  D7,A3                   ;Save in A3
00FD03CA                           635              
00FD03CA  6100 177A                636              BSR     GETLONG_D7              ;End address
00FD03CE  B43C 000D                637              CMP.B   #CR,D2                  ;Is it valid
00FD03D2  6600 1A1A                638              BNE     ERROR
00FD03D6  2847                     639              MOVE.L  D7,A4                   ;Save in A4
00FD03D8                           640              
00FD03D8  B9CB                     641              CMP.L   A3,A4
00FD03DA  6700 FC80                642              BEQ     LOOP                    ;If the same nothing to display
00FD03DE  6C00 0008                643              BGE     ASCII_OK
00FD03E2  2A4B                     644              MOVE.L  A3,A5                   ;Else swap values
00FD03E4  264C                     645              MOVE.L  A4,A3
00FD03E6  384D                     646              MOVE    A5,A4
00FD03E8                           647  
00FD03E8  6100 19C8                648  ASCII_OK:   BSR     CRLF                    ;New line
00FD03EC  2E0B                     649              MOVE.L  A3,D7
00FD03EE  6100 1806                650              BSR     PUTLONG_D7              ;Show current address
00FD03F2  123C 0020                651              MOVE.B  #BLANK,D1
00FD03F6  6100 18A2                652              BSR     PUTCHAR
00FD03FA  183C 0020                653              MOVE.B  #32,D4                  ;Count of characters across
00FD03FE                           654  
00FD03FE  1213                     655  ASCII_OK1:  MOVE.B  (A3),D1                 ;Get RAM byte to D6
00FD0400  B23C 0020                656              CMP.B   #' ',D1
00FD0404  6D00 001E                657              BLT     UNPRINTABLE
00FD0408  B23C 007F                658              CMP.B   #$7F,D1
00FD040C  6C00 0016                659              BGE     UNPRINTABLE
00FD0410                           660              
00FD0410  6100 1888                661  ASCII_OK2:  BSR     PUTCHAR
00FD0414                           662              
00FD0414  5304                     663              SUBQ.B  #1,D4                   ;Have we done 64 characters across
00FD0416  4A04                     664              TST.B   D4
00FD0418  67CE                     665              BEQ     ASCII_OK
00FD041A                           666              
00FD041A  528B                     667              ADDQ.L  #1,A3
00FD041C  B9CB                     668              CMP.L   A3,A4                   ;Are we done yet
00FD041E  6F00 FC3C                669              BLE     LOOP
00FD0422  60DA                     670              BRA     ASCII_OK1
00FD0424                           671  UNPRINTABLE:
00FD0424  123C 002E                672              MOVE.B  #'.',D1
00FD0428  60E6                     673              BRA     ASCII_OK2
00FD042A                           674              
00FD042A                           675  ;----------------------------------------------------------------------------------------------------
00FD042A                           676  
00FD042A                           677  VERIFY_RAM: ;M Command. Verify two RAM locations have the same data
00FD042A  6100 171A                678              BSR     GETLONG_D7              ;Get start address
00FD042E  B43C 002C                679              CMP.B   #',',D2                 ;Is it valid
00FD0432  6600 19BA                680              BNE     ERROR
00FD0436  2647                     681              MOVE.L  D7,A3                   ;--- Save in A3
00FD0438                           682              
00FD0438  6100 170C                683              BSR     GETLONG_D7              ;End address
00FD043C  B43C 002C                684              CMP.B   #',',D2                 ;Is it valid
00FD0440  6600 19AC                685              BNE     ERROR
00FD0444  2847                     686              MOVE.L  D7,A4                   ;--- Save in A4
00FD0446                           687              
00FD0446  B9CB                     688              CMP.L   A3,A4
00FD0448  6700 FC12                689              BEQ     LOOP                    ;If the same nothing to display
00FD044C  6C00 0008                690              BGE     VERIFY_OK
00FD0450  2A4B                     691              MOVE.L  A3,A5                   ;Else swap values
00FD0452  264C                     692              MOVE.L  A4,A3
00FD0454  384D                     693              MOVE    A5,A4
00FD0456                           694  
00FD0456  528C                     695  VERIFY_OK:  ADD.L   #1,A4                   ;End + 1
00FD0458  6100 16EC                696              BSR     GETLONG_D7              ;End address
00FD045C  B43C 000D                697              CMP.B   #CR,D2                  ;Is it valid
00FD0460  6600 198C                698              BNE     ERROR
00FD0464  2A47                     699              MOVE.L  D7,A5                   ;--- Save in A5
00FD0466                           700  
00FD0466  BB0B                     701  VERIFY_OK1: CMP.B   (A3)+,(A5)+
00FD0468  6600 000A                702              BNE     BAD_MATCH
00FD046C  B9CB                     703  VERIFY_OK2: CMP.L   A3,A4                   ;Are we done yet
00FD046E  6CF6                     704              BGE     VERIFY_OK1
00FD0470  6000 FBEA                705              BRA     LOOP
00FD0474                           706              
00FD0474  6100 193C                707  BAD_MATCH:  BSR     CRLF                    ;New line
00FD0478  2E0B                     708              MOVE.L  A3,D7
00FD047A  5387                     709              SUBQ.L  #1,D7                   ;Backup to problem
00FD047C  2647                     710              MOVE.L  D7,A3
00FD047E  6100 1776                711              BSR     PUTLONG_D7              ;Show first address
00FD0482  123C 0020                712              MOVE.B  #BLANK,D1
00FD0486  6100 1812                713              BSR     PUTCHAR
00FD048A  1C1B                     714              MOVE.B  (A3)+,D6
00FD048C  6100 17AA                715              BSR     PUTBYTE_D6
00FD0490  123C 0020                716              MOVE.B  #BLANK,D1
00FD0494                           717              
00FD0494  6100 1804                718              BSR     PUTCHAR
00FD0498  6100 1800                719              BSR     PUTCHAR
00FD049C                           720              
00FD049C  2E0D                     721              MOVE.L  A5,D7
00FD049E  5387                     722              SUBQ.L  #1,D7                   ;Backup to problem
00FD04A0  2A47                     723              MOVE.L  D7,A5
00FD04A2  6100 1752                724              BSR     PUTLONG_D7              ;Show first address
00FD04A6  123C 0020                725              MOVE.B  #BLANK,D1
00FD04AA  6100 17EE                726              BSR     PUTCHAR
00FD04AE  1C1D                     727              MOVE.B  (A5)+,D6
00FD04B0  6100 1786                728              BSR     PUTBYTE_D6
00FD04B4  6100 18FC                729              BSR     CRLF
00FD04B8  60B2                     730              BRA     VERIFY_OK2
00FD04BA                           731              
00FD04BA                           732              
00FD04BA                           733              
00FD04BA                           734  ;----------------------------------------------------------------------------------------------------
00FD04BA                           735  
00FD04BA                           736  ECHO_ASCII: ;E Command. Get ASCII typed on keyboard and display on Console
00FD04BA  45F9 00FD245B            737              LEA     ECHO_MSG,A2             ;"Will echo each keyboard char on screen"
00FD04C0  6100 18E0                738              BSR     PRINT_STRING
00FD04C4                           739  
00FD04C4  6100 18EC                740              BSR     CRLF                    ;New line
00FD04C8  4281                     741  ECHO2:      CLR.L   D1                      ;Just to be on the safe side
00FD04CA  6100 1800                742              BSR     GETCHAR                 ;get a character
00FD04CE                           743              
00FD04CE  B23C 001B                744              CMP.B   #ESC,D1                 ;If ESC then we abort
00FD04D2  6700 FB88                745              BEQ     LOOP
00FD04D6  B23C 000D                746              CMP.B   #CR,D1                  ;If CR then we also abort
00FD04DA  6700 FB80                747              BEQ     LOOP
00FD04DE                           748  
00FD04DE  B23C 0020                749              CMP.B   #' ',D1
00FD04E2  6D00 0010                750              BLT     NOASCII
00FD04E6  B23C 007F                751              CMP.B   #$7F,D1
00FD04EA  6C00 0008                752              BGE     NOASCII
00FD04EE  6100 17AA                753  ECHO1:      BSR     PUTCHAR                 ;Echo character
00FD04F2  60D4                     754              BRA     ECHO2
00FD04F4                           755  
00FD04F4  123C 002E                756  NOASCII:    MOVE.B  #'.',D1
00FD04F8  60F4                     757              BRA     ECHO1
00FD04FA                           758              
00FD04FA                           759  
00FD04FA                           760  ;----------------------------------------------------------------------------------------------------
00FD04FA                           761  
00FD04FA                           762  GOTO_RAM:   ;G Command . Go to a location in RAM and start from there.
00FD04FA  6100 164A                763              BSR     GETLONG_D7              ;Go to address in D7
00FD04FE  B43C 000D                764              CMP.B   #CR,D2                  ;Is it valid
00FD0502  6600 18EA                765              BNE     ERROR
00FD0506  2647                     766              MOVE.L  D7,A3                   ;Save in A3
00FD0508  4ED3                     767              JMP     (A3)                    ;That's all there is to it!
00FD050A                           768              
00FD050A                           769  
00FD050A                           770  
00FD050A                           771  ;----------------------------------------------------------------------------------------------------
00FD050A                           772  
00FD050A                           773  HEX_MATH:   ;H Command.      Add/subtract two hex mumbers.
00FD050A  6100 163A                774              BSR     GETLONG_D7              ;Get First number
00FD050E  B43C 002C                775              CMP.B   #',',D2                 ;Is it valid
00FD0512  6600 18DA                776              BNE     ERROR
00FD0516  2807                     777              MOVE.L  D7,D4                   ;Save in D4
00FD0518                           778              
00FD0518  6100 162C                779              BSR     GETLONG_D7              ;Get second number
00FD051C  B43C 000D                780              CMP.B   #CR,D2                  ;Is it valid
00FD0520  6600 18CC                781              BNE     ERROR
00FD0524  2A07                     782              MOVE.L  D7,D5                   ;Save in D5
00FD0526  3C07                     783              MOVE    D7,D6
00FD0528                           784              
00FD0528  45F9 00FD21C5            785              LEA     HEX_Data,A2             ;Hex data = string
00FD052E  6100 1872                786              BSR     PRINT_STRING
00FD0532  DC87                     787              ADD.L   D7,D6                   :Total in D6
00FD0534  2E06                     788              MOVE.L  D6,D7
00FD0536  6100 16BE                789              BSR     PUTLONG_D7
00FD053A                           790              
00FD053A  45F9 00FD21CE            791              LEA     HEX_Data2,A2            ;Difference =
00FD0540  6100 1860                792              BSR     PRINT_STRING
00FD0544  9A84                     793              SUB.L   D4,D5
00FD0546  2E05                     794              MOVE.L  D5,D7
00FD0548  6100 16AC                795              BSR     PUTLONG_D7
00FD054C  45F9 00FD307C            796              LEA     H_MSG_CRLF,A2           ;'H'
00FD0552  6100 184E                797              BSR     PRINT_STRING
00FD0556  6000 FB04                798              BRA     LOOP
00FD055A                           799  
00FD055A                           800  
00FD055A                           801  ;----------------------------------------------------------------------------------------------------
00FD055A                           802  
00FD055A                           803  TEST_INTS:  ;L Command setup interrupt vectors in RAM 0 -- 400H
00FD055A  6100 0054                804              BSR     LOW_RAM_INITILIZE       ;Make it a callable routine for later use.
00FD055E  45F9 00FD22FA            805              LEA     INTS_DONE_MSG,A2        ;'Interrupt vectors in RAM (0-400H) initilized'
00FD0564  6100 183C                806              BSR     PRINT_STRING
00FD0568  6100 1762                807              BSR     GETCHAR
00FD056C  6100 186A                808              BSR     TOUPPER
00FD0570  B23C 000D                809              CMP.B   #CR,D1
00FD0574  6600 FAE6                810              BNE     LOOP
00FD0578                           811  
00FD0578  6100 1838                812              BSR     CRLF                    
00FD057C  46FC 2000                813              MOVE.W  #$2000,SR               ;Allow ALL INTERRUPTS, SUPERVISOR MODE
00FD0580  123C 002E                814  INT_LOOP:   MOVE.B  #'.',D1                 ;Continously print .......
00FD0584  6100 1714                815              BSR     PUTCHAR                 ;Echo character
00FD0588  6100 1776                816              BSR     GETSTAT                 ;Is there a keyboard character ready
00FD058C  67F2                     817              BEQ     INT_LOOP
00FD058E  6100 173C                818              BSR     GETCHAR                 ;Get a keyboard character
00FD0592  B23C 001B                819              CMP.B   #ESC,D1                 ;ESC to abort test
00FD0596  6700 000C                820              BEQ     INT_LOOP1
00FD059A  6100 183C                821              BSR     TOUPPER                 ;Lower case to Upper case
00FD059E  6100 16FA                822              BSR     PUTCHAR
00FD05A2  60DC                     823              BRA     INT_LOOP
00FD05A4  46FC 2700                824  INT_LOOP1:  MOVE.W  #$2700,SR               ;MASK OFF INTERRUPTS
00FD05A8  6100 1808                825              BSR     CRLF
00FD05AC  6000 FA7E                826              BRA     START                   ;Reload Monitor
00FD05B0                           827              
00FD05B0                           828              
00FD05B0                           829  
00FD05B0                           830  LOW_RAM_INITILIZE:
00FD05B0  247C 00000008            831              MOVE.L  #$8,A2                  ;Skip (Reset vectors) STACK & ADDRESS vectors etc.
00FD05B6  47F9 00FD0674            832              LEA     BUS_ERROR,A3            ;8H = BUS ERROR
00FD05BC  24CB                     833              MOVE.L  A3,(A2)+                
00FD05BE  47F9 00FD0688            834              LEA     ADDRESS_ERROR,A3        ;CH = ADDRESS
00FD05C4  24CB                     835              MOVE.L  A3,(A2)+                
00FD05C6  47F9 00FD069C            836              LEA     ILLEGAL_ERROR,A3        
00FD05CC  24CB                     837              MOVE.L  A3,(A2)+                
00FD05CE  47F9 00FD06B0            838              LEA     ZERO_ERROR,A3           
00FD05D4  24CB                     839              MOVE.L  A3,(A2)+                
00FD05D6  47F9 00FD069C            840              LEA     ILLEGAL_ERROR,A3        
00FD05DC  24CB                     841              MOVE.L  A3,(A2)+                
00FD05DE  47F9 00FD069C            842              LEA     ILLEGAL_ERROR,A3        
00FD05E4  24CB                     843              MOVE.L  A3,(A2)+                
00FD05E6  47F9 00FD06C4            844              LEA     PRIVILEGE_ERROR,A3      
00FD05EC  24CB                     845              MOVE.L  A3,(A2)+                
00FD05EE  47F9 00FD06D8            846              LEA     TRACE_ERROR,A3          
00FD05F4  24CB                     847              MOVE.L  A3,(A2)+                
00FD05F6                           848  
00FD05F6  247C 00000028            849              MOVE.L  #$28,A2                 ;General Error, Starting at 1010 Illegal Opcode 
00FD05FC  47F9 00FD078E            850              LEA     ABORTE,A3               ;Use default Error message
00FD0602  24CB                     851  INIT0:      MOVE.L  A3,(A2)+                
00FD0604  B5FC 00000060            852              CMPA.L  #$60,A2                 ;Continue up to Spurious Interrupt (60H)
00FD060A  6BF6                     853              BMI.S   INIT0                   
00FD060C                           854              
00FD060C  47F9 00FD06EC            855              LEA     SPURIOUS_INT,A3         ;Spurious Interrupt vector
00FD0612  24CB                     856              MOVE.L  A3,(A2)+                
00FD0614  47F9 00FD0700            857              LEA     L1_INTERRUPT,A3         ;Hardware Interrupts
00FD061A  24CB                     858              MOVE.L  A3,(A2)+                
00FD061C  47F9 00FD0716            859              LEA     L2_INTERRUPT,A3         
00FD0622  24CB                     860              MOVE.L  A3,(A2)+                
00FD0624  47F9 00FD072A            861              LEA     L3_INTERRUPT,A3         
00FD062A  24CB                     862              MOVE.L  A3,(A2)+                
00FD062C  47F9 00FD073E            863              LEA     L4_INTERRUPT,A3         
00FD0632  24CB                     864              MOVE.L  A3,(A2)+                
00FD0634  47F9 00FD0752            865              LEA     L5_INTERRUPT,A3         
00FD063A  24CB                     866              MOVE.L  A3,(A2)+                
00FD063C  47F9 00FD0766            867              LEA     L6_INTERRUPT,A3         
00FD0642  24CB                     868              MOVE.L  A3,(A2)+                
00FD0644  47F9 00FD077A            869              LEA     L7_INTERRUPT,A3         
00FD064A  24CB                     870              MOVE.L  A3,(A2)+                
00FD064C                           871              
00FD064C                           872      
00FD064C                 TRUE      873     IFEQ SIMMULATOR  ;If SIMMULATOR = 0, i.e. we are in S100 or ROM mode, write this, else skip
00FD064C  47F9 00FD07A2            874              LEA     TRAPS,A3                ;16 Trap vectors 
00FD0652  24CB                     875  INIT1:      MOVE.L  A3,(A2)+                
00FD0654  B5FC 000000C0            876              CMPA.L  #$C0,A2                 ;Up to C0H
00FD065A  6BF6                     877              BMI.S   INIT1                   
00FD065C                           878      ENDC            
00FD065C  247C 000000C0            879              MOVE.L  #$C0,A2                 ;Just to be sure we are at the correct place
00FD0662  47F9 00FD078E            880              LEA     ABORTE,A3               ;Use default Error message
00FD0668                           881  
00FD0668  24CB                     882  INIT2:      MOVE.L  A3,(A2)+                ;INITIALIZE VECTORS
00FD066A  B5FC 00000400            883              CMPA.L  #$400,A2                ;Up to end of all vectors (3FFH)
00FD0670  6BF6                     884              BMI.S   INIT2                   
00FD0672  4E75                     885              RTS     ;All Done
00FD0674                           886              
00FD0674                           887              
00FD0674                           888              ;Below are the error messages
00FD0674  48E7 FFFE                889  BUS_ERROR:  MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD0678  45F9 00FD21DF            890              LEA     BUS_ERROR_MSG,A2
00FD067E  6100 1722                891              BSR     PRINT_STRING
00FD0682  4CDF 7FFF                892              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD0686  4E73                     893              RTE
00FD0688                           894  
00FD0688                           895  ADDRESS_ERROR:
00FD0688  48E7 FFFE                896              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD068C  45F9 00FD21EE            897              LEA     ADDRESS_ERROR_MSG,A2
00FD0692  6100 170E                898              BSR     PRINT_STRING
00FD0696  4CDF 7FFF                899              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD069A  4E73                     900              RTE
00FD069C                           901  
00FD069C                           902  ILLEGAL_ERROR:
00FD069C  48E7 FFFE                903              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD06A0  45F9 00FD2205            904              LEA     ILLEGAL_ERROR_MSG,A2
00FD06A6  6100 16FA                905              BSR     PRINT_STRING
00FD06AA  4CDF 7FFF                906              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD06AE  4E73                     907              RTE
00FD06B0                           908  
00FD06B0                           909  ZERO_ERROR:
00FD06B0  48E7 FFFE                910              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD06B4  45F9 00FD221D            911              LEA     ZERO_ERROR_MSG,A2
00FD06BA  6100 16E6                912              BSR     PRINT_STRING
00FD06BE  4CDF 7FFF                913              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD06C2  4E73                     914              RTE
00FD06C4                           915  
00FD06C4                           916  PRIVILEGE_ERROR:
00FD06C4  48E7 FFFE                917              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD06C8  45F9 00FD2231            918              LEA     PRIVILEGE_ERROR_MSG,A2
00FD06CE  6100 16D2                919              BSR     PRINT_STRING
00FD06D2  4CDF 7FFF                920              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD06D6  4E73                     921              RTE
00FD06D8                           922  
00FD06D8                           923  TRACE_ERROR:
00FD06D8  48E7 FFFE                924              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD06DC  45F9 00FD224B            925              LEA     TRACE_ERROR_MSG,A2
00FD06E2  6100 16BE                926              BSR     PRINT_STRING
00FD06E6  4CDF 7FFF                927              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD06EA  4E73                     928              RTE
00FD06EC                           929  
00FD06EC                           930  SPURIOUS_INT:
00FD06EC  48E7 FFFE                931              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD06F0  45F9 00FD2260            932              LEA     SPURIOUS_INT_MSG,A2
00FD06F6  6100 16AA                933              BSR     PRINT_STRING
00FD06FA  4CDF 7FFF                934              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD06FE  4E73                     935              RTE
00FD0700                           936  
00FD0700                           937  L1_INTERRUPT:
00FD0700  48E7 FFFE                938              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD0704  45F9 00FD2272            939              LEA     L1_INTERRUPT_MSG,A2
00FD070A  6100 1696                940              BSR     PRINT_STRING
00FD070E  4CDF 7FFF                941              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD0712  4E73                     942              RTE
00FD0714  4E73                     943              RTE
00FD0716                           944  
00FD0716                           945  L2_INTERRUPT:
00FD0716  48E7 FFFE                946              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD071A  45F9 00FD2287            947              LEA     L2_INTERRUPT_MSG,A2
00FD0720  6100 1680                948              BSR     PRINT_STRING
00FD0724  4CDF 7FFF                949              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD0728  4E73                     950              RTE
00FD072A                           951  
00FD072A                           952  L3_INTERRUPT:
00FD072A  48E7 FFFE                953              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD072E  45F9 00FD2293            954              LEA     L3_INTERRUPT_MSG,A2
00FD0734  6100 166C                955              BSR     PRINT_STRING
00FD0738  4CDF 7FFF                956              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD073C  4E73                     957              RTE
00FD073E                           958  
00FD073E                           959  L4_INTERRUPT:
00FD073E  48E7 FFFE                960              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD0742  45F9 00FD229F            961              LEA     L4_INTERRUPT_MSG,A2
00FD0748  6100 1658                962              BSR     PRINT_STRING
00FD074C  4CDF 7FFF                963              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD0750  4E73                     964              RTE
00FD0752                           965  
00FD0752                           966  L5_INTERRUPT:
00FD0752  48E7 FFFE                967              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD0756  45F9 00FD22AB            968              LEA     L5_INTERRUPT_MSG,A2
00FD075C  6100 1644                969              BSR     PRINT_STRING
00FD0760  4CDF 7FFF                970              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD0764  4E73                     971              RTE
00FD0766                           972  
00FD0766                           973  L6_INTERRUPT:
00FD0766  48E7 FFFE                974              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD076A  45F9 00FD22B7            975              LEA     L6_INTERRUPT_MSG,A2
00FD0770  6100 1630                976              BSR     PRINT_STRING
00FD0774  4CDF 7FFF                977              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD0778  4E73                     978              RTE
00FD077A                           979  
00FD077A                           980  L7_INTERRUPT:
00FD077A  48E7 FFFE                981              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD077E  45F9 00FD22C3            982              LEA     L7_INTERRUPT_MSG,A2
00FD0784  6100 161C                983              BSR     PRINT_STRING
00FD0788  4CDF 7FFF                984              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD078C  4E73                     985              RTE
00FD078E                           986              
00FD078E                           987  ABORTE:     
00FD078E  48E7 FFFE                988              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD0792  45F9 00FD22CF            989              LEA     INT_ERR_MSG,A2
00FD0798  6100 1608                990              BSR     PRINT_STRING
00FD079C  4CDF 7FFF                991              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD07A0  4E73                     992              RTE
00FD07A2                           993              
00FD07A2                           994  TRAPS:      
00FD07A2  48E7 FFFE                995              MOVEM.L D0-D7/A0-A6,-(A7)       ;SAVE ALL REGISTERS
00FD07A6  45F9 00FD22E2            996              LEA     TRAPS_ERR_MSG,A2
00FD07AC  6100 15F4                997              BSR     PRINT_STRING
00FD07B0  4CDF 7FFF                998              MOVEM.L (A7)+,D0-D7/A0-A6       ;POP ALL REGISTERS
00FD07B4  4E73                     999              RTE
00FD07B6                          1000  
00FD07B6                          1001  ;--------------------------------------------------------------------------------------------------
00FD07B6                          1002  TIME:
00FD07B6  45F9 00FD239C           1003              LEA     TIME_MSG,A2             ;Time determination module not written yet
00FD07BC  6100 15E4               1004              BSR     PRINT_STRING
00FD07C0  6000 F89A               1005              BRA     LOOP
00FD07C4                          1006  
00FD07C4                          1007  
00FD07C4                          1008  ;--------------------------------------------------------------------------------------------------
00FD07C4                          1009  
00FD07C4                          1010  JMP_Z80:    ;Switch back to Z80 Master CPU 
00FD07C4  2A3C 00FF00EE           1011              MOVE.L  #SW68K ,D5              ;Point to status Port 0ECH for DMA1 switch line
00FD07CA  2445                    1012              MOVE.L  D5,A2
00FD07CC                          1013              
00FD07CC  14BC 0000               1014              MOVE.B  #00,(A2)                ;Currently will use TMA line #1 to switch in/out the 68K board 
00FD07D0  4E71                    1015              NOP     ;<-- 68K Is held in HALT mode here until released again by the Z80/master CPU
00FD07D2  4E71                    1016              NOP
00FD07D4  4E71                    1017              NOP
00FD07D6  4E71                    1018              NOP
00FD07D8  6000 F882               1019              BRA     LOOP
00FD07DC                          1020  
00FD07DC                          1021  ;--------------------------------------------------------------------------------------------------
00FD07DC                          1022  SIGNALS:    ;Setup hardware signal tests to look at S-100 signals pDBIN, pWR*
00FD07DC  45F9 00FD23C3           1023              LEA     SIGNALS_MSG,A2          ;Put CPU in hardware loop to test (pDBIN or pWR*), Enter test RAM Location: 
00FD07E2  6100 15BE               1024              BSR     PRINT_STRING
00FD07E6                          1025  
00FD07E6  6100 135E               1026              BSR     GETLONG_D7              ;Get RAM location 
00FD07EA  4A03                    1027              TST.B   D3                      ;Byte count > 0
00FD07EC  6700 F86E               1028              BEQ     LOOP
00FD07F0  B43C 001B               1029              CMP.B   #ESC,D2                 ;If ESC then we abort
00FD07F4  6700 F866               1030              BEQ     LOOP
00FD07F8  B43C 000D               1031              CMP.B   #CR,D2                  ;If not CR then we also abort
00FD07FC  6600 15F0               1032              BNE     ERROR
00FD0800  2647                    1033              MOVE.L  D7,A3                   ;Store in A3 (also in D7)
00FD0802                          1034  
00FD0802  45F9 00FD2411           1035              LEA     Menu_1or2_MSG,A2        ;Enter 1=pDBIN, 2=pWR* : 
00FD0808  6100 1598               1036              BSR     PRINT_STRING
00FD080C                          1037  
00FD080C  4281                    1038              CLR.L   D1                      ;Just to be on the safe side
00FD080E  6100 14BC               1039              BSR     GETCHAR                 ;get a menu character
00FD0812  6100 15C4               1040              BSR     TOUPPER                 ;Lower case to Upper case
00FD0816                          1041  
00FD0816  B23C 0031               1042              CMP.B   #'1',D1                 ;Is it a pDBIN request
00FD081A  6700 000E               1043              BEQ     DBIN_TEST
00FD081E  B23C 0032               1044              CMP.B   #'2',D1                 ;Is it a pWR* request
00FD0822  6700 0034               1045              BEQ     WR_TEST
00FD0826  6000 15C6               1046              BRA     ERROR                   ;Must be an error
00FD082A                          1047  
00FD082A                          1048  
00FD082A                          1049  
00FD082A  123C 000D               1050  DBIN_TEST:  MOVE.B  #CR,D1                  ;Read test pDBIN
00FD082E  6100 146A               1051              BSR     PUTCHAR
00FD0832  123C 000A               1052              MOVE.B  #LF,D1
00FD0836  6100 1462               1053              BSR     PUTCHAR
00FD083A  123C 0072               1054              MOVE.B  #'r',D1
00FD083E  6100 145A               1055              BSR     PUTCHAR
00FD0842                          1056              
00FD0842  3413                    1057  DBIN_TEST1: MOVE.W  (A3),D2
00FD0844  3413                    1058              MOVE.W  (A3),D2
00FD0846  3413                    1059              MOVE.W  (A3),D2
00FD0848  3413                    1060              MOVE.W  (A3),D2
00FD084A  3413                    1061              MOVE.W  (A3),D2
00FD084C  3413                    1062              MOVE.W  (A3),D2
00FD084E  3413                    1063              MOVE.W  (A3),D2
00FD0850  3413                    1064              MOVE.W  (A3),D2
00FD0852  3413                    1065              MOVE.W  (A3),D2
00FD0854  3413                    1066              MOVE.W  (A3),D2
00FD0856  60EA                    1067              BRA     DBIN_TEST1              ;Must Hit Reset button to abort
00FD0858                          1068              
00FD0858                          1069              
00FD0858  343C AAAA               1070  WR_TEST:    MOVE.W  #$AAAA,D2               ;Write test pWR*
00FD085C  1238 000D               1071              MOVE.B  CR,D1
00FD0860  6100 1438               1072              BSR     PUTCHAR
00FD0864  123C 000A               1073              MOVE.B  #LF,D1
00FD0868  6100 1430               1074              BSR     PUTCHAR
00FD086C  123C 0077               1075              MOVE.B  #'w',D1
00FD0870  6100 1428               1076              BSR     PUTCHAR
00FD0874                          1077  
00FD0874  3682                    1078  WR_TEST1:   MOVE.W  D2,(A3)
00FD0876  3682                    1079              MOVE.W  D2,(A3)
00FD0878  3682                    1080              MOVE.W  D2,(A3)
00FD087A  3682                    1081              MOVE.W  D2,(A3)
00FD087C  3682                    1082              MOVE.W  D2,(A3)
00FD087E  3681                    1083              MOVE.W  D1,(A3)
00FD0880  3682                    1084              MOVE.W  D2,(A3)
00FD0882  3682                    1085              MOVE.W  D2,(A3)
00FD0884  3682                    1086              MOVE.W  D2,(A3)
00FD0886  3682                    1087              MOVE.W  D2,(A3)
00FD0888  60EA                    1088              BRA     WR_TEST1                ;Must Hit Reset button to abort
00FD088A                          1089  
00FD088A                          1090  
00FD088A                          1091  
00FD088A                          1092  
00FD088A                          1093  
00FD088A                          1094  PATCH:      ;Y Command, Quick patch to move RAM 4000H-9000H to F4000H & JUMP to it
00FD088A  45F9 00FD2499           1095              LEA     PATCH_MSG,A2            ;"Moving Code 4000H-9000H to F4000H, Then jump to that location"
00FD0890  6100 1510               1096              BSR     PRINT_STRING            ;The CPM3/Z80 SID program will place any test .bin file from a disk to 4000H 
00FD0894                          1097              ;in RAM (no matter what its final ORG is). 
00FD0894  6100 1436               1098              BSR     GETCHAR                 ;Get character in D1
00FD0898  6100 153E               1099              BSR     TOUPPER
00FD089C  B23C 000D               1100              CMP.B   #CR,D1
00FD08A0  6700 0006               1101              BEQ     PATCH0
00FD08A4  6000 F7B6               1102              BRA     LOOP
00FD08A8                          1103  
00FD08A8  6100 1508               1104  PATCH0:     BSR     CRLF                    ;Start patch
00FD08AC  267C 00004000           1105              MOVE.L  #$4000,A3               ;This command will then move test versions of this monitor (or any other
00FD08B2  2A7C 000F4000           1106              MOVE.L  #$F4000,A5              ;program) up out of the way to F4000H and execute it from there.
00FD08B8  223C 00008000           1107              MOVE.L  #$8000,D1               ;This shold be large enough for a monitor copy
00FD08BE                          1108              
00FD08BE  1ADB                    1109  PATCH1:     MOVE.B  (A3)+,(A5)+
00FD08C0  5381                    1110              SUBQ.L  #1,D1
00FD08C2  66FA                    1111              BNE     PATCH1
00FD08C4  4EF9 00F40000           1112              JMP     Patch_RAM               ;Jump to this loction ($00F40000)
00FD08CA                          1113              
00FD08CA                          1114  
00FD08CA                          1115  
00FD08CA                          1116  ;----------------------------------------------------------------------------------------------
00FD08CA                          1117  ;----------------------------------------------------------------------------------------------
00FD08CA                          1118  ;------------- MAIN IDE DRIVE DIAGNOSTIC MENU --------------------------------------------------
00FD08CA                          1119  ;       Normally the DMA buffers will reside in the RAM on the 68K board itself at 00FD9000H 
00FD08CA                          1120  ;----------------------------------------------------------------------------------------------
00FD08CA                          1121  
00FD08CA  6100 0F58               1122  MY_IDE:     BSR     CLEAR_ID_BUFFER         ;Clear ID Buffer
00FD08CE                          1123  
00FD08CE  6100 011C               1124              BSR     SEL_DRIVE_A             ;Select the first Drive/CF card
00FD08D2  6100 0CA8               1125              BSR     IDEinit                 ;Initialize the board and drive 0. If there is no drive abort
00FD08D6  6700 0010               1126              BEQ     INIT1_OK
00FD08DA                          1127              
00FD08DA  45F9 00FD2704           1128              LEA     INIT_1_ERROR,A2
00FD08E0  6100 14C0               1129              BSR     PRINT_STRING
00FD08E4  6000 F776               1130              BRA     LOOP
00FD08E8                          1131  
00FD08E8                          1132  INIT1_OK:
00FD08E8  6100 011C               1133              BSR     SEL_DRIVE_B             ;Select the second Drive/CF card (Do not mess with CPM Drive 0)
00FD08EC  6100 0C8E               1134              BSR     IDEinit                 ;Initialize drive 1. If there is no drive abort
00FD08F0  6700 0010               1135              BEQ     INIT2_OK
00FD08F4                          1136  
00FD08F4  6100 0F2E               1137              BSR     CLEAR_ID_BUFFER         ;Clear ID Buffer
00FD08F8                          1138              
00FD08F8  45F9 00FD2726           1139              LEA     INIT_2_ERROR,A2         ;Warn second IDE drive did not initilize
00FD08FE  6100 14A2               1140              BSR     PRINT_STRING
00FD0902                          1141  
00FD0902                          1142  INIT2_OK:
00FD0902  6100 00E8               1143              BSR     SEL_DRIVE_A             ;Back to first drive/CF Card
00FD0906                          1144  
00FD0906  6100 0112               1145              BSR     DRIVE_ID                ;Get the drive 0 id info. If there is no drive just abort
00FD090A  6700 0010               1146              BEQ     INIT3_OK
00FD090E                          1147              
00FD090E  45F9 00FD2761           1148              LEA     BAD_DRIVE,A2
00FD0914  6100 148C               1149              BSR     PRINT_STRING
00FD0918  6000 F742               1150              BRA     LOOP
00FD091C                          1151  
00FD091C                          1152  INIT3_OK:   ;Set default position will be first sector block 
00FD091C  45F9 00FD810C           1153              LEA     IDE_Buffer+12,A2        
00FD0922  0C52 0000               1154              CMP.W   #0,(A2)                 ;Is it non zero
00FD0926  6600 0010               1155              BNE     INIT4_OK                ;If there are zero sectors then something wrong
00FD092A                          1156  
00FD092A  45F9 00FD2761           1157              LEA     BAD_DRIVE,A2            ;"Error obtaining first Drive ID"
00FD0930  6100 1470               1158              BSR     PRINT_STRING
00FD0934  6000 F726               1159              BRA     LOOP
00FD0938                          1160              
00FD0938  4239 00FD850C           1161  INIT4_OK:   CLR.B   (RAM_SEC)               ;Sec 0
00FD093E  13FC 0000 00FD850D      1162              MOVE.B  #0,(RAM_TRK)            ;Track 0
00FD0946                          1163              
00FD0946  49F9 00FD8100           1164              LEA     IDE_BUFFER,A4
00FD094C  23CC 00FD8500           1165              MOVE.L  A4,(RAM_DMA)
00FD0952                          1166  
00FD0952  6100 0C28               1167              BSR     IDEinit                 ;For some reason this need to be here for some cards after getting the drive ID.
00FD0956                          1168              ;otherewise sector #'s are off by one! (Probably because on non-LBA reads)
00FD0956  6100 0DC0               1169              BSR     WR_LBA                  ;Update LBA on "1st" drive
00FD095A                          1170  
00FD095A                          1171  
00FD095A                          1172  
00FD095A                          1173  ;------------- MAIN IDE DRIVE DIAGNOSTIC MENU ---------------------------
00FD095A                          1174              
00FD095A  45F9 00FD257C           1175  IDE_LOOP:   LEA     IDE_SIGNON0,A2          ;List IDE command options
00FD0960  6100 1440               1176              BSR     PRINT_STRING
00FD0964                          1177  
00FD0964  0C39 0000 00FD850E      1178              CMP.B   #0,(CURRENT_IDE_DRIVE)
00FD096C  6600 000C               1179              BNE     SIGN_B
00FD0970  45F9 00FD2BF9           1180              LEA     CURRENT_MSG_A,A2
00FD0976  6000 0008               1181              BRA     IDE_LOOP0
00FD097A  45F9 00FD2C0C           1182  SIGN_B:     LEA     CURRENT_MSG_B,A2
00FD0980                          1183  IDE_LOOP0:
00FD0980  6100 1420               1184              BSR     PRINT_STRING
00FD0984                          1185              
00FD0984  6100 142C               1186              BSR     CRLF
00FD0988                          1187              
00FD0988  45F9 00FD25A1           1188              LEA     IDE_SIGNON1,A2          ;List IDE command options
00FD098E  6100 1412               1189              BSR     PRINT_STRING
00FD0992                          1190              
00FD0992  6100 090E               1191              BSR     DISPLAY_POSITION        ;Display current Track,sector,head#
00FD0996                          1192  
00FD0996  6100 141A               1193              BSR     CRLF
00FD099A  45F9 00FD26CF           1194              LEA     IDE_MENU_CMD,A2         ;Enter a command 
00FD09A0  6100 1400               1195              BSR     PRINT_STRING
00FD09A4                          1196  
00FD09A4  6100 1326               1197              BSR     GETCHAR                 ;Get a command from Console
00FD09A8  B23C 001B               1198              CMP.B   #ESC,D1                 ;Abort if ESC
00FD09AC  6600 0006               1199              BNE     NOT_ESC
00FD09B0  6000 F67A               1200              BRA     START                   ;Back to start of Monitor
00FD09B4                          1201  
00FD09B4  6100 1422               1202  NOT_ESC:    BSR     TOUPPER                 ;Lower case to Upper case
00FD09B8                          1203     
00FD09B8                 FALSE    1204     IFNE SIMMULATOR  ;If SIMMULATOR = 1
00FD09B8                          1205     ENDC     
00FD09B8  B23C 0041               1206              CMP.B   #'A',D1
00FD09BC  6D00 F6D8               1207              BLT     ERR
00FD09C0  B23C 005A               1208              CMP.B   #'Z',D1
00FD09C4  6E00 F6D0               1209              BGT     ERR
00FD09C8  0401 0041               1210              SUBI.B  #'A',D1
00FD09CC  4881                    1211              EXT.W   D1
00FD09CE  E589                    1212              LSL.L   #2,D1                   ;X4 for offset into table
00FD09D0  45F9 00FD1F3C           1213              LEA     IDE_TABLE,A2            ;Start of cnd table
00FD09D6  2672 1000               1214              MOVE.L  (A2,D1),A3              ;Add in X4 offset
00FD09DA  4ED3                    1215              JMP     (A3)
00FD09DC                          1216  
00FD09DC                          1217  ;             INDIVIDUAL IDE DRIVE MENU COMMANDS 
00FD09DC                          1218  
00FD09DC                          1219  ;---------------Select Drive/CF card ------------------------------------------
00FD09DC                          1220  SET_DRIVE_A:        ;Select First Drive
00FD09DC  6100 000E               1221              BSR     SEL_DRIVE_A
00FD09E0  6000 FF78               1222              BRA     IDE_LOOP                ;Back to IDE Menu
00FD09E4                          1223  
00FD09E4                          1224  SET_DRIVE_B:        ;Select First Drive
00FD09E4  6100 0020               1225              BSR     SEL_DRIVE_B
00FD09E8  6000 FF70               1226              BRA     IDE_LOOP                ;Back to IDE Menu
00FD09EC                          1227  
00FD09EC                          1228  SEL_DRIVE_A:;Select First Drive
00FD09EC  45F9 00FD2C80           1229              LEA     IDE_SEL_A,A2            ;Say so
00FD09F2  6100 13AE               1230              BSR     PRINT_STRING
00FD09F6  4201                    1231              CLR.B   D1
00FD09F8                          1232  SELECT_DRIVE:
00FD09F8  13C1 00FD850E           1233              MOVE.B  D1,CURRENT_IDE_DRIVE
00FD09FE  13C1 00FF0034           1234              MOVE.B  D1,IDEDrivePort         ;Select Drive 0 or 1
00FD0A04  4E75                    1235              RTS
00FD0A06                          1236  
00FD0A06                          1237  SEL_DRIVE_B:;Select Drive 1
00FD0A06  45F9 00FD2C98           1238              LEA     IDE_SEL_B,A2            ;Say so
00FD0A0C  6100 1394               1239              BSR     PRINT_STRING
00FD0A10  123C 0001               1240              MOVE.B  #1,D1
00FD0A14  4EF9 00FD09F8           1241              JMP     SELECT_DRIVE
00FD0A1A                          1242  
00FD0A1A                          1243  
00FD0A1A                          1244  
00FD0A1A                          1245  DRIVE_ID:
00FD0A1A  6100 0DB4               1246              BSR     IDEwaitnotbusy
00FD0A1E  6C00 0008               1247              BGE     L_5
00FD0A22  4241                    1248              CLR     D1
00FD0A24  5301                    1249              SUBQ.B  #1,D1                   ;NZ if error
00FD0A26  4E75                    1250              RTS     ;If Busy return NZ
00FD0A28                          1251              
00FD0A28  183C 00EC               1252  L_5:        MOVE.B  #COMMANDid,D4
00FD0A2C  1A3C 000F               1253              MOVE.B  #REGcommand,D5
00FD0A30  6100 0E46               1254              BSR     IDEwr8D                 ;Issue the command
00FD0A34                          1255              
00FD0A34  6100 0DC4               1256              BSR     IDEwaitdrq              ;Wait for Busy=0, DRQ=1
00FD0A38  6C00 0006               1257              BGE     L_6                     
00FD0A3C  6000 0A44               1258              BRA     SHOWerrors
00FD0A40                          1259              
00FD0A40  4206                    1260  L_6:        CLR.B   D6                      ;256 words
00FD0A42                          1261  
00FD0A42  45F9 00FD8100           1262              LEA     IDE_Buffer,A2           ;Store data here
00FD0A48  6100 0C06               1263              BSR     MoreRD16                ;Get 256 words of data from REGdata port to IDE_Buffer
00FD0A4C                          1264  
00FD0A4C                          1265              ;Decode Drive INFO
00FD0A4C  45F9 00FD2FFD           1266              LEA     msgmdl,A2               ;Drive/CF Card Information:-
00FD0A52  6100 134E               1267              BSR     PRINT_STRING
00FD0A56                          1268              
00FD0A56  45F9 00FD8136           1269              LEA     IDE_Buffer+54,A2        ;@ Word 27
00FD0A5C  163C 0014               1270              MOVE.B  #20,D3                  ;Character count in words
00FD0A60  6100 0084               1271              BSR     Print_ID_Info           ;Print [A2], [D3] X 2 characters
00FD0A64  6100 134C               1272              BSR     CRLF
00FD0A68                          1273              ;print the drive's serial number
00FD0A68  45F9 00FD3025           1274              LEA     msgsn,A2                ;'S/N:   '
00FD0A6E  6100 1332               1275              BSR     PRINT_STRING
00FD0A72  45F9 00FD8114           1276              LEA     IDE_Buffer+20,A2        ;@ Word 10
00FD0A78  163C 000A               1277              MOVE.B  #10,D3                  ;Character count in words
00FD0A7C  6100 0068               1278              BSR     Print_ID_Info
00FD0A80  6100 1330               1279              BSR     CRLF
00FD0A84                          1280              
00FD0A84  45F9 00FD302D           1281              LEA     msgrev,A2               ;'Rev:   '
00FD0A8A  6100 1316               1282              BSR     PRINT_STRING
00FD0A8E  45F9 00FD812E           1283              LEA     IDE_Buffer+46,A2        ;@ Word 23
00FD0A94  163C 0004               1284              MOVE.B  #4,D3                   
00FD0A98  6100 004C               1285              BSR     Print_ID_Info           ;Character count in words
00FD0A9C  6100 1314               1286              BSR     CRLF
00FD0AA0                          1287              ;Print the drive's cylinder, head, and sector specs
00FD0AA0  45F9 00FD3035           1288              LEA     msgcy,A2                ;'Cylinders: '
00FD0AA6  6100 12FA               1289              BSR     PRINT_STRING
00FD0AAA  45F9 00FD8102           1290              LEA     IDE_Buffer+2,A2         ;@ Word 1
00FD0AB0  6100 004A               1291              BSR     Print_ID_Hex
00FD0AB4                          1292  
00FD0AB4                          1293  
00FD0AB4  45F9 00FD3041           1294              LEA     msghd,A2                ;', Heads: '
00FD0ABA  6100 12E6               1295              BSR     PRINT_STRING
00FD0ABE  45F9 00FD8106           1296              LEA     IDE_Buffer+6,A2         ;@ Word 3
00FD0AC4  6100 0036               1297              BSR     Print_ID_Hex
00FD0AC8                          1298  
00FD0AC8  45F9 00FD304B           1299              LEA     msgsc,A2                ;', Sectors: '
00FD0ACE  6100 12D2               1300              BSR     PRINT_STRING
00FD0AD2  45F9 00FD810C           1301              LEA     IDE_Buffer+12,A2        ;@ Word 6
00FD0AD8  6100 0022               1302              BSR     Print_ID_Hex
00FD0ADC  6100 12D4               1303              BSR     CRLF                    
00FD0AE0  4203                    1304              CLR.B   D3                      ;Ret Z
00FD0AE2  6000 FE76               1305              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0AE6                          1306              
00FD0AE6                          1307  Print_ID_Info:
00FD0AE6  122A 0001               1308              MOVE.B  1(A2),D1                ;Text is stored high byte then low byte
00FD0AEA  6100 11AE               1309              BSR     PUTCHAR
00FD0AEE  1212                    1310              MOVE.B  (A2),D1
00FD0AF0  6100 11A8               1311              BSR     PUTCHAR
00FD0AF4  548A                    1312              ADDQ.L  #2,A2
00FD0AF6  5303                    1313              SUBQ.B  #1,D3
00FD0AF8  66EC                    1314              BNE     Print_ID_Info
00FD0AFA  4E75                    1315              RTS
00FD0AFC                          1316  
00FD0AFC                          1317              ; Print a 16 bit number in RAM located @ [A2] 
00FD0AFC                          1318  Print_ID_Hex:
00FD0AFC  528A                    1319              ADDQ.L  #1,A2                   ;(Note Special Low Byte First. Used only for Drive ID)
00FD0AFE  1C12                    1320              MOVE.B  (A2),D6
00FD0B00  6100 1136               1321              BSR     PUTBYTE_D6
00FD0B04  1C22                    1322              MOVE.B  -(A2),D6
00FD0B06  6100 1130               1323              BSR     PUTBYTE_D6
00FD0B0A  4E75                    1324              RTS
00FD0B0C                          1325              
00FD0B0C                          1326              
00FD0B0C                          1327              
00FD0B0C                          1328              
00FD0B0C                          1329  ;-------------- Read the current selected sector (based on LBA) to the IDE Buffer
00FD0B0C                          1330  READ_SEC:
00FD0B0C  49F9 00FD8100           1331              LEA     IDE_BUFFER,A4
00FD0B12  23CC 00FD8500           1332              MOVE.L  A4,RAM_DMA              ;DMA initially to IDE_Buffer
00FD0B18                          1333  
00FD0B18  6100 0AEA               1334              BSR     READSECTOR
00FD0B1C                          1335              
00FD0B1C  6700 000A               1336              BEQ     Main1B
00FD0B20  6100 1290               1337              BSR     CRLF                    ;Here if there was a problem
00FD0B24  6000 FE34               1338              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0B28                          1339  
00FD0B28  6100 1288               1340  Main1B:     BSR     CRLF                    
00FD0B2C  45F9 00FD2821           1341              LEA     msgrd,A2                ;Sector read OK
00FD0B32  6100 126E               1342              BSR     PRINT_STRING
00FD0B36                          1343  
00FD0B36  49F9 00FD8100           1344              LEA     IDE_BUFFER,A4           ;Show Sector Data
00FD0B3C  23CC 00FD8500           1345              MOVE.L  A4,RAM_DMA              ;DMA initially to IDE_Buffer
00FD0B42  6100 0822               1346              BSR     DISPLAY_SECTOR
00FD0B46  45F9 00FD2BC2           1347              LEA     CR_To_Continue,A2 
00FD0B4C  6100 1254               1348              BSR     PRINT_STRING
00FD0B50  6100 117A               1349              BSR     GETCHAR
00FD0B54  6100 125C               1350              BSR     CRLF                    
00FD0B58  6000 FE00               1351              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0B5C                          1352  
00FD0B5C                          1353  ;----------------- Write the current selected sector (based on LBA) from the IDE Buffer
00FD0B5C                          1354  
00FD0B5C  45F9 00FD27E0           1355  WRITE_SEC:  LEA     CONFIRM_WR_MSG,A2       ;Are you sure?
00FD0B62  6100 123E               1356              BSR     PRINT_STRING
00FD0B66  6100 1164               1357              BSR     GETCHAR
00FD0B6A  6100 126C               1358              BSR     TOUPPER
00FD0B6E  B23C 0059               1359              CMP.B   #'Y',D1
00FD0B72  6700 000A               1360              BEQ     WR_SEC_OK1
00FD0B76  6100 123A               1361              BSR     CRLF                    ;Here if there was a problem
00FD0B7A  6000 FDDE               1362              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0B7E                          1363   
00FD0B7E  6100 1232               1364  WR_SEC_OK1: BSR     CRLF
00FD0B82  49F9 00FD8100           1365              LEA     IDE_BUFFER,A4
00FD0B88  23CC 00FD8500           1366              MOVE.L  A4,(RAM_DMA)            ;DMA initially to IDE_Buffer
00FD0B8E                          1367  
00FD0B8E  6100 0B00               1368              BSR     WRITESECTOR             ;Will write whatever is in the IDE_Buffer
00FD0B92                          1369              
00FD0B92  6700 000A               1370              BEQ     Main2B
00FD0B96  6100 121A               1371              BSR     CRLF                    ;Here if there was a problem
00FD0B9A  6000 FDBE               1372              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0B9E                          1373  Main2B:     
00FD0B9E  45F9 00FD2832           1374              LEA     msgwr,A2                ;Sector written OK
00FD0BA4  6100 11FC               1375              BSR     PRINT_STRING
00FD0BA8                          1376  
00FD0BA8  49F9 00FD8100           1377              LEA     IDE_BUFFER,A4
00FD0BAE  23CC 00FD8500           1378              MOVE.L  A4,(RAM_DMA)            ;DMA initially to IDE_Buffer
00FD0BB4  6100 07B0               1379              BSR     DISPLAY_SECTOR
00FD0BB8  45F9 00FD2BC2           1380              LEA     CR_To_Continue,A2 
00FD0BBE  6100 11E2               1381              BSR     PRINT_STRING
00FD0BC2  6100 1108               1382              BSR     GETCHAR
00FD0BC6  6100 11EA               1383              BSR     CRLF                    
00FD0BCA  6000 FD8E               1384              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0BCE                          1385  
00FD0BCE                          1386  
00FD0BCE                          1387  
00FD0BCE                          1388              
00FD0BCE                          1389  ;------------------ Fill a sector with a Byte Value (in D5)
00FD0BCE                          1390  
00FD0BCE  45F9 00FD2CEA           1391  FILL_SEC:   LEA     FILL_BYTE_MSG,A2        ;Enter sector Fill byte
00FD0BD4  6100 11CC               1392              BSR     PRINT_STRING
00FD0BD8  6100 0FB4               1393              BSR     GETBYTE_D7              ;Get data in D7 (0-FF) 
00FD0BDC  B43C 001B               1394              CMP.B   #ESC,D2                 ;If ESC then we are done
00FD0BE0  6700 FD78               1395              BEQ     IDE_LOOP
00FD0BE4  B43C 000D               1396              CMP.B   #CR,D2                  ;If CR then we are done
00FD0BE8  6600 FD70               1397              BNE     IDE_LOOP
00FD0BEC  2A07                    1398              MOVE.L  D7,D5                   ;<<< Store data (BYTE) in D5 
00FD0BEE                          1399  
00FD0BEE  45F9 00FD27E0           1400              LEA     CONFIRM_WR_MSG,A2       ;Are you sure?
00FD0BF4  6100 11AC               1401              BSR     PRINT_STRING
00FD0BF8  6100 10D2               1402              BSR     GETCHAR
00FD0BFC  6100 11DA               1403              BSR     TOUPPER
00FD0C00  B23C 0059               1404              CMP.B   #'Y',D1
00FD0C04  6700 000A               1405              BEQ     CLEAR_BUFFER
00FD0C08  6100 11A8               1406              BSR     CRLF                    ;Here if abort
00FD0C0C  6000 FD4C               1407              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0C10                          1408  
00FD0C10                          1409  
00FD0C10                          1410  CLEAR_BUFFER:
00FD0C10  45F9 00FD8100           1411              LEA     IDE_Buffer,A2
00FD0C16  343C 0200               1412              MOVE.W  #512,D2                 ;512 bytes total to fill
00FD0C1A  14C5                    1413  CLEAR0:     MOVE.B  D5,(A2)+
00FD0C1C  5342                    1414              SUBQ.W  #1,D2
00FD0C1E  66FA                    1415              BNE     CLEAR0
00FD0C20                          1416  
00FD0C20  49F9 00FD8100           1417              LEA     IDE_BUFFER,A4
00FD0C26  23CC 00FD8500           1418              MOVE.L  A4,(RAM_DMA)            ;DMA initially to IDE_Buffer
00FD0C2C                          1419  
00FD0C2C  6100 0A62               1420              BSR     WRITESECTOR             ;Will write whatever is in the IDE_Buffer
00FD0C30                          1421              
00FD0C30  6700 000A               1422              BEQ     CLEAR2
00FD0C34  6100 117C               1423              BSR     CRLF                    ;Here if there was a problem
00FD0C38  6000 FD20               1424              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0C3C                          1425  CLEAR2:     
00FD0C3C  45F9 00FD2832           1426              LEA     msgwr,A2                ;Sector written OK
00FD0C42  6100 115E               1427              BSR     PRINT_STRING
00FD0C46                          1428  
00FD0C46  49F9 00FD8100           1429              LEA     IDE_BUFFER,A4
00FD0C4C  23CC 00FD8500           1430              MOVE.L  A4,(RAM_DMA)            ;DMA initially to IDE_Buffer
00FD0C52  6100 0712               1431              BSR     DISPLAY_SECTOR
00FD0C56  45F9 00FD2BC2           1432              LEA     CR_To_Continue,A2 
00FD0C5C  6100 1144               1433              BSR     PRINT_STRING
00FD0C60  6100 106A               1434              BSR     GETCHAR
00FD0C64  6100 114C               1435              BSR     CRLF                    
00FD0C68  6000 FCF0               1436              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0C6C                          1437              
00FD0C6C                          1438  
00FD0C6C                          1439  ;---------------------  Set a new LBA value from inputted Track/Sec info. Send to drive
00FD0C6C                          1440  SET_LBA:
00FD0C6C  45F9 00FD2844           1441              LEA     SET_LBA_MSG,A2          ;Set new LBA and send to drive
00FD0C72  6100 112E               1442              BSR     PRINT_STRING
00FD0C76  6100 05E2               1443              BSR     GEN_HEX32_LBA           ;Get new CPM style Track & Sector number and put them in RAM at RAM_SEC & RAM_TRK 
00FD0C7A  6D00 0006               1444              BLT     main3b                  ;Ret C set if abort/error
00FD0C7E  6100 0A98               1445              BSR     WR_LBA                  ;Update LBA on drive
00FD0C82  6100 112E               1446  main3b:     BSR     CRLF                    
00FD0C86  6000 FCD2               1447              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0C8A                          1448  
00FD0C8A                          1449  
00FD0C8A                          1450  
00FD0C8A                          1451  ;--------------------- Point current sector to next sector
00FD0C8A                          1452  NEXT_SECT:
00FD0C8A  6100 075C               1453              BSR     GET_NEXT_SECT
00FD0C8E  6600 000A               1454              BNE     AT_END
00FD0C92  6100 111E               1455              BSR     CRLF                    
00FD0C96  6000 FCC2               1456              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0C9A                          1457  AT_END:
00FD0C9A  45F9 00FD2B1F           1458              LEA     AT_END_MSG,A2           ;Tell us we are at end of disk
00FD0CA0  6100 1100               1459              BSR     PRINT_STRING
00FD0CA4  6100 110C               1460              BSR     CRLF                    
00FD0CA8  6000 FCB0               1461              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0CAC                          1462  
00FD0CAC                          1463  ;--------------------- Point current sector to previous sector
00FD0CAC                          1464  PREV_SECT:
00FD0CAC  6100 0780               1465              BSR     GET_PREV_SECT
00FD0CB0  6600 000A               1466              BNE     AT_START
00FD0CB4  6100 10FC               1467              BSR     CRLF                    
00FD0CB8  6000 FCA0               1468              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0CBC                          1469  AT_START:
00FD0CBC  45F9 00FD2B02           1470              LEA     AT_START_MSG,A2         ;Tell us we are at start of disk
00FD0CC2  6100 10DE               1471              BSR     PRINT_STRING
00FD0CC6  6100 10EA               1472              BSR     CRLF                    
00FD0CCA  6000 FC8E               1473              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0CCE                          1474              
00FD0CCE                          1475  ;--------------------- Sequentially read sectors from disk starting at current LBA position
00FD0CCE                          1476  SEQ_SEC_RD:
00FD0CCE  6100 0B00               1477              BSR     IDEwaitnotbusy          
00FD0CD2  6C00 0006               1478              BGE     MORE_SEC                
00FD0CD6  6000 07AA               1479              BRA     SHOWerrors
00FD0CDA                          1480  
00FD0CDA                          1481  MORE_SEC:
00FD0CDA  6100 10D6               1482              BSR     CRLF
00FD0CDE  49F9 00FD8100           1483              LEA     IDE_BUFFER,A4
00FD0CE4  23CC 00FD8500           1484              MOVE.L  A4,(RAM_DMA)            ;DMA initially to IDE_Buffer
00FD0CEA                          1485  
00FD0CEA                          1486              
00FD0CEA  123C 003C               1487              MOVE.B  #'<',D1
00FD0CEE  6100 0FAA               1488              BSR     PUTCHAR
00FD0CF2  2847                    1489              MOVE.L  D7,A4
00FD0CF4  6100 0F00               1490              BSR     PUTLONG_D7
00FD0CF8  123C 003E               1491              MOVE.B  #'>',D1
00FD0CFC  6100 0F9C               1492              BSR     PUTCHAR
00FD0D00                          1493              
00FD0D00  6100 0902               1494              BSR     READSECTOR              ;If there are errors they will show up in READSECTOR
00FD0D04  6700 0024               1495              BEQ     SEQOK
00FD0D08                          1496  
00FD0D08  45F9 00FD2A7A           1497              LEA     CONTINUE_MSG,A2         ;If an error ask if we wish to continue
00FD0D0E  6100 1092               1498              BSR     PRINT_STRING
00FD0D12  6100 0FB8               1499              BSR     GETCHAR
00FD0D16  6100 10C0               1500              BSR     TOUPPER
00FD0D1A  B23C 001B               1501              CMP.B   #ESC,D1                 ;Abort if ESC
00FD0D1E  6600 000A               1502              BNE     SEQOK
00FD0D22  6100 108E               1503              BSR     CRLF                    
00FD0D26  6000 FC32               1504              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0D2A                          1505  
00FD0D2A  6100 0576               1506  SEQOK:      BSR     DISPLAY_POSITION        ;Display current Track,sector,head#
00FD0D2E                          1507              
00FD0D2E  49F9 00FD8100           1508              LEA     IDE_BUFFER,A4
00FD0D34  23CC 00FD8500           1509              MOVE.L  A4,(RAM_DMA)            ;DMA initially to IDE_Buffer
00FD0D3A                          1510  
00FD0D3A  6100 062A               1511              BSR     DISPLAY_SECTOR
00FD0D3E                          1512  
00FD0D3E  6100 0FC0               1513              BSR     GETSTAT                 ;Any keyboard character will stop display
00FD0D42  6700 0028               1514              BEQ     NO_WAIT                 
00FD0D46  6100 0F84               1515              BSR     GETCHAR                 
00FD0D4A  45F9 00FD2A7A           1516              LEA     CONTINUE_MSG,A2
00FD0D50  6100 1050               1517              BSR     PRINT_STRING
00FD0D54  6100 0F76               1518              BSR     GETCHAR
00FD0D58  6100 107E               1519              BSR     TOUPPER
00FD0D5C  B23C 001B               1520              CMP.B   #ESC,D1
00FD0D60  6600 000A               1521              BNE     NO_WAIT
00FD0D64  6100 104C               1522              BSR     CRLF                    
00FD0D68  6000 FBF0               1523              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0D6C                          1524  
00FD0D6C                          1525  NO_WAIT:
00FD0D6C  6100 067A               1526              BSR     GET_NEXT_SECT           ;Point LBA to next sector
00FD0D70  6700 FF68               1527              BEQ     MORE_SEC                ;Note will go to last sec on disk unless stopped
00FD0D74  6100 103C               1528              BSR     CRLF                    
00FD0D78  6000 FBE0               1529              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0D7C                          1530  
00FD0D7C                          1531  
00FD0D7C                          1532  
00FD0D7C                          1533  
00FD0D7C                          1534  
00FD0D7C                          1535  ;--------------- Read N Sectors to disk --------------------------------------------------
00FD0D7C                          1536  ;Note unlike the normal sector read, this routine increments the DMA address after each sector read
00FD0D7C                          1537   
00FD0D7C                          1538  N_RD_SEC:   
00FD0D7C  45F9 00FD2FC7           1539              LEA     WILL_RD_MSG,A2          ;Enter RAM location where sector data will be placed
00FD0D82  6100 101E               1540              BSR     PRINT_STRING
00FD0D86                          1541  
00FD0D86  6100 0DBE               1542              BSR     GETLONG_D7              ;Get start address
00FD0D8A  B43C 000D               1543              CMP.B   #CR,D2                  ;Is it valid
00FD0D8E  6600 FBCA               1544              BNE     IDE_LOOP
00FD0D92  23C7 00FD8502           1545              MOVE.L  D7,(RAM_DMA_STORE)      ;<--- Save in RAM_DMA_STORE
00FD0D98                          1546  
00FD0D98  45F9 00FD2FAB           1547              LEA     SEC_COUNT_MSG,A2        ;Enter sector count
00FD0D9E  6100 1002               1548              BSR     PRINT_STRING
00FD0DA2  6100 0DEA               1549              BSR     GETBYTE_D7              ;Get data in D7 (0-FF) 
00FD0DA6  B43C 001B               1550              CMP.B   #ESC,D2                 ;If ESC then we are done
00FD0DAA  6700 FBAE               1551              BEQ     IDE_LOOP
00FD0DAE  B43C 000D               1552              CMP.B   #CR,D2                  ;If CR then we are done
00FD0DB2  6600 FBA6               1553              BNE     IDE_LOOP
00FD0DB6  33C7 00FD8506           1554              MOVE.W  D7,(SECTOR_COUNT)       ;store sector count
00FD0DBC  6100 0FF4               1555              BSR     CRLF
00FD0DC0  6100 0FF0               1556              BSR     CRLF
00FD0DC4                          1557  
00FD0DC4                          1558  NextRSec:   
00FD0DC4  6100 04DC               1559              BSR     DISPLAY_POSITION        ;Display current Track,sector
00FD0DC8  45F9 00FD2B32           1560              LEA     READN_MSG,A2            ;' ----> ',0
00FD0DCE  6100 0FD2               1561              BSR     PRINT_STRING
00FD0DD2                          1562  
00FD0DD2  2239 00FD8502           1563              MOVE.L  (RAM_DMA_STORE),D1      ;DMA initially to IDE_Buffer
00FD0DD8  23C1 00FD8500           1564              MOVE.L  D1,(RAM_DMA)
00FD0DDE  2E01                    1565              MOVE.L  D1,D7
00FD0DE0  6100 0E14               1566              BSR     PUTLONG_D7              ;Show current address
00FD0DE4  45F9 00FD307C           1567              LEA     H_MSG_CRLF,A2           ;'H',CR,LF,0
00FD0DEA  6100 0FB6               1568              BSR     PRINT_STRING
00FD0DEE                          1569  
00FD0DEE  6100 0814               1570              BSR     READSECTOR              ;Note Sector/track values will also be updated here. 
00FD0DF2                          1571  
00FD0DF2  2239 00FD8500           1572              MOVE.L  (RAM_DMA),D1
00FD0DF8  0681 00000200           1573              ADD.L   #$200,D1
00FD0DFE  23C1 00FD8502           1574              MOVE.L  D1,(RAM_DMA_STORE)
00FD0E04                          1575  
00FD0E04  5379 00FD8506           1576              SUBQ.W  #1,(SECTOR_COUNT)
00FD0E0A  6600 0006               1577              BNE     NEXT_SEC_NRD
00FD0E0E  6000 0012               1578              BRA     DoneRSec
00FD0E12                          1579              
00FD0E12                          1580  NEXT_SEC_NRD:
00FD0E12  6100 05D4               1581              BSR     GET_NEXT_SECT           ;Point to next sector
00FD0E16  67AC                    1582              BEQ     NextRSec
00FD0E18  45F9 00FD2B1F           1583              LEA     AT_END_MSG,A2           ;Tell us we are at end of disk
00FD0E1E  6100 0F82               1584              BSR     PRINT_STRING
00FD0E22                          1585              
00FD0E22                          1586  DoneRSec:
00FD0E22  6100 0F8E               1587              BSR     CRLF                    
00FD0E26  13FC 0000 00FD850C      1588              MOVE.B  #0,(RAM_SEC)            ;Back to CPM sector 0
00FD0E2E  13FC 0000 00FD850D      1589              MOVE.B  #0,(RAM_TRK)
00FD0E36  13FC 0000 00FD850E      1590              MOVE.B  #0,(RAM_TRK+1)
00FD0E3E  6100 08D8               1591              BSR     WR_LBA                  ;Update LBA on drive
00FD0E42  6100 0F6E               1592              BSR     CRLF                    
00FD0E46  6000 FB12               1593              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0E4A                          1594  
00FD0E4A                          1595  
00FD0E4A                          1596  ;------------------ Write N Sectors to disk------------------------------------
00FD0E4A                          1597  ;Note unlike the normal sector write routine, this routine incriments the DMA address after each write.
00FD0E4A                          1598  
00FD0E4A                          1599  N_WR_SEC:   
00FD0E4A  45F9 00FD2F70           1600              LEA     WILL_WR_MSG,A2          ;Enter RAM location for the start of sector writes 
00FD0E50  6100 0F50               1601              BSR     PRINT_STRING
00FD0E54                          1602  
00FD0E54  6100 0CF0               1603              BSR     GETLONG_D7              ;Get start address
00FD0E58  B43C 000D               1604              CMP.B   #CR,D2                  ;Is it valid
00FD0E5C  6600 FAFC               1605              BNE     IDE_LOOP
00FD0E60  23C7 00FD8502           1606              MOVE.L  D7,(RAM_DMA_STORE)      ;--- Save in RAM_DMA_STORE
00FD0E66                          1607  
00FD0E66  45F9 00FD2FAB           1608              LEA     SEC_COUNT_MSG,A2        ;Enter sector count
00FD0E6C  6100 0F34               1609              BSR     PRINT_STRING
00FD0E70  6100 0D1C               1610              BSR     GETBYTE_D7              ;Get data in D7 (0-FF) 
00FD0E74  B43C 001B               1611              CMP.B   #ESC,D2                 ;If ESC then we are done
00FD0E78  6700 FAE0               1612              BEQ     IDE_LOOP
00FD0E7C  B43C 000D               1613              CMP.B   #CR,D2                  ;If CR then we are done
00FD0E80  6600 FAD8               1614              BNE     IDE_LOOP
00FD0E84  33C7 00FD8506           1615              MOVE.W  D7,(SECTOR_COUNT)       ;store sector count
00FD0E8A                          1616  
00FD0E8A  45F9 00FD27E0           1617              LEA     CONFIRM_WR_MSG,A2       ;Are you sure?
00FD0E90  6100 0F10               1618              BSR     PRINT_STRING
00FD0E94  6100 0E36               1619              BSR     GETCHAR
00FD0E98  6100 0F3E               1620              BSR     TOUPPER       
00FD0E9C  B23C 0059               1621              CMP.B   #'Y',D1
00FD0EA0  6700 0006               1622              BEQ     NextWSec1
00FD0EA4  6000 FAB4               1623              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0EA8                          1624  NextWSec1:
00FD0EA8  6100 0F08               1625              BSR     CRLF
00FD0EAC                          1626  
00FD0EAC                          1627  NextWSec:
00FD0EAC  6100 0F04               1628              BSR     CRLF                    
00FD0EB0  2239 00FD8502           1629              MOVE.L  (RAM_DMA_STORE),D1      ;DMA initially to IDE_Buffer
00FD0EB6  23C1 00FD8500           1630              MOVE.L  D1,(RAM_DMA)
00FD0EBC  2E01                    1631              MOVE.L  D1,D7
00FD0EBE  6100 0D36               1632              BSR     PUTLONG_D7              ;Show current address
00FD0EC2  45F9 00FD2B3A           1633              LEA     WRITEN_MSG,A2           ;' ----> ',0
00FD0EC8  6100 0ED8               1634              BSR     PRINT_STRING
00FD0ECC  6100 03D4               1635              BSR     DISPLAY_POSITION        ;Display current Track,sector
00FD0ED0                          1636  
00FD0ED0                          1637  
00FD0ED0  6100 07BE               1638              BSR     WRITESECTOR             ;Sector/track values are sent to board in WRITESECTOR
00FD0ED4                          1639  
00FD0ED4  2239 00FD8500           1640              MOVE.L  (RAM_DMA),D1
00FD0EDA  0681 00000200           1641              ADD.L   #$200,D1
00FD0EE0  23C1 00FD8502           1642              MOVE.L  D1,(RAM_DMA_STORE)
00FD0EE6                          1643  
00FD0EE6  5379 00FD8506           1644              SUBQ.W  #1,(SECTOR_COUNT)
00FD0EEC  6600 0006               1645              BNE     NEXT_SEC_NWR
00FD0EF0  6000 0012               1646              BRA     DoneWSec
00FD0EF4                          1647              
00FD0EF4                          1648  NEXT_SEC_NWR:
00FD0EF4  6100 04F2               1649              BSR     GET_NEXT_SECT           
00FD0EF8  67B2                    1650              BEQ     NextWSec
00FD0EFA                          1651              
00FD0EFA  45F9 00FD2B1F           1652              LEA     AT_END_MSG,A2           ;Tell us we are at end of disk
00FD0F00  6100 0EA0               1653              BSR     PRINT_STRING
00FD0F04                          1654  DoneWSec:
00FD0F04  6100 0EAC               1655              BSR     CRLF                    
00FD0F08  13FC 0000 00FD850C      1656              MOVE.B  #0,(RAM_SEC)            ;Back to CPM sector 0
00FD0F10  13FC 0000 00FD850D      1657              MOVE.B  #0,(RAM_TRK)
00FD0F18  13FC 0000 00FD850E      1658              MOVE.B  #0,(RAM_TRK+1)
00FD0F20  6100 07F6               1659              BSR     WR_LBA                  ;Update LBA on drive
00FD0F24  6100 0E8C               1660              BSR     CRLF                    
00FD0F28  6000 FA30               1661              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0F2C                          1662  
00FD0F2C                          1663  
00FD0F2C                          1664  
00FD0F2C                          1665  ;-------------- Format current disk----------------------------------------------------
00FD0F2C                          1666  
00FD0F2C  0C39 0000 00FD850E      1667  FORMAT:     CMP.B   #0,(CURRENT_IDE_DRIVE)
00FD0F34  6600 000C               1668              BNE     FORM_B
00FD0F38  45F9 00FD2AAC           1669              LEA     FORMAT_MSG_A,A2        
00FD0F3E  6000 0008               1670              BRA     FORM_X
00FD0F42  45F9 00FD2AC7           1671  FORM_B:     LEA     FORMAT_MSG_B,A2
00FD0F48                          1672  FORM_X:     
00FD0F48  6100 0E58               1673              BSR     PRINT_STRING
00FD0F4C  45F9 00FD27E0           1674              LEA     CONFIRM_WR_MSG,A2       ;Are you sure?
00FD0F52  6100 0E4E               1675              BSR     PRINT_STRING
00FD0F56  6100 0D74               1676              BSR     GETCHAR
00FD0F5A  6100 0E7C               1677              BSR     TOUPPER
00FD0F5E  B23C 0059               1678              CMP.B   #'Y',D1
00FD0F62  6700 000A               1679              BEQ     FORMAT_BUFFER           
00FD0F66  6100 0E4A               1680              BSR     CRLF                    
00FD0F6A  6000 F9EE               1681              BRA     IDE_LOOP                ;Back to IDE Menu
00FD0F6E                          1682  
00FD0F6E                          1683  FORMAT_BUFFER:
00FD0F6E  45F9 00FD2CB0           1684              LEA     FORMAT_STARTED_MSG,A2   ;The current drive is being formatted. Esc to aborot
00FD0F74  6100 0E2C               1685              BSR     PRINT_STRING
00FD0F78  6100 0E38               1686              BSR     CRLF
00FD0F7C  13FC 0000 00FD850C      1687              MOVE.B  #0,(RAM_SEC)            ;Back to CPM sec_TRK)
00FD0F84  13FC 0000 00FD850E      1688              MOVE.B  #0,(RAM_TRK+1)
00FD0F8C                          1689  
00FD0F8C  6100 078A               1690              BSR     WR_LBA                  ;Update LBA on drive
00FD0F90                          1691  
00FD0F90  3A3C E5E5               1692              MOVE.W  #$0E5E5,D5              ;First set Sector pattern to E5's
00FD0F94  45F9 00FD8100           1693              LEA     IDE_Buffer,A2
00FD0F9A  343C 0200               1694              MOVE.W  #512,D2                 ;512 bytes total to fill
00FD0F9E  14C5                    1695  CLEARF      MOVE.B  D5,(A2)+
00FD0FA0  5342                    1696              SUBQ.W  #1,D2
00FD0FA2  66FA                    1697              BNE     CLEARF
00FD0FA4                          1698  
00FD0FA4                          1699  FORMAT_LOOP:
00FD0FA4  49F9 00FD8100           1700              LEA     IDE_BUFFER,A4
00FD0FAA  23CC 00FD8500           1701              MOVE.L  A4,(RAM_DMA)            ;DMA initially to IDE_Buffer
00FD0FB0                          1702  
00FD0FB0  6100 06DE               1703              BSR     WRITESECTOR             ;Will write whatever is in the IDE_Buffer
00FD0FB4  6700 0010               1704              BEQ     SEC_FORMAT_OK
00FD0FB8                          1705              
00FD0FB8  45F9 00FD2C1F           1706              LEA     FORMAT_ERR,A2           ;Indicate an error
00FD0FBE  6100 0DE2               1707              BSR     PRINT_STRING
00FD0FC2  6000 0044               1708              BRA     FORMAT_DONE             ;Back to IDE Menu
00FD0FC6                          1709  
00FD0FC6                          1710  SEC_FORMAT_OK:
00FD0FC6  49F9 00FD8100           1711              LEA     IDE_BUFFER,A4
00FD0FCC  23CC 00FD8500           1712              MOVE.L  A4,(RAM_DMA)            ;DMA initially to IDE_Buffer
00FD0FD2                          1713              
00FD0FD2  0C39 0000 00FD850C      1714              CMP.B   #0,(RAM_SEC)            ;Get Current Sector
00FD0FDA  6600 0006               1715              BNE     SKIP_SHOW_TRACK
00FD0FDE  6100 0366               1716              BSR     SHOW_TRACK
00FD0FE2                          1717  
00FD0FE2                          1718  SKIP_SHOW_TRACK:
00FD0FE2  6100 0404               1719              BSR     GET_NEXT_SECT           ;RET NZ if end of disk
00FD0FE6  6600 0016               1720              BNE     DISK_END
00FD0FEA                          1721              
00FD0FEA  6100 0D14               1722              BSR     GETSTAT                 ;Any keyboard character will stop display
00FD0FEE  67B4                    1723              BEQ     FORMAT_LOOP
00FD0FF0  6100 0CDA               1724              BSR     GETCHAR
00FD0FF4  B23C 001B               1725              CMP.B   #ESC,D1
00FD0FF8  66AA                    1726              BNE     FORMAT_LOOP
00FD0FFA  6000 000C               1727              BRA     FORMAT_DONE
00FD0FFE                          1728  
00FD0FFE                          1729  DISK_END:   
00FD0FFE  45F9 00FD2B1F           1730              LEA     AT_END_MSG,A2           ;Tell us we are at end of disk
00FD1004  6100 0D9C               1731              BSR     PRINT_STRING
00FD1008                          1732  FORMAT_DONE:
00FD1008  123C 0000               1733              MOVE.B  #0,D1                   ;Login drive A:
00FD100C  6100 F9EA               1734              BSR     SELECT_DRIVE
00FD1010  13C1 00FD850E           1735              MOVE.B  D1,(CURRENT_IDE_DRIVE)
00FD1016  13FC 0000 00FD850C      1736              MOVE.B  #0,(RAM_SEC)            ;Back to CPM sector 0
00FD101E  13FC 0000 00FD850D      1737              MOVE.B  #0,(RAM_TRK)
00FD1026  13FC 0000 00FD850E      1738              MOVE.B  #0,(RAM_TRK+1)
00FD102E  6100 06E8               1739              BSR     WR_LBA                  ;Update LBA on drive
00FD1032  6100 0D7E               1740              BSR     CRLF                    
00FD1036  6000 F922               1741              BRA     IDE_LOOP                ;Back to IDE Menu
00FD103A                          1742  
00FD103A                          1743  
00FD103A                          1744  ;---------------- Copy Drive A: to Drive B:  ------------------------------
00FD103A                          1745  
00FD103A                          1746  
00FD103A                          1747  COPY_AB:    
00FD103A  45F9 00FD2B43           1748              LEA     DiskCopyMsg,A2
00FD1040  6100 0D60               1749              BSR     PRINT_STRING
00FD1044  6100 0C86               1750              BSR     GETCHAR
00FD1048  6100 0D8E               1751              BSR     TOUPPER
00FD104C  B23C 0059               1752              CMP.B   #'Y',D1
00FD1050  6700 0006               1753              BEQ     COPY_AB1
00FD1054  6000 00A6               1754              BRA     C_DONE
00FD1058                          1755              
00FD1058                          1756  COPY_AB1:   
00FD1058  13FC 0000 00FD850C      1757              MOVE.B  #0,(RAM_SEC)            ;Start with CPM sector 0
00FD1060  13FC 0000 00FD850D      1758              MOVE.B  #0,(RAM_TRK)            ;Start with CPM Track 0
00FD1068  13FC 0000 00FD850E      1759              MOVE.B  #0,(RAM_TRK+1)
00FD1070  6100 0D40               1760              BSR     CRLF
00FD1074  6100 0D3C               1761              BSR     CRLF
00FD1078                          1762              
00FD1078                          1763  NextDCopy:  
00FD1078  123C 0000               1764              MOVE.B  #0,D1                   ;Login drive A:
00FD107C  6100 F97A               1765              BSR     SELECT_DRIVE
00FD1080                          1766  
00FD1080  6100 0696               1767              BSR     WR_LBA                  ;Update LBA on "A:" drive
00FD1084                          1768  
00FD1084  49F9 00FD8100           1769              LEA     IDE_BUFFER,A4
00FD108A  23CC 00FD8500           1770              MOVE.L  A4,(RAM_DMA)            ;DMA initially to IDE_Buffer
00FD1090                          1771              
00FD1090  6100 0572               1772              BSR     READSECTOR              ;Get sector data from A: drive to buffer
00FD1094                          1773              
00FD1094  123C 0001               1774              MOVE.B  #1,D1                   ;Login drive B:
00FD1098  6100 F95E               1775              BSR     SELECT_DRIVE
00FD109C                          1776              
00FD109C  6100 067A               1777              BSR     WR_LBA                  ;Update LBA on "B:" drive
00FD10A0                          1778              
00FD10A0  49F9 00FD8100           1779              LEA     IDE_BUFFER,A4
00FD10A6  23CC 00FD8500           1780              MOVE.L  A4,(RAM_DMA)
00FD10AC                          1781  
00FD10AC  6100 05E2               1782              BSR     WRITESECTOR             ;Write buffer data to sector on B: drive
00FD10B0  6700 0018               1783              BEQ     COPY_OK1
00FD10B4                          1784  
00FD10B4  45F9 00FD2BE3           1785              LEA     COPY_ERR,A2             ;Indicate an error
00FD10BA  6100 0CE6               1786              BSR     PRINT_STRING
00FD10BE  6100 0248               1787              BSR     SHOW_TRACK_SEC          ;Show current location of error
00FD10C2  6100 0CEE               1788              BSR     CRLF
00FD10C6  6000 001E               1789              BRA     COPY_OK3
00FD10CA                          1790  
00FD10CA                          1791  COPY_OK1:
00FD10CA  0C39 0000 00FD850C      1792              CMP.B   #0,(RAM_SEC)            ;Get Current Sector
00FD10D2  6600 0006               1793              BNE     COPY_OK2
00FD10D6                          1794  
00FD10D6  6100 026E               1795              BSR     SHOW_TRACK
00FD10DA                          1796              
00FD10DA                          1797  COPY_OK2:
00FD10DA  6100 0C24               1798              BSR     GETSTAT                 ;Any keyboard character will stop display
00FD10DE  6700 004E               1799              BEQ     C_NEXTSEC1
00FD10E2  6100 0BE8               1800              BSR     GETCHAR                 ;Flush character
00FD10E6                          1801  COPY_OK3:
00FD10E6  45F9 00FD2A7A           1802              LEA     CONTINUE_MSG,A2
00FD10EC  6100 0CB4               1803              BSR     PRINT_STRING
00FD10F0  6100 0BDA               1804              BSR     GETCHAR
00FD10F4  B23C 001B               1805              CMP.B   #ESC,D1
00FD10F8  6600 0034               1806              BNE     C_NEXTSEC1
00FD10FC  123C 0000               1807  C_DONE:     MOVE.B  #0,D1                   ;Login drive A:
00FD1100  6100 F8F6               1808              BSR     SELECT_DRIVE
00FD1104  13C1 00FD850E           1809              MOVE.B  D1,(CURRENT_IDE_DRIVE)
00FD110A  13FC 0000 00FD850C      1810              MOVE.B  #0,(RAM_SEC)            ;Start with CPM sector 0
00FD1112  13FC 0000 00FD850D      1811              MOVE.B  #0,(RAM_TRK)            ;Start with CPM Track 0
00FD111A  13FC 0000 00FD850E      1812              MOVE.B  #0,(RAM_TRK+1)
00FD1122  6100 05F4               1813              BSR     WR_LBA                  ;Update LBA on drive
00FD1126  6100 0C8A               1814              BSR     CRLF                    
00FD112A  6000 F82E               1815              BRA     IDE_LOOP                ;Back to IDE Menu
00FD112E                          1816              
00FD112E                          1817  C_NEXTSEC1:
00FD112E  6100 02B8               1818              BSR     GET_NEXT_SECT           ;Update to next sector/track
00FD1132  6600 0006               1819              BNE     C_NEXTSEC2
00FD1136  6000 FF40               1820              BRA     NextDCopy
00FD113A                          1821  
00FD113A                          1822  C_NEXTSEC2: 
00FD113A  45F9 00FD2B86           1823              LEA     CopyDone,A2             ;Tell us we are all done.
00FD1140  6100 0C60               1824              BSR     PRINT_STRING
00FD1144  60B6                    1825              BRA     C_DONE
00FD1146                          1826              
00FD1146                          1827              
00FD1146                          1828              
00FD1146                          1829  ;-------------- Verify Drive A: = B: ------------------------------
00FD1146                          1830  
00FD1146                          1831  VERIFY_AB:  
00FD1146  45F9 00FD2B65           1832              LEA     DiskVerifyMsg,A2
00FD114C  6100 0C54               1833              BSR     PRINT_STRING
00FD1150                          1834              
00FD1150  13FC 0000 00FD850C      1835              MOVE.B  #0,(RAM_SEC)            ;Start with CPM sector 0
00FD1158  13FC 0000 00FD850D      1836              MOVE.B  #0,(RAM_TRK)            ;Start with CPM Track 0
00FD1160  13FC 0000 00FD850E      1837              MOVE.B  #0,(RAM_TRK+1)
00FD1168  6100 0C48               1838              BSR     CRLF
00FD116C  6100 0C44               1839              BSR     CRLF
00FD1170                          1840              
00FD1170                          1841  NextVCopy:
00FD1170  123C 0000               1842              MOVE.B  #0,D1                   ;Login drive A:
00FD1174  6100 F882               1843              BSR     SELECT_DRIVE
00FD1178                          1844  
00FD1178  6100 059E               1845              BSR     WR_LBA                  ;Update LBA on "A:" drive
00FD117C                          1846  
00FD117C  49F9 00FD8100           1847              LEA     IDE_BUFFER,A4
00FD1182  23CC 00FD8500           1848              MOVE.L  A4,(RAM_DMA)
00FD1188                          1849              
00FD1188  6100 047A               1850              BSR     READSECTOR              ;Get sector data from A: drive to buffer
00FD118C                          1851  
00FD118C  123C 0001               1852              MOVE.B  #1,D1                   ;Login drive B:
00FD1190  6100 F866               1853              BSR     SELECT_DRIVE
00FD1194                          1854              
00FD1194  6100 0582               1855              BSR     WR_LBA                  ;Update LBA on "B:" drive
00FD1198                          1856  
00FD1198  49F9 00FD8300           1857              LEA     IDE_BUFFER2,A4
00FD119E  23CC 00FD8500           1858              MOVE.L  A4,(RAM_DMA)            ;DMA initially to IDE_Buffer2
00FD11A4                          1859              
00FD11A4  6100 045E               1860              BSR     READSECTOR
00FD11A8                          1861  
00FD11A8  45F9 00FD8300           1862              LEA     IDE_Buffer2,A2
00FD11AE  47F9 00FD8100           1863              LEA     IDE_Buffer,A3
00FD11B4  323C 0200               1864              MOVE.W  #512,D1                 ;Length of sector in words
00FD11B8                          1865  
00FD11B8                          1866  NEXT_CMP:
00FD11B8  B70A                    1867              CMP.B   (A2)+,(A3)+             ;Are they the same
00FD11BA  6600 000A               1868              BNE     VER_ERROR
00FD11BE  5341                    1869              SUBQ.W  #1,D1
00FD11C0  66F6                    1870              BNE     NEXT_CMP                ;CX will contain count of words done so far, (0 if done OK)
00FD11C2  6000 0014               1871              BRA     IDE_VERIFY_OK
00FD11C6                          1872  
00FD11C6                          1873  VER_ERROR:
00FD11C6  45F9 00FD2B98           1874              LEA     VERIFY_ERR,A2           ;'Verify Error. 
00FD11CC  6100 0BD4               1875              BSR     PRINT_STRING            
00FD11D0  6100 0136               1876              BSR     SHOW_TRACK_SEC          ;Show current location of error
00FD11D4  6000 001E               1877              BRA     VERIFYT1                ;Ask for a continue message here
00FD11D8                          1878              
00FD11D8                          1879  IDE_VERIFY_OK:
00FD11D8  0C39 0000 00FD850C      1880              CMP.B   #0,(RAM_SEC)            ;Get Current Sector
00FD11E0  6600 0006               1881              BNE     VERIFYT
00FD11E4                          1882  
00FD11E4  6100 0160               1883              BSR     SHOW_TRACK
00FD11E8                          1884              
00FD11E8                          1885  VERIFYT:
00FD11E8  6100 0B16               1886              BSR     GETSTAT                 ;Any keyboard character will stop display
00FD11EC  6700 0020               1887              BEQ     V_NEXTSEC1
00FD11F0  6100 0ADA               1888              BSR     GETCHAR                 ;Flush character
00FD11F4                          1889  VERIFYT1:
00FD11F4  45F9 00FD2A7A           1890              LEA     CONTINUE_MSG,A2
00FD11FA  6100 0BA6               1891              BSR     PRINT_STRING
00FD11FE  6100 0ACC               1892              BSR     GETCHAR
00FD1202  B23C 001B               1893              CMP.B   #ESC,D1
00FD1206  6600 0006               1894              BNE     V_NEXTSEC1
00FD120A  6000 0018               1895              BRA     V_NEXTSEC3
00FD120E                          1896  V_NEXTSEC1:
00FD120E  6100 01D8               1897              BSR     GET_NEXT_SECT           ;Update to next sector/track
00FD1212  6600 0006               1898              BNE     V_NEXTSEC2
00FD1216  6000 FF58               1899              BRA     NextVCopy
00FD121A                          1900  V_NEXTSEC2: 
00FD121A  45F9 00FD2BAE           1901              LEA     VerifyDone,A2           ;Tell us we are all done.
00FD1220  6100 0B80               1902              BSR     PRINT_STRING
00FD1224                          1903  V_NEXTSEC3:
00FD1224  123C 0000               1904              MOVE.B  #0,D1                   ;Login drive A:
00FD1228  6100 F7CE               1905              BSR     SELECT_DRIVE
00FD122C  13C1 00FD850E           1906              MOVE.B  D1,(CURRENT_IDE_DRIVE)
00FD1232  13FC 0000 00FD850C      1907              MOVE.B  #0,(RAM_SEC)            ;Start with CPM sector 0
00FD123A  13FC 0000 00FD850D      1908              MOVE.B  #0,(RAM_TRK)            ;Start with CPM Track 0
00FD1242  13FC 0000 00FD850E      1909              MOVE.B  #0,(RAM_TRK+1)
00FD124A  6100 04CC               1910              BSR     WR_LBA                  ;Update LBA on drive
00FD124E  6100 0B62               1911              BSR     CRLF                    
00FD1252  6000 F706               1912              BRA     IDE_LOOP                ;Back to IDE Menu
00FD1256                          1913              
00FD1256                          1914              
00FD1256                          1915              
00FD1256                          1916              
00FD1256                          1917  ;-------------------- Back to parent 68K Monitor commands
00FD1256                          1918  QUIT_IDE:
00FD1256  6000 EE04               1919              BRA     LOOP                    ;Back to main Menu
00FD125A                          1920              
00FD125A                          1921              
00FD125A                          1922  
00FD125A                          1923  ;==================== Support Routines FOR IDE MODULE ==================================
00FD125A                          1924  
00FD125A                          1925  ;Generate an LBA sector number with data input from CPM style Track# & Sector#
00FD125A                          1926  
00FD125A                          1927  GEN_HEX32_LBA:
00FD125A  45F9 00FD2871           1928              LEA     ENTERRAM_SECL,A2        ;Enter sector number, low
00FD1260  6100 0B40               1929              BSR     PRINT_STRING
00FD1264  6100 0928               1930              BSR     GETBYTE_D7              ;Get 8 bit value (2 digits) to D7
00FD1268  13C7 00FD850C           1931              MOVE.B  D7,(RAM_SEC)
00FD126E  6100 0B42               1932              BSR     CRLF
00FD1272                          1933  
00FD1272  45F9 00FD2891           1934              LEA     ENTERRAM_TRKL,A2        ;Enter low byte track number
00FD1278  6100 0B28               1935              BSR     PRINT_STRING
00FD127C  6100 0910               1936              BSR     GETBYTE_D7              ;Get 8 bit value (2 digits) to D7
00FD1280  13C7 00FD850D           1937              MOVE.B  D7,RAM_TRK
00FD1286  6100 0B2A               1938              BSR     CRLF
00FD128A                          1939  
00FD128A  45F9 00FD28B1           1940              LEA     ENTERRAM_TRKH,A2        ;Enter high byte track number
00FD1290  6100 0B10               1941              BSR     PRINT_STRING
00FD1294  6100 08F8               1942              BSR     GETBYTE_D7              ;Get 8 bit value (2 digits) to D7
00FD1298  13C7 00FD850E           1943              MOVE.B  D7,(RAM_TRK+1)
00FD129E  4201                    1944              CLR.B   D1                      ;To return NC
00FD12A0  4E75                    1945              RTS
00FD12A2                          1946  
00FD12A2                          1947  
00FD12A2                          1948  DISPLAY_POSITION:   ;Display current track,sector & head position
00FD12A2  45F9 00FD3057           1949              LEA     msgCPMTRK,A2            ;Display in LBA format
00FD12A8  6100 0AF8               1950              BSR     PRINT_STRING            ;---- CPM FORMAT ----
00FD12AC  1C39 00FD850E           1951              MOVE.B  (RAM_TRK+1),D6
00FD12B2  6100 0984               1952              BSR     PUTBYTE_D6              ;High TRK byte
00FD12B6  1C39 00FD850D           1953              MOVE.B  (RAM_TRK),D6
00FD12BC  6100 097A               1954              BSR     PUTBYTE_D6              ;Low TRK byte
00FD12C0                          1955  
00FD12C0  45F9 00FD3062           1956              LEA     msgCPMSEC,A2
00FD12C6  6100 0ADA               1957              BSR     PRINT_STRING            ;SEC = (16 bits)
00FD12CA                          1958  ;           MOVE.B  (RAM_SEC+1),D6          ;High Sec
00FD12CA                          1959  ;           BSR     PUTBYTE_D6
00FD12CA  1C39 00FD850C           1960              MOVE.B  (RAM_SEC),D6            ;Low Sec
00FD12D0  6100 0966               1961              BSR     PUTBYTE_D6
00FD12D4                          1962              
00FD12D4                          1963              ;---- LBA FORMAT ----
00FD12D4  45F9 00FD306E           1964              LEA     msgLBA,A2
00FD12DA  6100 0AC6               1965              BSR     PRINT_STRING            ;(LBA = 00 (<-- Old "Heads" = 0 for these drives).
00FD12DE                          1966              
00FD12DE  1C39 00FD8509           1967              MOVE.B  (DISPLAY_TRK+1),D6      ;High "cylinder" byte
00FD12E4  6100 0952               1968              BSR     PUTBYTE_D6
00FD12E8  1C39 00FD8508           1969              MOVE.B  (DISPLAY_TRK),D6        ;Low "cylinder" byte
00FD12EE  6100 0948               1970              BSR     PUTBYTE_D6
00FD12F2                          1971  
00FD12F2  1C39 00FD850A           1972              MOVE.B  (DISPLAY_SEC),D6
00FD12F8  6100 093E               1973              BSR     PUTBYTE_D6
00FD12FC  45F9 00FD307A           1974              LEA     MSGBracket,A2           ;)$
00FD1302  6100 0A9E               1975              BSR     PRINT_STRING
00FD1306  4E75                    1976              RTS
00FD1308                          1977  
00FD1308                          1978  
00FD1308                          1979  
00FD1308                          1980  SHOW_TRACK_SEC:     ;Display current (CPM) track,sector
00FD1308  45F9 00FD3057           1981              LEA     msgCPMTRK,A2            
00FD130E  6100 0A92               1982              BSR     PRINT_STRING            ;---- CPM FORMAT ----
00FD1312  1C39 00FD850E           1983              MOVE.B  (RAM_TRK+1),D6          ;High TRK byte
00FD1318  6100 091E               1984              BSR     PUTBYTE_D6
00FD131C  1C39 00FD850D           1985              MOVE.B  (RAM_TRK),D6            ;Low TRK byte
00FD1322  6100 0914               1986              BSR     PUTBYTE_D6
00FD1326                          1987  
00FD1326  45F9 00FD3062           1988              LEA     msgCPMSEC,A2
00FD132C  6100 0A74               1989              BSR     PRINT_STRING            
00FD1330                          1990              
00FD1330  1C39 00FD850C           1991              MOVE.B  (RAM_SEC),D6            ;Low Sec (Only)
00FD1336  6100 0900               1992              BSR     PUTBYTE_D6
00FD133A  45F9 00FD307C           1993              LEA     H_MSG_CRLF,A2           
00FD1340  6100 0A60               1994              BSR     PRINT_STRING            
00FD1344  4E75                    1995              RTS
00FD1346                          1996  
00FD1346                          1997  SHOW_TRACK:
00FD1346  45F9 00FD3057           1998              LEA     msgCPMTRK,A2            ;CPM TRACK=
00FD134C  6100 0A54               1999              BSR     PRINT_STRING            
00FD1350  1C39 00FD850D           2000              MOVE.B  (RAM_TRK),D6            ;Low TRK byte
00FD1356  6100 08E0               2001              BSR     PUTBYTE_D6
00FD135A  45F9 00FD3080           2002              LEA     H_MSG_CR,A2             
00FD1360  6100 0A40               2003              BSR     PRINT_STRING            
00FD1364  4E75                    2004              RTS
00FD1366                          2005  
00FD1366                          2006  
00FD1366                          2007  
00FD1366                          2008  DISPLAY_SECTOR:     ;Print a DISPLAY_SEC of the data in the 512 byte IDE_Buffer (RAM_DMA)
00FD1366  6100 0A4A               2009              BSR     CRLF                    ;Note written so it can be easily converted to a "normal: DS: based" routine
00FD136A  2479 00FD8500           2010              MOVE.L  RAM_DMA,A2              ;Get Current DMA Address to A2 & A3
00FD1370  264A                    2011              MOVE.L  A2,A3
00FD1372  163C 0020               2012              MOVE.B  #32,D3                  ;print 32 lines
00FD1376                          2013              
00FD1376  2E0A                    2014  SF172:      MOVE.L  A2,D7
00FD1378  6100 087C               2015              BSR     PUTLONG_D7              ;Show current address
00FD137C  123C 0020               2016              MOVE.B  #BLANK,D1
00FD1380  6100 0918               2017              BSR     PUTCHAR                 BEQAT_DISK_END
00FD1384  123C 0020               2018              MOVE.B  #BLANK,D1
00FD1388  6100 0910               2019              BSR     PUTCHAR
00FD138C                          2020  
00FD138C  183C 0010               2021              MOVE.B  #16,D4                  ;16 characters across
00FD1390  1C1A                    2022  SF175:      MOVE.B  (A2)+,D6
00FD1392  6100 08A4               2023              BSR     PUTBYTE_D6
00FD1396  5304                    2024              SUBQ.B  #1,D4
00FD1398  66F6                    2025              BNE     SF175
00FD139A                          2026  
00FD139A  123C 0020               2027              MOVE.B  #BLANK,D1
00FD139E  6100 08FA               2028              BSR     PUTCHAR
00FD13A2  123C 0020               2029              MOVE.B  #BLANK,D1
00FD13A6  6100 08F2               2030              BSR     PUTCHAR
00FD13AA  123C 0020               2031              MOVE.B  #BLANK,D1
00FD13AE  6100 08EA               2032              BSR     PUTCHAR
00FD13B2                          2033              
00FD13B2  183C 0010               2034              MOVE.B  #16,D4                  ;16 across again
00FD13B6  1C1B                    2035  Sloop2:     MOVE.B  (A3)+,D6                
00FD13B8  CC3C 007F               2036              AND.B   #$7f,D6
00FD13BC  BC3C 0020               2037              CMP.B   #' ',D6                 ;filter out control characters
00FD13C0  6C08                    2038              BGE.B   Sloop3
00FD13C2  1C3C 002E               2039              MOVE.B  #'.',D6
00FD13C6  6000 000C               2040              BRA     Sloop4
00FD13CA  BC3C 007E               2041  Sloop3:     CMP.B   #'~',D6
00FD13CE  6F04                    2042              BLE.B   Sloop4
00FD13D0  1C3C 002E               2043              MOVE.B  #'.',D6
00FD13D4  1206                    2044  Sloop4:     MOVE.B  D6,D1
00FD13D6  6100 08C2               2045              BSR     PUTCHAR
00FD13DA  5304                    2046              SUBQ.B  #1,D4
00FD13DC  66D8                    2047              BNE     Sloop2                  
00FD13DE  6100 09D2               2048              BSR     CRLF
00FD13E2                          2049              
00FD13E2  5303                    2050              SUBQ.B  #1,D3
00FD13E4  6690                    2051              BNE     SF172
00FD13E6  4E75                    2052              RTS
00FD13E8                          2053  
00FD13E8                          2054  
00FD13E8                          2055  
00FD13E8                          2056  
00FD13E8                          2057              ;Point to next sector.  Ret Z if all OK,NZ if at end of disk
00FD13E8                          2058  GET_NEXT_SECT:      
00FD13E8  5239 00FD850C           2059              ADDQ.B  #1,(RAM_SEC)            ;Inc Current Sector
00FD13EE  0C39 00FE 00FD850C      2060              CMP.B   #MAXSEC-1,(RAM_SEC)     ;Assumes < 255 sec /track
00FD13F6  6600 0024               2061              BNE     NEXT_SEC_DONE
00FD13FA                          2062              
00FD13FA  13FC 0000 00FD850C      2063              MOVE.B  #0,(RAM_SEC)            ;Back to CPM sector 0
00FD1402                          2064              
00FD1402  5239 00FD850D           2065              ADDQ.B  #1,(RAM_TRK)            ;Bump to next track
00FD1408  13FC 0000 00FD850E      2066              MOVE.B  #0,(RAM_TRK+1)          
00FD1410  0C39 0000 00FD850D      2067              CMP.B   #0,(RAM_TRK)            ;Tracks 0-0FFH only
00FD1418  6700 000A               2068              BEQ     AT_DISK_END
00FD141C                          2069  NEXT_SEC_DONE:
00FD141C  6100 02FA               2070              BSR     WR_LBA                  ;Update the LBC pointer
00FD1420  B301                    2071              EOR.B   D1,D1
00FD1422  4E75                    2072              RTS     ;Ret Z if all OK
00FD1424                          2073  AT_DISK_END:
00FD1424  6100 02F2               2074              BSR     WR_LBA                  ;Update the LBC pointer
00FD1428  B301                    2075              EOR.B   D1,D1
00FD142A  5301                    2076              SUBQ.B  #1,D1
00FD142C  4E75                    2077              RTS     ;;Ret NZ if end of disk
00FD142E                          2078  
00FD142E                          2079              
00FD142E                          2080  
00FD142E                          2081              ;Point to previous sector.  Ret Z if all OK
00FD142E                          2082  GET_PREV_SECT:      
00FD142E  0C39 0000 00FD850C      2083              CMP.B   #0,(RAM_SEC)            ;Get Current Sector
00FD1436  6700 000C               2084              BEQ     PREVIOUS_TRACK
00FD143A  5339 00FD850C           2085              SUBQ.B  #1,(RAM_SEC)            ;0 to MAXSEC CPM Sectors
00FD1440  6000 0024               2086              BRA     PREVIOUS_SEC_DONE
00FD1444                          2087  
00FD1444                          2088  PREVIOUS_TRACK:     
00FD1444  13FC 00FE 00FD850C      2089              MOVE.B  #MAXSEC-1,(RAM_SEC)     ;Back to CPM last sector on previous track
00FD144C                          2090              
00FD144C  0C39 0000 00FD850D      2091              CMP.B   #0,(RAM_TRK)            ;If On track 0 already then problem
00FD1454  6700 0018               2092              BEQ     AT_00
00FD1458  5339 00FD850D           2093              SUBQ.B  #1,(RAM_TRK)
00FD145E  13FC 0000 00FD850E      2094              MOVE.B  #0,(RAM_TRK+1)          
00FD1466                          2095  PREVIOUS_SEC_DONE:
00FD1466  6100 02B0               2096              BSR     WR_LBA                  ;Update the LBC pointer
00FD146A  B301                    2097              EOR.B   D1,D1
00FD146C  4E75                    2098              RTS     ;Ret z if all OK
00FD146E  6100 02A8               2099  AT_00:      BSR     WR_LBA                  ;Update the LBC pointer
00FD1472  45F9 00FD2AE2           2100              LEA     ATHOME_MSG,A2
00FD1478  6100 0928               2101              BSR     PRINT_STRING
00FD147C  B301                    2102              EOR.B   D1,D1
00FD147E  5301                    2103              SUBQ.B  #1,D1
00FD1480  4E75                    2104              RTS     
00FD1482                          2105  
00FD1482                          2106  ;
00FD1482                          2107  SHOWerrors:
00FD1482  6100 092E               2108              BSR     CRLF
00FD1486  1A3C 000F               2109              MOVE.B  #REGstatus,D5           ;Get status in status register
00FD148A  6100 03C8               2110              BSR     IDErd8D
00FD148E  1C04                    2111              MOVE.B  D4,D6
00FD1490  0804 0000               2112              BTST    #0,D4                   ;Error bit
00FD1494  6600 0052               2113              BNE     MoreError               ;Go to  REGerr register for more info
00FD1498                          2114              ;All OK if 01000000
00FD1498                          2115              
00FD1498  0804 0007               2116              BTST    #7,D4                   ;Busy bit
00FD149C  6700 0010               2117              BEQ     NOT7
00FD14A0  45F9 00FD28D2           2118              LEA     DRIVE_BUSY,A2           ;Drive Busy (bit 7) stuck high.   Status = 
00FD14A6  6100 08FA               2119              BSR     PRINT_STRING
00FD14AA  6000 00C2               2120              BRA     DONEERR
00FD14AE                          2121              
00FD14AE  0804 0006               2122  NOT7:       BTST    #6,D4                   ;Ready bit
00FD14B2  6600 0010               2123              BNE     NOT6
00FD14B6  45F9 00FD28FD           2124              LEA     DRIVE_NOT_READY,A2      ;Drive Not Ready (bit 6) stuck low.  Status = 
00FD14BC  6100 08E4               2125              BSR     PRINT_STRING
00FD14C0  6000 00AC               2126              BRA     DONEERR
00FD14C4                          2127              
00FD14C4  0804 0005               2128  NOT6:       BTST    #5,D4                   ;Fault bit
00FD14C8  6600 0010               2129              BNE     NOT5
00FD14CC  45F9 00FD2927           2130              LEA     DRIVE_WR_FAULT,A2       ;Drive write fault.    Status =
00FD14D2  6100 08CE               2131              BSR     PRINT_STRING
00FD14D6  6000 0096               2132              BRA     DONEERR
00FD14DA                          2133              
00FD14DA  45F9 00FD2947           2134  NOT5:       LEA     UNKNOWN_ERROR,A2
00FD14E0  6100 08C0               2135              BSR     PRINT_STRING
00FD14E4  6000 0088               2136              BRA     DONEERR
00FD14E8                          2137  
00FD14E8                          2138  MoreError:  ;Get here if bit 0 of the status register indicted a problem
00FD14E8  1A3C 0009               2139              MOVE.B  #REGerr,D5              ;Get error code in REGerr
00FD14EC  6100 0366               2140              BSR     IDErd8D
00FD14F0  1C04                    2141              MOVE.B  D4,D6
00FD14F2                          2142  
00FD14F2  0804 0004               2143              BTST    #4,D4                   ;Not found bit
00FD14F6  6700 0010               2144              BEQ     NOTE4
00FD14FA  45F9 00FD29EA           2145              LEA     SEC_NOT_FOUND,A2
00FD1500  6100 08A0               2146              BSR     PRINT_STRING
00FD1504  6000 0068               2147              BRA     DONEERR
00FD1508                          2148  
00FD1508  0804 0007               2149  NOTE4:      BTST    #7,D4                   ;Bad block bit
00FD150C  6700 0010               2150              BEQ     NOTE7
00FD1510  45F9 00FD2975           2151              LEA     BAD_BLOCK,A2
00FD1516  6100 088A               2152              BSR     PRINT_STRING
00FD151A  6000 0052               2153              BRA     DONEERR
00FD151E                          2154  
00FD151E  0804 0006               2155  NOTE7:      BTST    #6,D4                   ;Uncorrectable bit
00FD1522  6700 0010               2156              BEQ     NOTE6
00FD1526  45F9 00FD2999           2157              LEA     UNRECOVER_ERR,A2
00FD152C  6100 0874               2158              BSR     PRINT_STRING
00FD1530  6000 003C               2159              BRA     DONEERR
00FD1534                          2160  
00FD1534  0804 0002               2161  NOTE6:      BTST    #2,D4                   ;Invalid command bit
00FD1538  6700 0012               2162              BEQ     NOTE2
00FD153C  45F9 00FD2A0E           2163              LEA     INVALID_CMD,A2
00FD1542  6100 085E               2164              BSR     PRINT_STRING
00FD1546  4EF9 00FD156E           2165              JMP     DONEERR
00FD154C                          2166  
00FD154C  0804 0001               2167  NOTE2:      BTST    #1,D4                   ;Not found bit
00FD1550  6700 0012               2168              BEQ     NOTE1
00FD1554  45F9 00FD2A31           2169              LEA     TRK0_ERR,A2
00FD155A  6100 0846               2170              BSR     PRINT_STRING
00FD155E  4EF9 00FD156E           2171              JMP     DONEERR
00FD1564                          2172  
00FD1564  45F9 00FD2A59           2173  NOTE1:      LEA     UNKNOWN_ERROR1,A2
00FD156A  6100 0836               2174              BSR     PRINT_STRING
00FD156E                          2175  
00FD156E                          2176  DONEERR:    ;Display Byte bit pattern in D6
00FD156E  6100 06F8               2177              BSR     PUTBITS_D6              ;Show error bit pattern
00FD1572  6100 083E               2178              BSR     CRLF
00FD1576  303C 0001               2179              MOVE.W  #1,D0                   ;Set NZ flag
00FD157A  4E75                    2180              RTS
00FD157C                          2181  
00FD157C                          2182  
00FD157C                          2183  ;================================================================================================
00FD157C                          2184  ; IDE Drive BIOS Routines written in a format that can be used with CPM68K throughout we 
00FD157C                          2185  ; will use IDE_BUFFER so the the buffers can reside at the top segment of available RAM. 
00FD157C                          2186  ; Normally this will be FD8100H  (Above the ROM).
00FD157C                          2187  ;================================================================================================
00FD157C                          2188  
00FD157C                          2189  IDEinit:    ;Initilze the 8255 and drive then do a hard reset on the drive, 
00FD157C                          2190              ;By default the drive will come up initilized in LBA mode.
00FD157C                          2191  
00FD157C  13FC 0092 00FF0033      2192              MOVE.B  #READcfg8255,IDECtrlPort;Config 8255 chip, READ mode
00FD1584                          2193  
00FD1584  13FC 0000 00FF0032      2194              MOVE.B  #0,IDEportC                 ;No IDE control lines asserted
00FD158C  323C 0020               2195              MOVE.W  #$20,D1                     ;time delay for reset/initilization
00FD1590  5341                    2196  InitDelay:  SUBQ.W  #1,D1
00FD1592  66FC                    2197              BNE     InitDelay                   ;Delay
00FD1594                          2198  
00FD1594  13FC 0080 00FF0032      2199              MOVE.B  #IDErstline,IDEportC     ;Hard reset the disk drive
00FD159C                          2200              
00FD159C  323C 0080               2201              MOVE.W  #IDE_Reset_Delay,D1     ;Time delay for reset/initilization (~66 uS, with 8MHz 8086, 1 I/O wait state)
00FD15A0                          2202  ResetDelay:
00FD15A0  5341                    2203              SUBQ.W  #1,D1
00FD15A2  66FC                    2204              BNE     ResetDelay              ;Delay (IDE reset pulse width)
00FD15A4                          2205  
00FD15A4  13FC 0000 00FF0032      2206              MOVE.B  #0,IDEportC             ;No IDE control lines asserted
00FD15AC                          2207  
00FD15AC  6100 0044               2208              BSR     DELAY_32                ;Allow time for CF/Drive to recover
00FD15B0                          2209              
00FD15B0  183C 00E0               2210              MOVE.B  #%11100000,D4           ;Data for IDE SDH reg (512bytes, LBA mode,single drive,head 0000)
00FD15B4                          2211  ;           MOVE.B  #%10100000,D4           ;For Trk,Sec,head (non LBA) use 10100000 (This is the mode we use for MSDOS)
00FD15B4                          2212              ;Note. Cannot get LBA mode to work with an old Seagate Medalist 6531 drive.
00FD15B4                          2213              ;have to use the non-LBA mode. (Common for old hard disks).
00FD15B4  1A3C 000E               2214              MOVE.B  #REGshd,D5              ;00001110,(0EH) for CS0,A2,A1,  
00FD15B8  6100 02BE               2215              BSR     IDEwr8D                 ;Write byte to select the MASTER device
00FD15BC                          2216  
00FD15BC  1C3C 00FF               2217              MOVE.B  #$FF,D6                 ;<<< May need to adjust delay time
00FD15C0                          2218  WaitInit:
00FD15C0  1A3C 000F               2219              MOVE.B  #REGstatus,D5           ;Get status after initilization
00FD15C4  6100 028E               2220              BSR     IDErd8D                 ;Check Status (info in [DH])
00FD15C8  1204                    2221              MOVE.B  D4,D1
00FD15CA  C23C 0080               2222              AND.B   #$80,D1
00FD15CE  6700 001E               2223              BEQ     DoneInit                ;Return if ready bit is zero
00FD15D2                          2224              
00FD15D2  2E3C 0000FFFF           2225              MOVE.L  #$0FFFF,D7
00FD15D8  1A3C 0002               2226  DELAY2:     MOVE.B  #2,D5                   ;May need to adjust delay time to allow cold drive to
00FD15DC  5305                    2227  DELAY1:     SUBQ.B  #1,D5                   ;to speed
00FD15DE  66FC                    2228              BNE     DELAY1
00FD15E0  5307                    2229              SUBQ.B  #1,D7
00FD15E2  66F4                    2230              BNE     DELAY2
00FD15E4                          2231  
00FD15E4  5306                    2232              SUBQ.B  #1,D6
00FD15E6  66D8                    2233              BNE     WaitInit
00FD15E8  6100 FE98               2234              BSR     SHOWerrors              ;Ret with NZ flag set if error (probably no drive)
00FD15EC  4E75                    2235              RTS
00FD15EE                          2236  DoneInit:
00FD15EE  B341                    2237              EOR     D1,D1
00FD15F0  4E75                    2238              RTS
00FD15F2                          2239              
00FD15F2                          2240  DELAY_32: 
00FD15F2  123C 0028               2241              MOVE.B  #40,D1                  ;DELAY ~32 MS (DOES NOT SEEM TO BE CRITICAL)
00FD15F6  143C 0000               2242  DELAY3:     MOVE.B  #0,D2
00FD15FA  5302                    2243  M0:         SUBQ.B  #1,D2
00FD15FC  66FC                    2244              BNE     M0
00FD15FE  5301                    2245              SUBQ.B  #1,D1
00FD1600  66F4                    2246              BNE     DELAY3 
00FD1602  4E75                    2247              RTS
00FD1604                          2248              ;Read a sector, specified by the 4 bytes in LBA
00FD1604                          2249              ;Z on success, NZ BSR error routine if problem
00FD1604                          2250              ;Tell which sector we want to read from.
00FD1604                          2251  READSECTOR: ;Note: Translate first in case of an error otherewise we 
00FD1604  6100 0112               2252              BSR     WR_LBA                  ;will get stuck on bad sector 
00FD1608  6100 01C6               2253              BSR     IDEwaitnotbusy          ;make sure drive is ready
00FD160C  6C00 0006               2254              BGE     L_18                    
00FD1610  6000 FE70               2255              BRA     SHOWerrors              ;Returned with NZ set if error
00FD1614                          2256  
00FD1614  183C 0001               2257  L_18:       MOVE.B  #$1,D4                  ;For CPM, one sector at a time
00FD1618  1A3C 000A               2258              MOVE.B  #REGseccnt,D5
00FD161C  6100 025A               2259              BSR     IDEwr8D                 ;Write to 8255 A Register
00FD1620  6100 01AE               2260              BSR     IDEwaitnotbusy          ;make sure drive is ready
00FD1624  6C00 0006               2261              BGE     L_19                    
00FD1628  6000 FE58               2262              BRA     SHOWerrors              ;Returned with NZ set if error
00FD162C                          2263              
00FD162C  183C 0020               2264  L_19:       MOVE.B  #COMMANDread,D4
00FD1630  1A3C 000F               2265              MOVE.B  #REGcommand,D5
00FD1634  6100 0242               2266              BSR     IDEwr8D                 ;Send sec read command to drive.
00FD1638  6100 01C0               2267              BSR     IDEwaitdrq              ;wait until it's got the data
00FD163C  6C00 0008               2268              BGE     L_20                    
00FD1640  4EF9 00FD1482           2269              JMP     SHOWerrors
00FD1646                          2270  
00FD1646  2479 00FD8500           2271  L_20:       MOVE.L  RAM_DMA,A2              ;Get Current DMA Address to A2
00FD164C  1C3C 0000               2272              MOVE.B  #0,D6                   ;Read 512 bytes to D6
00FD1650                          2273  
00FD1650                          2274  MoreRD16:
00FD1650  13FC 0008 00FF0032      2275              MOVE.B  #REGdata,IDEportC       ;REG regsiter address
00FD1658  0039 0040 00FF0032      2276              OR.B    #IDErdline,IDEportC     ;08H+40H, Pulse RD line
00FD1660                          2277              
00FD1660  14F9 00FF0030           2278              MOVE.B  IDEportA,(A2)+          ;Read the lower byte first 
00FD1666  14F9 00FF0031           2279              MOVE.B  IDEportB,(A2)+          ;Then the upper byte first 
00FD166C                          2280              
00FD166C  13FC 0008 00FF0032      2281              MOVE.B  #REGdata,IDEportC       ;Deassert RD line
00FD1674  5306                    2282              SUBQ.B  #$1,D6
00FD1676  66D8                    2283              BNE     MoreRD16
00FD1678                          2284              
00FD1678  1A3C 000F               2285              MOVE.B  #REGstatus,D5
00FD167C  6100 01D6               2286              BSR     IDErd8D
00FD1680  1204                    2287              MOVE.B  D4,D1
00FD1682  C23C 0001               2288              AND.B   #$1,D1
00FD1686  6700 0006               2289              BEQ     L_21                    
00FD168A  6100 FDF6               2290              BSR     SHOWerrors              ;If error display status
00FD168E  4E75                    2291  L_21:       RTS
00FD1690                          2292  
00FD1690                          2293  
00FD1690                          2294              ;Write a sector, specified by the 3 bytes in LBA (_ IX+0)",
00FD1690                          2295              ;Z on success, NZ to error routine if problem
00FD1690                          2296              ;Tell which sector we want to read from.
00FD1690                          2297  WRITESECTOR:;Note: Translate first in case of an error otherewise we 
00FD1690  6100 0086               2298              BSR     WR_LBA                  ;will get stuck on bad sector 
00FD1694  6100 013A               2299              BSR     IDEwaitnotbusy          ;make sure drive is ready
00FD1698  6C00 0008               2300              BGE     L_22                    
00FD169C  4EF9 00FD1482           2301              JMP     SHOWerrors
00FD16A2                          2302              
00FD16A2  183C 0030               2303  L_22:       MOVE.B  #COMMANDwrite,D4
00FD16A6  1A3C 000F               2304              MOVE.B  #REGcommand,D5
00FD16AA  6100 01CC               2305              BSR     IDEwr8D                 ;Tell drive to write a sector
00FD16AE  6100 014A               2306              BSR     IDEwaitdrq              ;wait unit it wants the data
00FD16B2  6C00 0008               2307              BGE     L_23                    
00FD16B6  4EF9 00FD1482           2308              JMP     SHOWerrors
00FD16BC                          2309              
00FD16BC  2239 00FD8500           2310  L_23:       MOVE.L  RAM_DMA,D1
00FD16C2  2441                    2311              MOVE.L  D1,A2                   ;Get Current DMA Address
00FD16C4  1C3C 0000               2312              MOVE.B  #0,D6                   ;256X2 bytes
00FD16C8                          2313              
00FD16C8  13FC 0080 00FF0033      2314              MOVE.B  #WRITEcfg8255,IDECtrlPort
00FD16D0                          2315              
00FD16D0                          2316  WRSEC1_IDE:
00FD16D0  13DA 00FF0030           2317              MOVE.B  (A2)+,IDEportA
00FD16D6  13DA 00FF0031           2318              MOVE.B  (A2)+,IDEportB
00FD16DC                          2319  
00FD16DC  13FC 0008 00FF0032      2320              MOVE.B  #REGdata,IDEportC
00FD16E4  0039 0020 00FF0032      2321              OR.B    #IDEwrline,IDEportC     ;Send WR pulse
00FD16EC  13FC 0008 00FF0032      2322              MOVE.B  #REGdata,IDEportC
00FD16F4  5306                    2323              SUBQ.B  #$1,D6
00FD16F6  66D8                    2324              BNE     WRSEC1_IDE
00FD16F8                          2325              
00FD16F8  13FC 0092 00FF0033      2326              MOVE.B  #READcfg8255,IDECtrlPort  ;Set 8255 back to read mode
00FD1700                          2327              
00FD1700  1A3C 000F               2328              MOVE.B  #REGstatus,D5
00FD1704  6100 014E               2329              BSR     IDErd8D
00FD1708  1204                    2330              MOVE.B  D4,D1
00FD170A  C23C 0001               2331              AND.B   #$1,D1
00FD170E  6700 FF7E               2332              BEQ     L_21                    
00FD1712  6100 FD6E               2333              BSR     SHOWerrors              ;If error display status
00FD1716  4E75                    2334  L_24:       RTS
00FD1718                          2335  
00FD1718                          2336              
00FD1718                          2337              ;Write the logical block address to the drive's registers
00FD1718                          2338              ;Note we do not need to set the upper nibble of the LBA
00FD1718                          2339              ;It will always be 0 for these small CPM drives (so no High Cylinder
00FD1718                          2340  WR_LBA:     ;numbers etc).
00FD1718  1839 00FD850C           2341              MOVE.B  (RAM_SEC),D4            ;LBA mode, Low sectors go directly 
00FD171E                          2342  ;           ADDQ.B  #$1,D4                  ;Sectors are numbered 1 -- MAXSEC (even in LBA mode)
00FD171E  13C4 00FD850A           2343              MOVE.B  D4,(DISPLAY_SEC)        ;For Diagnostic Diaplay Only
00FD1724  1A3C 000B               2344              MOVE.B  #REGsector,D5           ;Send info to drive
00FD1728  6100 014E               2345              BSR     IDEwr8D                 ;Write to 8255 A Register
00FD172C                          2346              ;Note: For drive we will have 0 - MAXSEC sectors only
00FD172C                          2347              
00FD172C  1839 00FD850D           2348              MOVE.B  (RAM_TRK),D4
00FD1732  13C4 00FD8508           2349              MOVE.B  D4,(DISPLAY_TRK)        ;Send Low TRK#
00FD1738  1A3C 000C               2350              MOVE.B  #REGcylinderLSB,D5
00FD173C  6100 013A               2351              BSR     IDEwr8D                 ;Write to 8255 A Register
00FD1740                          2352              
00FD1740  1839 00FD850E           2353              MOVE.B  (RAM_TRK+1),D4
00FD1746  13C4 00FD8509           2354              MOVE.B  D4,(DISPLAY_TRK+1)
00FD174C  1A3C 000D               2355              MOVE.B  #REGcylinderMSB,D5      ;Send High TRK#
00FD1750  6100 0126               2356              BSR     IDEwr8D                 ;Send High TRK# (in DH) to IDE Drive
00FD1754  6100 0156               2357              BSR     IDEwr8D_X               ;Special write to 8255 B Register (Not A) to update LED HEX Display 
00FD1758                          2358              ;High 8 bits ignored by IDE drive
00FD1758                          2359              
00FD1758  183C 0001               2360              MOVE.B  #$1,D4                  ;For CPM, one sector at a time
00FD175C  1A3C 000A               2361              MOVE.B  #REGseccnt,D5
00FD1760  6100 0116               2362              BSR     IDEwr8D                 ;Write to 8255 A Register
00FD1764  4E75                    2363              RTS
00FD1766                          2364              
00FD1766                          2365              ;Special version for MS-DOS system BIOS (see IBM BIOS Section)
00FD1766                          2366              ;This will display Head, Cylinder and Sector on the LED HEX display
00FD1766                          2367  DOS_WR_LBA: ;instead of LBA sector numbers.
00FD1766  1839 00FD850F           2368              MOVE.B  CURRENT_HEAD,D4         ;OR in head info to lower 4 bits
00FD176C  C83C 000F               2369              AND.B   #$0F,D4                 ;Just in case
00FD1770  883C 00A0               2370              OR.B    #%10100000,D4           ;Set to >>>>> NON-LBA mode <<<<<
00FD1774  1A3C 000E               2371              MOVE.B  #REGshd,D5              ;Send "Head #" (in DH) to IDE drive
00FD1778  6100 00FE               2372              BSR     IDEwr8D                 
00FD177C                          2373  
00FD177C  1839 00FD8510           2374              MOVE.B  CURRENT_TRACK_HIGH,D4   ;Send High TRK#
00FD1782  1A3C 000D               2375              MOVE.B  #REGcylinderMSB,D5
00FD1786  6100 00F0               2376              BSR     IDEwr8D                 ;Send High TRK# (in DH) to IDE Drive
00FD178A                          2377  
00FD178A  1839 00FD850F           2378              MOVE.B  CURRENT_HEAD,D4         ;Get head info to lower 8 bits of the special
00FD1790  C83C 000F               2379              AND.B   #$0F,D4                 ;top two LED HEX displays.
00FD1794  E94C                    2380              LSL     #4,D4                   ;These 8 (high) data lines are ignored by the IDE drive
00FD1796  8839 00FD8510           2381              OR.B    CURRENT_TRACK_HIGH,D4       ;Will display  the Head in top nibble and the two bits of the HIGH bits 
00FD179C  1A3C 000D               2382              MOVE.B  #REGcylinderMSB,D5      ;of the high cylinder in the low nibble.
00FD17A0  6100 010A               2383              BSR     IDEwr8D_X               ;Special output to 8255 B Register (Not A) to update LED HEX Display ONLY
00FD17A4                          2384              
00FD17A4  1839 00FD8511           2385              MOVE.B  CURRENT_TRACK,D4        ;Get low Track # 
00FD17AA  1A3C 000C               2386              MOVE.B  #REGcylinderLSB,D5      ;Send Low TRK# (in DH)
00FD17AE  6100 00C8               2387              BSR     IDEwr8D                 ;Special write to 8255 B Register (Not A) 
00FD17B2                          2388              
00FD17B2  1839 00FD8512           2389              MOVE.B  CURRENT_SECTOR,D4       ;Bits 0-5 only  (currently 1-17)
00FD17B8  1A3C 000B               2390              MOVE.B  #REGsector,D5           ;Send "Sector#" 
00FD17BC  6100 00BA               2391              BSR     IDEwr8D                 ;Write to 8255 A Register
00FD17C0                          2392  
00FD17C0  1839 00FD8513           2393              MOVE.B  SECTORS_TO_DO,D4        ;# of CONTIGOUS sectors to send
00FD17C6  1A3C 000A               2394              MOVE.B  #REGseccnt,D5
00FD17CA  6100 00AC               2395              BSR     IDEwr8D                 ;Write to 8255 A Register
00FD17CE  4E75                    2396              RTS
00FD17D0                          2397  
00FD17D0                          2398  
00FD17D0                          2399  
00FD17D0                          2400  IDEwaitnotbusy:     ;Drive READY if 01000000
00FD17D0  3C3C FFFF               2401              MOVE.W  #$0FFFF,D6
00FD17D4                          2402  MoreWait:
00FD17D4  1A3C 000F               2403              MOVE.B  #REGstatus,D5           ;wait for RDY bit to be set
00FD17D8  6100 007A               2404              BSR     IDErd8D                 ;Note AH or CH are unchanged
00FD17DC  1204                    2405              MOVE.B  D4,D1
00FD17DE  C23C 00C0               2406              AND.B   #%11000000,D1
00FD17E2  0A01 0040               2407              EOR.B   #%01000000,D1
00FD17E6  6700 000E               2408              BEQ     DONE_NOT_BUSY
00FD17EA  5346                    2409              SUBQ.W  #1,D6
00FD17EC  66E6                    2410              BNE     MoreWait
00FD17EE  103C 00FF               2411              MOVE.B  #$FF,D0                 
00FD17F2  E308                    2412              LSL.B   #1,D0                   ;Set carry to indicate an error
00FD17F4  4E75                    2413              RTS
00FD17F6                          2414  DONE_NOT_BUSY:
00FD17F6  4201                    2415              CLR.B   D1                      ;Clear carry it indicate no error
00FD17F8  4E75                    2416              RTS
00FD17FA                          2417              
00FD17FA                          2418              ;Wait for the drive to be ready to transfer data.
00FD17FA                          2419  IDEwaitdrq: ;Returns the drive's status in Acc
00FD17FA  3C3C FFFF               2420              MOVE.W  #$0FFFF,D6
00FD17FE                          2421  MoreDRQ:
00FD17FE  1A3C 000F               2422              MOVE.B  #REGstatus,D5           ;wait for DRQ bit to be set
00FD1802  6100 0050               2423              BSR     IDErd8D                 ;Note AH or CH are unchanged
00FD1806  1204                    2424              MOVE.B  D4,D1
00FD1808  C23C 0088               2425              AND.B   #%10001000,D1
00FD180C  B23C 0008               2426              CMP.B   #%00001000,D1
00FD1810  6700 000E               2427              BEQ     DoneDRQ
00FD1814  5346                    2428              SUBQ.W  #1,D6
00FD1816  66E6                    2429              BNE     MoreDRQ
00FD1818  103C 00FF               2430              MOVE.B  #$FF,D0                 
00FD181C  E308                    2431              LSL.B   #1,D0                   ;Set carry to indicate an error
00FD181E  4E75                    2432              RTS
00FD1820                          2433  DoneDRQ:
00FD1820  4201                    2434              CLR.B   D1                      ;Clear carry it indicate no error
00FD1822  4E75                    2435              RTS
00FD1824                          2436  
00FD1824                          2437  
00FD1824                          2438  CLEAR_ID_BUFFER:    ;Clear the ID Buffer area
00FD1824  323C 0000               2439              MOVE.W  #$0000,D1               ;Clear to 0
00FD1828  45F9 00FD8100           2440              LEA     IDE_Buffer,A2           
00FD182E  143C 0007               2441              MOVE.B  #7,D2                   ;14 bytes total
00FD1832  34C1                    2442  CLEAR3:     MOVE.W  D1,(A2)+
00FD1834  5302                    2443              SUBQ.B  #1,D2
00FD1836  66FA                    2444              BNE     CLEAR3
00FD1838  4E75                    2445              RTS
00FD183A                          2446  
00FD183A                          2447  
00FD183A  B23C 000D               2448  IDE_ERR:    CMP.B   #CR,D1                  ;If CR just return
00FD183E  6700 F11A               2449              BEQ     IDE_LOOP
00FD1842  45F9 00FD27BD           2450              LEA     BadIDECmdMsg,A2         ;Non menu selection
00FD1848  6100 0558               2451              BSR     PRINT_STRING
00FD184C  6100 0564               2452              BSR     CRLF
00FD1850  6000 F108               2453              BRA     IDE_LOOP                ;Back to start for next command
00FD1854                          2454              
00FD1854                          2455  
00FD1854                          2456  ;------------------------------------------------------------------
00FD1854                          2457  ; Low Level 8 bit R/W to the drive controller.  These are the routines that talk
00FD1854                          2458  ; directly to the drive controller registers, via the 8255 chip.  
00FD1854                          2459  ; Note the 16 bit Sector I/O to the drive is done directly 
00FD1854                          2460  ; in the routines READSECTOR & WRITESECTOR for speed reasons.
00FD1854                          2461  
00FD1854                          2462  IDErd8D:    ;READ 8 bits from IDE register @ [DL], return info in [DH]
00FD1854  13C5 00FF0032           2463              MOVE.B  D5,IDEportC             ;Select IDE register, drive address onto control lines
00FD185A                          2464              
00FD185A  0039 0040 00FF0032      2465              OR.B    #IDErdline,IDEportC     ;RD pulse pin (40H), Assert read pin
00FD1862                          2466  
00FD1862  1839 00FF0030           2467              MOVE.B  IDEportA,D4             ;Return with data in [D4]
00FD1868                          2468              
00FD1868  13C5 00FF0032           2469              MOVE.B  D5,IDEportC             ;Select IDE register, drive address onto control lines
00FD186E                          2470  
00FD186E  13FC 0000 00FF0032      2471              MOVE.B  #0,IDEportC             ;Zero all port C lines
00FD1876  4E75                    2472              RTS
00FD1878                          2473  
00FD1878                          2474  
00FD1878                          2475  IDEwr8D:    ;WRITE Data in [DH] to IDE register @ [DL]
00FD1878  13FC 0080 00FF0033      2476              MOVE.B  #WRITEcfg8255,IDECtrlPort;Set 8255 to write mode
00FD1880                          2477              
00FD1880  13C4 00FF0030           2478              MOVE.B  D4,IDEportA             ;Get data put it in 8255 A port
00FD1886                          2479              
00FD1886  13C5 00FF0032           2480              MOVE.B  D5,IDEportC             ;Select IDE register, drive address onto control lines
00FD188C                          2481              
00FD188C  0039 0020 00FF0032      2482              OR.B    #IDEwrline,IDEportC     ;Assert write pin
00FD1894                          2483              
00FD1894  13C5 00FF0032           2484              MOVE.B  D5,IDEportC             ;Select IDE register, drive address onto control lines
00FD189A                          2485  
00FD189A  13FC 0000 00FF0032      2486              MOVE.B  #0,IDEportC             ;Zero all port C lines
00FD18A2                          2487              
00FD18A2  13FC 0092 00FF0033      2488              MOVE.B  #READcfg8255,IDECtrlPort;Config 8255 chip, read mode on return
00FD18AA  4E75                    2489              RTS
00FD18AC                          2490  
00FD18AC                          2491  
00FD18AC                          2492  IDEwr8D_X:  ;WRITE Data in [DH] to IDE register @ [DL]
00FD18AC  13FC 0080 00FF0033      2493              MOVE.B  #WRITEcfg8255,IDECtrlPort;Set 8255 to write mode
00FD18B4                          2494              
00FD18B4  13C4 00FF0031           2495              MOVE.B  D4,IDEportB             ;Get data and put it in 8255 >>>> Port B <<<< 
00FD18BA                          2496              
00FD18BA  13C5 00FF0032           2497              MOVE.B  D5,IDEportC             ;Select IDE register, drive address onto control lines
00FD18C0                          2498              
00FD18C0  0039 0020 00FF0032      2499              OR.B    #IDEwrline,IDEportC     ;Assert write pin
00FD18C8                          2500              
00FD18C8  13C5 00FF0032           2501              MOVE.B  D5,IDEportC             ;Select IDE register, drive address onto control lines
00FD18CE                          2502  
00FD18CE  13FC 0000 00FF0032      2503              MOVE.B  #0,IDEportC             ;Zero all port C lines
00FD18D6                          2504              
00FD18D6  13FC 0092 00FF0033      2505              MOVE.B  #READcfg8255,IDECtrlPort;Config 8255 chip, read mode on return
00FD18DE  4E75                    2506              RTS
00FD18E0                          2507  
00FD18E0                          2508  
00FD18E0                          2509  
00FD18E0                          2510  ;----------------------- Routine to download from a PC via XMODEM a .bin file ----------------------------------------
00FD18E0                          2511              
00FD18E0                          2512  XMODEM_BIN: ;Download an XModem .bin file.  Note some registers changed (not A0 and A1)
00FD18E0  45F9 00FD2D04           2513              LEA     MODEM_BIN_SIGNON,A2     ;Will show message explaining we are about to upload a .bin file
00FD18E6  6100 04BA               2514              BSR     PRINT_STRING
00FD18EA                          2515  
00FD18EA  13FC 0000 00FD8514      2516              MOVE.B  #0,(RECVD_SECT_NO)
00FD18F2  13FC 0000 00FD8515      2517              MOVE.B  #0,(SECTNO)
00FD18FA  13FC 0000 00FD8516      2518              MOVE.B  #0,(ERRCT)
00FD1902                          2519              
00FD1902  6100 059C               2520              BSR     SERIAL_INITILIZE_A      ;RESET THE ZILOG SCC
00FD1906                          2521              
00FD1906  45F9 00FD2D66           2522              LEA     RAM_DESTINATION_MSG,A2  ;Ask for destination
00FD190C  6100 0494               2523              BSR     PRINT_STRING
00FD1910  6100 0234               2524              BSR     GETLONG_D7              ;Get start address
00FD1914  B43C 000D               2525              CMP.B   #CR,D2                  ;Is it valid - must end with CR
00FD1918  6600 04D4               2526              BNE     ERROR                   ;From there BRA to LOOP
00FD191C  2647                    2527              MOVE.L  D7,A3                   ;<<< Save RAM address in A3
00FD191E  6100 0492               2528              BSR     CRLF
00FD1922                          2529  
00FD1922  2438 1F40               2530              MOVE.L  SERIAL_RETRYS,D2        ;Number of times to try reading serial port before aborting.
00FD1926  6100 041A               2531              BSR     RECV
00FD192A                          2532  
00FD192A  45F9 00FD2F0F           2533              LEA     START_B_POINTER_MSG,A2  ;"Will load .bin file data starting at RAM location "
00FD1930  6100 0470               2534              BSR     PRINT_STRING
00FD1934  2E0B                    2535              MOVE.L  A3,D7
00FD1936  6100 02BE               2536              BSR     PUTLONG_D7              ;Show current address
00FD193A  6100 0476               2537              BSR     CRLF
00FD193E                          2538              
00FD193E  45F9 00FD2D9D           2539              LEA     DOWNLOAD_MSG,A2         ;Speak "Downloading file"
00FD1944  6100 0510               2540              BSR     SPEAK_STRING
00FD1948                          2541  
00FD1948                          2542  RECV_LOOP:  ;<<< MAIN RECIEVE LOOP >>>>
00FD1948  4202                    2543              CLR.B   D2                      ;GET 0
00FD194A  13C2 00FD8516           2544              MOVE.B  D2,(ERRCT)              ;Start error count with 0
00FD1950                          2545  RECV_HDR:
00FD1950  45F9 00FD2DB7           2546              LEA     RMSG,A2                 ;Reading sector message
00FD1956  6100 044A               2547              BSR     PRINT_STRING
00FD195A  1C39 00FD8515           2548              MOVE.B  (SECTNO),D6             ;Show current sector number
00FD1960  5206                    2549              ADD.B   #1,D6
00FD1962  6100 02D4               2550              BSR     PUTBYTE_D6
00FD1966  45F9 00FD2E78           2551              LEA     RAM_MSG,A2              ;"H.  IF OK, will write to RAM location"
00FD196C  6100 0434               2552              BSR     PRINT_STRING
00FD1970  2E0B                    2553              MOVE.L  A3,D7
00FD1972  6100 0282               2554              BSR     PUTLONG_D7              ;Show current address
00FD1976  45F9 00FD2F6E           2555              LEA     H_MSG,A2
00FD197C  6100 0424               2556              BSR     PRINT_STRING
00FD1980                          2557  
00FD1980  243C 00027100           2558              MOVE.L  #20*SERIAL_RETRYS,D2    ;Number of times to try reading serial port before aborting.
00FD1986  6100 03BA               2559              BSR     RECV                    ;Get character from modem serial port
00FD198A  B43C 00FF               2560              CMP.B   #$FF,D2                 ;Return with FF in D2 if all is OK
00FD198E  6700 005E               2561              BEQ     RHNTO                   ;WE ARE OK, NO TIMEOUT
00FD1992                          2562  
00FD1992                          2563  RECV_HDR_TIMEOUT:
00FD1992  45F9 00FD2E1B           2564              LEA     TOUTM,A2                ;PRINT TIMEOUT MESSAGE
00FD1998  6100 0408               2565              BSR     PRINT_STRING
00FD199C  1C39 00FD8516           2566              MOVE.B  (ERRCT),D6              ;Show error count as well
00FD19A2  6100 0294               2567              BSR     PUTBYTE_D6
00FD19A6  6100 040A               2568              BSR     CRLF
00FD19AA                          2569  
00FD19AA                          2570  RECV_SECT_ERR:      ;PURGE THE LINE OF INPUT CHARS
00FD19AA  243C 00001F40           2571              MOVE.L  #SERIAL_RETRYS,D2       ;Number of times to try reading serial port before aborting.
00FD19B0  6100 0390               2572              BSR     RECV
00FD19B4  4A02                    2573              TST.B   D2
00FD19B6  66F2                    2574              BNE     RECV_SECT_ERR           ;LOOP UNTIL SENDER DONE
00FD19B8                          2575              
00FD19B8  123C 0015               2576              MOVE.B  #NAK,D1
00FD19BC  6100 034C               2577              BSR     SERIAL_OUT              ;SEND NAK
00FD19C0                          2578              
00FD19C0  1C39 00FD8516           2579              MOVE.B  (ERRCT),D6              ;Inc Error Count (ERRCT)
00FD19C6  5206                    2580              ADD.B   #1,D6
00FD19C8  13C6 00FD8516           2581              MOVE.B  D6,(ERRCT)
00FD19CE  BC3C 0008               2582              CMP.B   #MODEM_ERR_LIMIT,D6     ;Currently set for 5 trys
00FD19D2  6F00 FF7C               2583              BLE     RECV_HDR                ;Go try again
00FD19D6                          2584              
00FD19D6  6100 011E               2585              BSR     CHECK_FOR_QUIT
00FD19DA  4A01                    2586              TST.B   D1
00FD19DC  6700 FF72               2587              BEQ     RECV_HDR                ;Try again
00FD19E0  45F9 00FD2EE8           2588              LEA     BAD_HEADER,A2           ;'Unable to get a valid file header!'
00FD19E6  6100 03BA               2589              BSR     PRINT_STRING
00FD19EA  6000 00FA               2590              BRA     MODEM_DONE              ;Abort back to Monitor start
00FD19EE                          2591  
00FD19EE  B23C 0001               2592  RHNTO:      CMP.B   #SOH,D1                 ;GOT CHAR - MUST BE SOH
00FD19F2  6700 002A               2593              BEQ     GOT_SOH
00FD19F6  8201                    2594              OR.B    D1,D1                   ;00 FROM SPEED CHECK?
00FD19F8  6600 0006               2595              BNE     L_2                     
00FD19FC  6000 FF52               2596              BRA     RECV_HDR
00FD1A00  B23C 0004               2597  L_2:        CMP.B   #EOT,D1
00FD1A04  6600 0006               2598              BNE     L_3                     
00FD1A08  6000 00BC               2599              BRA     GOT_EOT
00FD1A0C  1C01                    2600  L_3:        MOVE.B  D1,D6
00FD1A0E  6100 0228               2601              BSR     PUTBYTE_D6
00FD1A12  45F9 00FD2DCE           2602              LEA     ERRSOH,A2               ;'H Received',CR,LF,'Did not get Correct SOH'
00FD1A18  6100 0388               2603              BSR     PRINT_STRING
00FD1A1C  608C                    2604              BRA     RECV_SECT_ERR
00FD1A1E                          2605  
00FD1A1E                          2606  GOT_SOH:    ;We got correct SOH so now get data
00FD1A1E  243C 00001F40           2607              MOVE.L  #SERIAL_RETRYS,D2       ;Number of times to try reading serial port before aborting.
00FD1A24  6100 031C               2608              BSR     RECV
00FD1A28  B43C 00FF               2609              CMP.B   #$FF,D2                 ;Return with FF in D2 if all is OK
00FD1A2C  6600 FF64               2610              BNE     RECV_HDR_TIMEOUT
00FD1A30                          2611  
00FD1A30  1A01                    2612              MOVE.B  D1,D5                   ;D5=BLOCK #
00FD1A32  243C 00001F40           2613              MOVE.L  #SERIAL_RETRYS,D2      ;Number of times to try reading serial port before aborting. 
00FD1A38  6100 0308               2614              BSR     RECV
00FD1A3C  B43C 00FF               2615              CMP.B   #$FF,D2                 ;GET CMA'D SECT #
00FD1A40  6600 FF50               2616              BNE     RECV_HDR_TIMEOUT
00FD1A44  4601                    2617              NOT.B   D1
00FD1A46                          2618  
00FD1A46  BA01                    2619              CMP.B   D1,D5                   ;GOOD SECTOR #?
00FD1A48  6700 0010               2620              BEQ     RECV_SECTOR
00FD1A4C                          2621              ;GOT BAD SECTOR #
00FD1A4C  45F9 00FD2DE4           2622              LEA     MODEM_ERR2,A2           ;'++BAD SECTOR # IN HDR'
00FD1A52  6100 034E               2623              BSR     PRINT_STRING
00FD1A56  6000 FF52               2624              BRA     RECV_SECT_ERR
00FD1A5A                          2625  
00FD1A5A                          2626  RECV_SECTOR:;Now get 128 Bytes
00FD1A5A  13C5 00FD8514           2627              MOVE.B  D5,(RECVD_SECT_NO)      ;GET SECTOR #
00FD1A60  4204                    2628              CLR.B   D4                      ;INIT CKSUM = 0
00FD1A62  163C 0080               2629              MOVE.B  #$80,D3                 ;128 Byte sectors always
00FD1A66                          2630  
00FD1A66                          2631  RECV_CHAR:
00FD1A66  243C 00027100           2632              MOVE.L  #20*SERIAL_RETRYS,D2    ;Number of times to try reading serial port before aborting.
00FD1A6C  6100 02D4               2633              BSR     RECV                    ;GET CHAR
00FD1A70  B43C 00FF               2634              CMP.B   #$FF,D2                 ;GET CMA'D SECT #
00FD1A74  6600 FF1C               2635              BNE     RECV_HDR_TIMEOUT
00FD1A78  16C1                    2636              MOVE.B  D1,(A3)+                ;<<< STORE CHAR >>>
00FD1A7A  D801                    2637              ADD.B   D1,D4                   ;Add in checksum
00FD1A7C  5303                    2638              SUB.B   #1,D3                   ;128 Bytes done yet?
00FD1A7E  66E6                    2639              BNE     RECV_CHAR
00FD1A80                          2640              
00FD1A80                          2641              ;NEXT VERIFY CHECKSUM
00FD1A80  243C 00001F40           2642              MOVE.L  #SERIAL_RETRYS,D2       ;Number of times to try reading serial port before aborting.
00FD1A86  6100 02BA               2643              BSR     RECV                    ;GET CHECKSUM
00FD1A8A  B43C 00FF               2644              CMP.B   #$FF,D2                 ;Return with FF in D2 if all is OK
00FD1A8E  6600 FF02               2645              BNE     RECV_HDR_TIMEOUT
00FD1A92                          2646  MODL_5:
00FD1A92  B801                    2647              CMP.B   D1,D4                   ;CHECK IF CHECKSUM IS CORRECT
00FD1A94  6600 0022               2648              BNE     RECV_CKSUM_ERR
00FD1A98  1439 00FD8514           2649              MOVE.B  (RECVD_SECT_NO),D2      ;GOT A SECTOR, WRITE IF = 1+PREV SECTOR
00FD1A9E  5205                    2650              ADD.B   #1,D5                   ;CALC NEXT SECTOR #
00FD1AA0  B405                    2651              CMP.B   D5,D2                   ;MATCH?
00FD1AA2  6600 0008               2652              BNE     DO_ACK
00FD1AA6                          2653  
00FD1AA6  13C5 00FD8515           2654              MOVE.B  D5,(SECTNO)             ;UPDATE SECTOR #
00FD1AAC  123C 0006               2655  DO_ACK:     MOVE.B  #ACK,D1
00FD1AB0  6100 0258               2656              BSR     SERIAL_OUT
00FD1AB4  6000 FE92               2657              BRA     RECV_LOOP
00FD1AB8                          2658              
00FD1AB8                          2659              
00FD1AB8                          2660  RECV_CKSUM_ERR:
00FD1AB8  45F9 00FD2DFF           2661              LEA     MODEM_ERR3,A2
00FD1ABE  6100 02E2               2662              BSR     PRINT_STRING
00FD1AC2  6000 FEE6               2663              BRA     RECV_SECT_ERR
00FD1AC6                          2664  
00FD1AC6                          2665  GOT_EOT:    ;DONE - CLOSE UP SHOP
00FD1AC6  123C 0006               2666              MOVE.B  #ACK,d1                 ;ACK THE EOT
00FD1ACA  6100 023E               2667              BSR     SERIAL_OUT
00FD1ACE  6100 02E2               2668              BSR     CRLF
00FD1AD2  45F9 00FD2E9E           2669              LEA     FINISH_MSG,A2           ;Speak downloading finished
00FD1AD8  6100 037C               2670              BSR     SPEAK_STRING
00FD1ADC  45F9 00FD2EC8           2671              LEA     TRANS_DONE,A2
00FD1AE2  6100 02BE               2672  EXIT2:      BSR     PRINT_STRING
00FD1AE6                          2673  MODEM_DONE: 
00FD1AE6  6000 E574               2674              BRA     LOOP
00FD1AEA                          2675     
00FD1AEA  45F9 00FD2F44           2676  EXIT1:      LEA     ABORT_MSG,A2
00FD1AF0  4EF9 00FD1AE2           2677              JMP     EXIT2
00FD1AF6                          2678  
00FD1AF6                          2679  
00FD1AF6                          2680  CHECK_FOR_QUIT:     ;MULTIPLE ERRORS, ASK IF TIME TO QUIT
00FD1AF6  13FC 0000 00FD8516      2681              MOVE.B  #0,(ERRCT)              ;RESET ERROR COUNT
00FD1AFE  45F9 00FD2E35           2682              LEA     QUITM,A2
00FD1B04  6100 029C               2683              BSR     PRINT_STRING
00FD1B08  6100 01C2               2684              BSR     GETCHAR
00FD1B0C  2F01                    2685              MOVE.L  D1,-(A7)
00FD1B0E  6100 02A2               2686              BSR     CRLF
00FD1B12  221F                    2687              MOVE.L  (A7)+,D1                ;Is D1 = 'R'
00FD1B14  B23C 0052               2688              CMP.B   #'R',D1
00FD1B18  6700 002A               2689              BEQ     DONE_CHECK
00FD1B1C  B23C 0072               2690              CMP.B   #'r',D1
00FD1B20  6700 0022               2691              BEQ     DONE_CHECK
00FD1B24  B23C 0051               2692              CMP.B   #'Q',D1
00FD1B28  6700 0018               2693              BEQ     NOT_DONE_CHECK
00FD1B2C  B23C 0071               2694              CMP.B   #'q',D1
00FD1B30  6700 0010               2695              BEQ     NOT_DONE_CHECK
00FD1B34  B23C 001B               2696              CMP.B   #ESC,D1
00FD1B38  6700 0008               2697              BEQ     NOT_DONE_CHECK
00FD1B3C  4EF9 00FD1AF6           2698              JMP     CHECK_FOR_QUIT
00FD1B42                          2699  NOT_DONE_CHECK:
00FD1B42  8201                    2700              OR.B    D1,D1                   ;TURN OFF ZERO FLAG
00FD1B44  4E75                    2701  DONE_CHECK: RTS
00FD1B46                          2702              
00FD1B46                          2703  
00FD1B46                          2704              
00FD1B46                          2705  ;======================== SUPPORT ROUTINES ========================================================
00FD1B46                          2706  
00FD1B46  4287                    2707  GETLONG_D7: CLR.L   D7                      ;Get a long number and place in D7 (1-8 bytes)
00FD1B48  4203                    2708              CLR.B   D3                      ;Byte count
00FD1B4A  6100 004E               2709  GETLONG1:   BSR     GETNIBBLE               ;Get a Hex byte in D1
00FD1B4E  B43C 001B               2710              CMP.B   #ESC,D2
00FD1B52  6700 0022               2711              BEQ     ABORT_LONG
00FD1B56  B43C 000D               2712              CMP.B   #CR,D2                  ;Loop until GETNIBBLE returns $FF = CR or ','
00FD1B5A  6700 0030               2713              BEQ     DONE_LONG
00FD1B5E  B43C 002C               2714              CMP.B   #',',D2                 ;Loop until GETNIBBLE returns $FF = CR or ','
00FD1B62  6700 0028               2715              BEQ     DONE_LONG
00FD1B66  B43C 0020               2716              CMP.B   #BLANK,D2               ;Loop until GETNIBBLE returns $FF = CR or ','
00FD1B6A  6700 0020               2717              BEQ     DONE_LONG
00FD1B6E  E98F                    2718              LSL.L   #4,D7
00FD1B70  8E01                    2719              OR.B    D1,D7
00FD1B72  5203                    2720              ADDQ.B  #1,D3
00FD1B74  60D4                    2721              BRA     GETLONG1
00FD1B76                          2722              
00FD1B76  7E00                    2723  ABORT_LONG: MOVE.L  #0,D7                   ;Return 0, (D1 contains ESC)
00FD1B78  2F01                    2724              MOVE.L  D1,-(A7)
00FD1B7A  123C 000D               2725              MOVE.B  #CR,D1                  ;Send out a CR/LF before returning
00FD1B7E  6100 011A               2726              BSR     PUTCHAR
00FD1B82  123C 000A               2727              MOVE.B  #LF,D1                  
00FD1B86  6100 0112               2728              BSR     PUTCHAR
00FD1B8A  221F                    2729              MOVE.L  (A7)+,D1
00FD1B8C  4E75                    2730  DONE_LONG:  RTS     ;Normal return with FFh in D1 if CR or ',' was entered. D1 = FEh if a space was entered
00FD1B8E                          2731  
00FD1B8E                          2732  
00FD1B8E  4287                    2733  GETBYTE_D7: CLR.L   D7                      ;Get a Byte number and place in D7 (1-2 bytes)
00FD1B90  61B4                    2734              BSR     GETLONG_D7
00FD1B92  CEBC 000000FF           2735              AND.L   #$ff,D7                 ;Return with just a Byte (D2 will normally be 2)
00FD1B98  4E75                    2736              RTS
00FD1B9A                          2737              
00FD1B9A                          2738  
00FD1B9A  4202                    2739  GETNIBBLE:  CLR.B   D2                      ;clear D2 flag byte
00FD1B9C  4201                    2740              CLR.B   D1                      ;just in case
00FD1B9E  6100 012C               2741              BSR     GETCHAR                 ;Get a HEX character (0,1,2,3...A,B,C,D,E,F in D1)
00FD1BA2  B23C 001B               2742              CMP.B   #ESC,D1                 ;Was an abort requested
00FD1BA6  6700 0034               2743              BEQ     NIBBLE1
00FD1BAA                          2744  
00FD1BAA  B23C 000D               2745              CMP.B   #CR,D1                  ;CR terminates data entry
00FD1BAE  6700 002C               2746              BEQ     NIBBLE1
00FD1BB2  B23C 002C               2747              CMP.B   #',',D1                 ;',' also terminates data entry
00FD1BB6  6700 0024               2748              BEQ     NIBBLE1
00FD1BBA  B23C 0020               2749              CMP.B   #BLANK,D1               ;A BLANK also terminates data entry
00FD1BBE  6700 001C               2750              BEQ     NIBBLE1
00FD1BC2                          2751              
00FD1BC2  6100 0214               2752              BSR     TOUPPER                 ;(D1)Lower case to Upper case 
00FD1BC6                          2753     
00FD1BC6  0401 0030               2754              SUB.B   #$30,D1                 ;SEE IF LESS THAN ZERO
00FD1BCA  6D14                    2755              BLT.S   NIBBLE2
00FD1BCC                          2756  
00FD1BCC  B23C 0009               2757              CMP.B   #$09,D1                 ;SEE IF GT 9
00FD1BD0  6F0A                    2758              BLE.S   NIBBLE1
00FD1BD2  5F01                    2759              SUBQ.B  #7,D1                   ;NORMALIZE $A TO 10
00FD1BD4  B23C 0010               2760              CMP.B   #$10,D1                 ;SEE IF TOO LARGE
00FD1BD8  6406                    2761              BCC.S   NIBBLE2
00FD1BDA  4E75                    2762              RTS     ;Return with nibble in D1 (0,1,2,3...F)
00FD1BDC                          2763              
00FD1BDC  1401                    2764  NIBBLE1:    MOVE.B  D1,D2                   ;Store ESC/CR/,/BLANK in D2
00FD1BDE  4E75                    2765              RTS     
00FD1BE0                          2766              
00FD1BE0  123C 0007               2767  NIBBLE2:    MOVE.B  #BELL,D1                ;Not a valid HEX character
00FD1BE4  6100 00B4               2768              BSR     PUTCHAR
00FD1BE8  123C 003F               2769              MOVE.B  #'?',D1
00FD1BEC  6100 00AC               2770              BSR     PUTCHAR
00FD1BF0  143C 001B               2771              MOVE.B  #ESC,D2
00FD1BF4  4E75                    2772              RTS
00FD1BF6                          2773  
00FD1BF6                          2774  
00FD1BF6                          2775  
00FD1BF6                          2776  
00FD1BF6                          2777              
00FD1BF6  2C07                    2778  PUTLONG_D7: MOVE.L  D7,D6                   ;Print long in D7 on CRT, Note D6 destroyed
00FD1BF8  4846                    2779              SWAP    D6                      ;Swap down upper word
00FD1BFA  6100 000A               2780              BSR     PUTWORD_D6
00FD1BFE  2C07                    2781              MOVE.L  D7,D6
00FD1C00  6100 0004               2782              BSR     PUTWORD_D6
00FD1C04  4E75                    2783              RTS
00FD1C06                          2784              
00FD1C06                          2785  
00FD1C06                          2786              
00FD1C06  3206                    2787  PUTWORD_D6: MOVE.W  D6,D1                   ;Note D1 is destroyed
00FD1C08  E049                    2788              LSR.W   #8,D1                   ;Shift upper byte to lower 8 bits
00FD1C0A  E849                    2789              LSR.W   #4,D1                   ;Shift upper byte to lower 4 bits
00FD1C0C  C23C 000F               2790              AND.B  #$0F,D1                  ;SAVE LOWER NIBBLE
00FD1C10  823C 0030               2791              OR.B   #$30,D1                  ;CONVERT TO ASCII
00FD1C14  B23C 0039               2792              CMP.B  #$39,D1                  ;SEE IF IT IS > 9
00FD1C18  6F02                    2793              BLE.S   HEXOK2
00FD1C1A  5E01                    2794              ADDQ.B   #7,D1                  ;ADD TO MAKE 10=>A
00FD1C1C  6100 007C               2795  HEXOK2:     BSR     PUTCHAR
00FD1C20                          2796              ;Address lower high byte nibble
00FD1C20  3206                    2797              MOVE.W  D6,D1                   ;Origional number again to D1
00FD1C22  E049                    2798              LSR.W   #8,D1                   ;Shift upper byte to lower 8 bits
00FD1C24  C23C 000F               2799              AND.B  #$0F,D1                  ;SAVE LOWER NIBBLE
00FD1C28  823C 0030               2800              OR.B   #$30,D1                  ;CONVERT TO ASCII
00FD1C2C  B23C 0039               2801              CMP.B  #$39,D1                  ;SEE IF IT IS>9
00FD1C30  6F02                    2802              BLE.S   HEXOK3
00FD1C32  5E01                    2803              ADDQ.B   #7,D1                  ;ADD TO MAKE 10=>A
00FD1C34  6100 0064               2804  HEXOK3:     BSR     PUTCHAR
00FD1C38                          2805              
00FD1C38                          2806  
00FD1C38                          2807  PUTBYTE_D6: ;Print HEX value in D6
00FD1C38  3206                    2808              MOVE.W  D6,D1                   ;Origional number again to D1
00FD1C3A  E849                    2809              LSR.W   #4,D1                   ;Shift upper byte to lower 4 bits
00FD1C3C  C23C 000F               2810              AND.B  #$0F,D1                  ;SAVE LOWER NIBBLE
00FD1C40  823C 0030               2811              OR.B   #$30,D1                  ;CONVERT TO ASCII
00FD1C44  B23C 0039               2812              CMP.B  #$39,D1                  ;SEE IF IT IS>9
00FD1C48  6F02                    2813              BLE.S   HEXOK4
00FD1C4A  5E01                    2814              ADDQ.B   #7,D1                  ;ADD TO MAKE 10=>A
00FD1C4C  6100 004C               2815  HEXOK4:     BSR     PUTCHAR
00FD1C50                          2816              ;Address lower high byte nibble
00FD1C50  3206                    2817              MOVE.W  D6,D1                   ;Origional number again to D1
00FD1C52  C23C 000F               2818              AND.B  #$0F,D1                  ;SAVE LOWER NIBBLE
00FD1C56  823C 0030               2819              OR.B   #$30,D1                  ;CONVERT TO ASCII
00FD1C5A  B23C 0039               2820              CMP.B  #$39,D1                  ;SEE IF IT IS>9
00FD1C5E  6F02                    2821              BLE.S   HEXOK5
00FD1C60  5E01                    2822              ADDQ.B   #7,D1                  ;ADD TO MAKE 10=>A
00FD1C62  6100 0036               2823  HEXOK5:     BSR     PUTCHAR
00FD1C66  4E75                    2824              RTS     ;All done
00FD1C68                          2825  
00FD1C68                          2826  
00FD1C68                          2827              
00FD1C68                          2828  PUTBITS_D6: ;Display Byte bit pattern in D6
00FD1C68  2F03                    2829              MOVE.L  D3,-(A7)                ;Save D3
00FD1C6A  2F02                    2830              MOVE.L  D2,-(A7)                ;Save D2
00FD1C6C  163C 0007               2831              MOVE.B  #7,D3                   ;Bit indicator (7,6,5...0)
00FD1C70  143C 0008               2832              MOVE.B  #8,D2                   ;Bit count
00FD1C74                          2833              
00FD1C74  0706                    2834  PUTBIT1:    BTST    D3,D6
00FD1C76  6700 000E               2835              BEQ     SHOW_0
00FD1C7A  123C 0031               2836              MOVE.B  #'1',D1
00FD1C7E  6100 001A               2837              BSR     PUTCHAR
00FD1C82  6000 000A               2838              BRA     NEXT_BIT
00FD1C86  123C 0030               2839  SHOW_0:     MOVE.B  #'0',D1
00FD1C8A  6100 000E               2840              BSR     PUTCHAR
00FD1C8E  5303                    2841  NEXT_BIT:   SUBQ.B  #1,D3
00FD1C90  5302                    2842              SUBQ.B  #1,D2                   ;8 bits total
00FD1C92  66E0                    2843              BNE     PUTBIT1
00FD1C94  241F                    2844              MOVE.L  (A7)+,D2                ;Restore D2
00FD1C96  261F                    2845              MOVE.L  (A7)+,D3                ;Restore D3
00FD1C98  4E75                    2846              RTS
00FD1C9A                          2847  
00FD1C9A                          2848  ;---------------------------- MAIN ROUTINE TO PRINT A CHARACTER ON CONSOLE --------------------------
00FD1C9A                          2849  
00FD1C9A                          2850              ;Send ASCII character in D1
00FD1C9A                          2851  PUTCHAR:    
00FD1C9A                 FALSE    2852     IFNE SIMMULATOR  ;If SIMMULATOR = 1, then send character via software int
00FD1C9A                          2853     ENDC
00FD1C9A                          2854  
00FD1C9A                 TRUE     2855    IFEQ SIMMULATOR   ;If SIMMULATOR = 0, then send via console I/O port (or serial port)
00FD1C9A  2F05                    2856              MOVE.L  D5,-(A7)                ;> Save D5
00FD1C9C  2F08                    2857              MOVE.L  A0,-(A7)                ;> Save A0
00FD1C9E  207C 00FF00EF           2858              MOVE.L  #IOBYTE,A0              ;Point to IOBYTE Port on SMB
00FD1CA4  1A10                    2859              MOVE.B  (A0),D5                 ;Check if data is to be sent to the serial port
00FD1CA6  CA3C 0020               2860              AND.B   #$20,D5
00FD1CAA  4A05                    2861              TST.B   D5
00FD1CAC  6600 000C               2862              BNE     PUTCHAR0                :Jump to simple Propeller port
00FD1CB0  6100 0058               2863              BSR     SERIAL_OUT              ;Call serial output routine
00FD1CB4  205F                    2864              MOVE.L  (A7)+,A0                ;Restore A0
00FD1CB6  2A1F                    2865              MOVE.L  (A7)+,D5                ;Restore D5
00FD1CB8  4E75                    2866              RTS     ;Return from subroutine, char in D1
00FD1CBA                          2867              
00FD1CBA  205F                    2868  PUTCHAR0:   MOVE.L  (A7)+,A0                ;< Restore A0
00FD1CBC  1A10                    2869  PUTCHAR1:   MOVE.B  (A0),D5                 ;Check CRT status is ready to recieve character
00FD1CBE  CA3C 0004               2870              AND.B   #$04,D5
00FD1CC2  4A05                    2871              TST.B   D5
00FD1CC4  67F6                    2872              BEQ     PUTCHAR1
00FD1CC6  1281                    2873              MOVE.B  D1,(A1)                 ;Output ASCII (in D1) to hardware port 01H
00FD1CC8  2A1F                    2874              MOVE.L  (A7)+,D5                ;< Restore D5
00FD1CCA  4E75                    2875              RTS     ;Return from subroutine
00FD1CCC                          2876     ENDC
00FD1CCC                          2877  
00FD1CCC                          2878  
00FD1CCC                          2879  
00FD1CCC                          2880  ;---------------------------- MAIN ROUTINE TO GET A CHARACTER FROM CONSOLE --------------------------
00FD1CCC                          2881  
00FD1CCC                          2882              ;A0 has console status port, A1 has console data port
00FD1CCC                          2883  GETCHAR:
00FD1CCC                 FALSE    2884     IFNE SIMMULATOR  ;If SIMMULATOR = 1, then echo character via software int
00FD1CCC                          2885    ENDC
00FD1CCC                          2886     
00FD1CCC                 TRUE     2887     IFEQ SIMMULATOR  ;If SIMMULATOR = 0, then echod character via PUTCHAR 
00FD1CCC  2F05                    2888              MOVE.L  D5,-(A7)                ;> Save D5
00FD1CCE  2F08                    2889              MOVE.L  A0,-(A7)                ;> Save A0
00FD1CD0  207C 00FF00EF           2890              MOVE.L  #IOBYTE,A0              ;Point to IOBYTE Port on SMB
00FD1CD6  1A10                    2891              MOVE.B  (A0),D5                 ;Check if data is to be sent to the serial port
00FD1CD8  CA3C 0020               2892              AND.B   #$20,D5
00FD1CDC  4A05                    2893              TST.B   D5
00FD1CDE  6000 000C               2894              BRA     GETCHAR0                ;Jump to simple Propeller port
00FD1CE2                          2895  ;           BNE     GETCHAR0                
00FD1CE2  6100 0068               2896              BSR     SERIAL_IN               ;Call serial input routine (currently not working!)
00FD1CE6  205F                    2897              MOVE.L  (A7)+,A0                ;Restore A0
00FD1CE8  2A1F                    2898              MOVE.L  (A7)+,D5                ;Restore D5
00FD1CEA  4E75                    2899              RTS     ;Return from subroutine, char in D1
00FD1CEC                          2900              
00FD1CEC  205F                    2901  GETCHAR0:   MOVE.L  (A7)+,A0                ;< Restore A0 (console status port)
00FD1CEE  1A10                    2902  GETCHAR1:   MOVE.B  (A0),D5                 ;Get a keyboard character in D1
00FD1CF0  CA3C 0002               2903              AND.B   #$02,D5
00FD1CF4  4A05                    2904              TST.B   D5                      ;Are we ready
00FD1CF6  67F6                    2905              BEQ     GETCHAR1
00FD1CF8  1211                    2906              MOVE.B  (A1),D1                 ;Get ASCII (in D1) from hardware port 01H
00FD1CFA  619E                    2907              BSR     PUTCHAR                 ;Echo it on console
00FD1CFC  2A1F                    2908              MOVE.L  (A7)+,D5                ;< Restore D5
00FD1CFE  4E75                    2909              RTS     ;Return from subroutine, char in D1
00FD1D00                          2910     ENDC
00FD1D00                          2911  
00FD1D00                          2912  
00FD1D00  1210                    2913  GETSTAT:    MOVE.B  (A0),D1                 ;Get a keyboard status in D1, Z= nothing, 2 = char present
00FD1D02  C23C 0002               2914              AND.B   #$02,D1
00FD1D06  4A01                    2915              TST.B   D1
00FD1D08  4E75                    2916              RTS
00FD1D0A                          2917  
00FD1D0A                          2918  ;--------------------------------- SERIAL PORT OUTPUT CHARACTER ROUTINE -----------------------------
00FD1D0A                          2919  
00FD1D0A  2F05                    2920  SERIAL_OUT: MOVE.L  D5,-(A7)                ;> Save D5
00FD1D0C  2F02                    2921              MOVE.L  D2,-(A7)                ;> Save D2
00FD1D0E  2F08                    2922              MOVE.L  A0,-(A7)                ;> Save A0
00FD1D10  207C 00FF00A1           2923              MOVE.L  #ACTL,A0                ;Point to Control port of Zilog serial chip
00FD1D16  343C 0200               2924              MOVE.W  #512,D2                 ;Will check status 512 times (only)
00FD1D1A                          2925              
00FD1D1A                          2926  SERIAL_OUT_STAT:    
00FD1D1A  1A10                    2927              MOVE.B  (A0),D5                 ;Check serial port is ready
00FD1D1C  CA3C 0004               2928              AND.B   #$04,D5
00FD1D20  4A05                    2929              TST.B   D5
00FD1D22  6600 0014               2930              BNE     SEND_SERIAL             ;Ready to send
00FD1D26  5342                    2931              SUB.W   #1,D2                   ;Decraeae loop count
00FD1D28  4A42                    2932              TST.W   D2
00FD1D2A  66EE                    2933              BNE     SERIAL_OUT_STAT
00FD1D2C  123C 0000               2934              MOVE.B  #0,D1                   ;Return empty just in case
00FD1D30                          2935  SERIAL_DONE:
00FD1D30  205F                    2936              MOVE.L  (A7)+,A0                ;< Restore A0
00FD1D32  241F                    2937              MOVE.L  (A7)+,D2                ;< Restore D2
00FD1D34  2A1F                    2938              MOVE.L  (A7)+,D5                ;< Restore D5
00FD1D36  4E75                    2939              RTS     ;Return from subroutine, char in D1
00FD1D38                          2940  
00FD1D38                          2941  SEND_SERIAL:
00FD1D38  207C 00FF00A3           2942              MOVE.L  #ADTA,A0                ;Point to data port of Zilog serial chip
00FD1D3E  1081                    2943              MOVE.B  D1,(A0)                 
00FD1D40  60EE                    2944              BRA     SERIAL_DONE
00FD1D42                          2945  
00FD1D42                          2946  
00FD1D42                          2947  ;--------------------------------- SERIAL PORT INPUT CHARACTER ROUTINE -----------------------------
00FD1D42                          2948              ;For XMODEM input
00FD1D42  2F0B                    2949  RECV:       MOVE.L  A3,-(A7)                ;> Save A3
00FD1D44  6100 0016               2950              BSR     SERIAL_IN_CORE          ;D2 will contain delay countdown
00FD1D48  265F                    2951              MOVE.L  (A7)+,A3                ;< Restore A3
00FD1D4A  4E75                    2952              RTS
00FD1D4C                          2953              ;For other serial input
00FD1D4C  2F0B                    2954  SERIAL_IN:  MOVE.L  A3,-(A7)                ;> Save A3
00FD1D4E  243C 00001F40           2955              MOVE.L  #SERIAL_RETRYS,D2       ;Default number of times to try port before aborting
00FD1D54  6100 0006               2956              BSR     SERIAL_IN_CORE          
00FD1D58  265F                    2957              MOVE.L  (A7)+,A3                ;< Restore A3
00FD1D5A  4E75                    2958              RTS
00FD1D5C                          2959  
00FD1D5C                          2960  SERIAL_IN_CORE:
00FD1D5C  267C 00FF00A1           2961              MOVE.L  #ACTL,A3                ;Point to Control port of Zilog serial chip
00FD1D62  323C 0005               2962              MOVE.W  #$5,D1
00FD1D66  1681                    2963              MOVE.B  D1,(A3)                 ;Lower RTS line
00FD1D68  323C 00EA               2964              MOVE.W  #$EA,D1
00FD1D6C  1681                    2965              MOVE.B  D1,(A3)                 
00FD1D6E  4E71                    2966              nop
00FD1D70  4E71                    2967              nop
00FD1D72  4E71                    2968              nop
00FD1D74  4E71                    2969              nop
00FD1D76  1213                    2970  SERIAL_IN2: MOVE.B  (A3),D1
00FD1D78  C23C 0001               2971              AND.B   #$01,D1
00FD1D7C  B23C 0001               2972              CMP.B   #$01,D1
00FD1D80  6700 0012               2973              BEQ     SERIAL_IN3              ;Get serial data
00FD1D84  5382                    2974              SUB.L   #1,D2
00FD1D86  4A42                    2975              TST.W   D2
00FD1D88  66EC                    2976              BNE     SERIAL_IN2
00FD1D8A  143C 0000               2977              MOVE.B  #0,D2                   ;Return with 0 in D2 if timeout
00FD1D8E  123C 0000               2978              MOVE.B  #0,D1                   ;Return with 0 in D1 if timeout
00FD1D92  4E75                    2979              RTS
00FD1D94                          2980              
00FD1D94  267C 00FF00A3           2981  SERIAL_IN3: MOVE.L  #ADTA,A3                ;Point to data port of Zilog serial chip
00FD1D9A  1213                    2982              MOVE.B  (A3),D1                 ;Get byte of data, put in D1
00FD1D9C  143C 00FF               2983              MOVE.B  #$FF,D2                 ;Return with FF in D2 if all is OK
00FD1DA0  4E75                    2984              RTS     
00FD1DA2                          2985              
00FD1DA2                          2986  
00FD1DA2                          2987  ;---------------------------- MAIN ROUTINE TO PRINT A STRING ON CONSOLE --------------------------
00FD1DA2                          2988  
00FD1DA2                          2989  PRINT_STRING:       ;Print string up to terminating \0
00FD1DA2  121A                    2990              MOVE.B  (A2)+,D1                
00FD1DA4  4A01                    2991              TST.B   D1
00FD1DA6  6700 0008               2992              BEQ     PRINT_DONE
00FD1DAA  6100 FEEE               2993              BSR     PUTCHAR
00FD1DAE  60F2                    2994              BRA     PRINT_STRING
00FD1DB0  4E75                    2995  PRINT_DONE: RTS
00FD1DB2                          2996  
00FD1DB2                          2997              
00FD1DB2                          2998  CRLF:
00FD1DB2  123C 000D               2999              MOVE.B  #CR,D1                  ;Send CR/LF to CRT
00FD1DB6  6100 FEE2               3000              BSR     PUTCHAR
00FD1DBA  123C 000A               3001              MOVE.B  #LF,D1
00FD1DBE  6100 FEDA               3002              BSR     PUTCHAR
00FD1DC2  4E75                    3003              RTS
00FD1DC4                          3004              
00FD1DC4  123C 0009               3005  PUT_TAB:    MOVE.B  #TAB,D1                 ;Send TAB to CRT
00FD1DC8  6100 FED0               3006              BSR     PUTCHAR
00FD1DCC  4E75                    3007              RTS
00FD1DCE                          3008  
00FD1DCE  123C 0020               3009  SPACE:      MOVE.B  #BLANK,D1               ;SPACE to CRT
00FD1DD2  6100 FEC6               3010              BSR     PUTCHAR
00FD1DD6  4E75                    3011              RTS
00FD1DD8                          3012  
00FD1DD8                          3013  
00FD1DD8  B23C 0040               3014  TOUPPER:    CMP.B   #$40,D1                 ;LC->UC in D1
00FD1DDC  6500 000E               3015              BCS     UPPER_DONE
00FD1DE0  B23C 007B               3016              CMP.B   #$7B,D1
00FD1DE4  6400 0006               3017              BCC     UPPER_DONE
00FD1DE8  C23C 005F               3018              AND.B   #$5F,D1
00FD1DEC  4E75                    3019  UPPER_DONE: RTS     
00FD1DEE                          3020              
00FD1DEE                          3021              
00FD1DEE  45F9 00FD2160           3022  ERROR:      LEA     ErrorMsg,A2             ;Show unknown error
00FD1DF4  61AC                    3023              BSR     PRINT_STRING
00FD1DF6  6000 E264               3024              BRA     LOOP
00FD1DFA                          3025  
00FD1DFA  45F9 00FD218B           3026  NOT_DONE:   LEA     NotDoneMsg,A2           ;Code not done yet
00FD1E00  61A0                    3027              BSR     PRINT_STRING
00FD1E02  6000 E258               3028              BRA     LOOP
00FD1E06                          3029  
00FD1E06                          3030              ;Send character in D1 to Console IO board speaker
00FD1E06  2F0B                    3031  SPEAKOUT:   MOVE.L  A3,-(A7)                ;> Save A3
00FD1E08  2F02                    3032              MOVE.L  D2,-(A7)                ;> Save D2
00FD1E0A  2F03                    3033              MOVE.L  D3,-(A7)                ;> Save D3
00FD1E0C  243C 000000FF           3034              MOVE.L  #255,D2                 ;Will try 255 times, then timeout
00FD1E12  267C 00FF00A0           3035              MOVE.L  #BCTL,A3
00FD1E18  2613                    3036  SOUT1:      MOVE.L  (A3),D3
00FD1E1A  C63C 0004               3037              AND.B   #$04,D3
00FD1E1E  6600 000E               3038              BNE     SENDS
00FD1E22  5302                    3039              SUB.B   #1,D2
00FD1E24  66F2                    3040              BNE     SOUT1
00FD1E26  261F                    3041  SOUT2:      MOVE.L  (A7)+,D3                ;< Restore D3
00FD1E28  241F                    3042              MOVE.L  (A7)+,D2                ;< Restore D2
00FD1E2A  265F                    3043              MOVE.L  (A7)+,A3                ;< Restore A3
00FD1E2C  4E75                    3044              RTS
00FD1E2E                          3045  
00FD1E2E  267C 00FF00A2           3046  SENDS:      MOVE.L  #BDTA,A3
00FD1E34  1681                    3047              MOVE.B  D1,(A3)                 ;Send actual character to data port
00FD1E36                          3048  ;           BSR     PUTCHAR                 ;<---- For debugging, display character ---
00FD1E36  263C 000003E8           3049              MOVE.L  #SPEAKER_DELAY,D3       ;For some reason we need this delay
00FD1E3C  5383                    3050  SENDS1:     SUB.L   #1,D3                   ;If not characters get dropped!
00FD1E3E  4A83                    3051              TST.L   D3
00FD1E40  66FA                    3052              BNE     SENDS1
00FD1E42  163C 0005               3053              MOVE.B  #5,D3                   ;Sel register 5
00FD1E46  267C 00FF00A0           3054              MOVE.L  #BCTL,A3                ;Raise RTS line to prevent the next character arriving
00FD1E4C  1683                    3055              MOVE.B  D3,(A3)
00FD1E4E  163C 00E8               3056              MOVE.B  #$E8,D3
00FD1E52  1683                    3057              MOVE.B  D3,(A3)
00FD1E54  60D0                    3058              BRA     SOUT2
00FD1E56                          3059               
00FD1E56                          3060              ;ROUTINE TO SEND A STRING IN (A2) TO TALKER, terminate with 0 (or CR)
00FD1E56                          3061  SPEAK_STRING:       
00FD1E56  121A                    3062              MOVE.B  (A2)+,D1
00FD1E58  B23C 0000               3063              CMP.B   #0,D1                   
00FD1E5C  4A01                    3064              TST.B   D1
00FD1E5E  6700 000E               3065              BEQ     SPEAK_DONE
00FD1E62  B23C 000D               3066              CMP.B   #CR,D1
00FD1E66  6700 0006               3067              BEQ     SPEAK_DONE
00FD1E6A  619A                    3068              BSR     SPEAKOUT
00FD1E6C  60E8                    3069              BRA     SPEAK_STRING
00FD1E6E  123C 000D               3070  SPEAK_DONE: MOVE.B  #CR,D1                  ;Flush speaker que
00FD1E72  6092                    3071              BRA     SPEAKOUT
00FD1E74  4E75                    3072              RTS
00FD1E76                          3073  
00FD1E76                          3074              
00FD1E76                          3075              
00FD1E76                          3076  TEST_SERIAL:
00FD1E76  45F9 00FD250D           3077              LEA     SERIAL_TEST_MSG,A2      ;Will show mesage explaining the test
00FD1E7C  6100 FF24               3078              BSR     PRINT_STRING
00FD1E80                          3079  TEST_SERIAL1:
00FD1E80  6100 FECA               3080              BSR     SERIAL_IN
00FD1E84  B23C 001B               3081              CMP.B   #ESC,D1                 ;If ESC return to main loop
00FD1E88  6700 0008               3082              BEQ     TEST_SERIAL_DONE
00FD1E8C  6100 FE7C               3083              BSR     SERIAL_OUT
00FD1E90  60EE                    3084              BRA     TEST_SERIAL1
00FD1E92                          3085  TEST_SERIAL_DONE:
00FD1E92  45F9 00FD2566           3086              LEA     SERIAL_TEST_DONE_MSG,A2 ;Will show mesage explaining the test
00FD1E98  6100 FF08               3087              BSR     PRINT_STRING
00FD1E9C  6000 E1BE               3088              BRA     loop                    ;Back to start for next command
00FD1EA0                          3089              
00FD1EA0                          3090  
00FD1EA0                          3091  SERIAL_INITILIZE_A:
00FD1EA0  247C 00FF00A1           3092              MOVE.L  #ACTL,A2                ;ZILOG SCC base A port
00FD1EA6  740E                    3093              MOVE.L  #14,D2                  ;Byte count (14), for below
00FD1EA8  47F9 00FD1FA4           3094              LEA     SCCINIT_A,A3            ;Start of SCCINIT table
00FD1EAE  1A1B                    3095  SCC_1:      MOVE.B  (A3)+,D5                ;Table of Zilog SCC Initilization values
00FD1EB0  1485                    3096              MOVE.B  D5,(A2)                 ;Program the SCC Channel B (A1,A3 or 10,12H) for 19K Baud
00FD1EB2  5302                    3097              SUB.B   #1,D2                   ;All 14 values
00FD1EB4  4A02                    3098              TST.B   D2
00FD1EB6  66F6                    3099              BNE     SCC_1
00FD1EB8  4E75                    3100              RTS
00FD1EBA                          3101  
00FD1EBA                          3102  
00FD1EBA                          3103  SERIAL_INITILIZE_B: 
00FD1EBA  247C 00FF00A0           3104              MOVE.L  #BCTL,A2                ;ZILOG SCC base B port
00FD1EC0  740E                    3105              MOVE.L  #14,D2                  ;Byte count (14), for below
00FD1EC2  47F9 00FD1FB4           3106              LEA     SCCINIT_B,A3            ;Start of SCCINIT table
00FD1EC8  1A1B                    3107  SCC_2:      MOVE.B  (A3)+,D5                ;Table of Zilog SCC Initilization values
00FD1ECA  1485                    3108              MOVE.B  D5,(A2)                 ;Program the SCC Channel B (A1,A3 or 10,12H) for 19K Baud
00FD1ECC  5302                    3109              SUB.B   #1,D2                   ;All 14 values
00FD1ECE  4A02                    3110              TST.B   D2
00FD1ED0  66F6                    3111              BNE     SCC_2
00FD1ED2  4E75                    3112              RTS
00FD1ED4                          3113  
00FD1ED4                          3114  
00FD1ED4                          3115  ;---------------------------------------------------------------------------------------------------
00FD1ED4                          3116  
00FD1ED4= 00FD00C6                3117  ctable      dc.l    MEM_MAP                 ;A;Display Memory Map
00FD1ED8= 00FD0096                3118              dc.l    ERR                     ;B
00FD1EDC= 00FD18E0                3119              dc.l    XMODEM_BIN              ;C;Upload an XModem .bin file
00FD1EE0= 00FD012E                3120              dc.l    DISPLAY_RAM             ;D;Display Memory contents (Read RAM in Bytes)
00FD1EE4= 00FD04BA                3121              dc.l    ECHO_ASCII              ;E;Echo ASCII keyboard character to Console
00FD1EE8= 00FD01C0                3122              dc.l    FILL_RAM                ;F;Fill memory contents
00FD1EEC= 00FD04FA                3123              dc.l    GOTO_RAM                ;G;Jump to a ADDRESS location
00FD1EF0= 00FD050A                3124              dc.l    HEX_MATH                ;H;Add & Subtract two Hex numbers
00FD1EF4= 00FD07B6                3125              dc.l    TIME                    ;I;Put CMOS-RTC Time & Date on CRT
00FD1EF8= 00FD0096                3126              dc.l    ERR                     ;J
00FD1EFC= 00FD00BA                3127              dc.l    SHOW_MENU               ;K;Display this menu
00FD1F00= 00FD055A                3128              dc.l    TEST_INTS               ;L;Test Interrupt hardware
00FD1F04= 00FD0268                3129              dc.l    MOVE_RAM                ;M;Move memory
00FD1F08= 00FD08CA                3130              dc.l    MY_IDE                  ;N;Sub-menu to test/diagnose IDE Board
00FD1F0C= 00FD0096                3131              dc.l    ERR                     ;O
00FD1F10= 00FD0096                3132              dc.l    ERR                     ;P
00FD1F14= 00FD02AE                3133              dc.l    QUERY_PORT              ;Q;Query In or Out to a port
00FD1F18= 00FD0096                3134              dc.l    ERR                     ;R
00FD1F1C= 00FD0206                3135              dc.l    SUBS_RAM                ;S;Substitute byte values in RAM
00FD1F20= 00FD03BC                3136              dc.l    ASCII_RAM               ;T;Show ASCII values in RAM
00FD1F24= 00FD1E76                3137              dc.l    TEST_SERIAL             ;U;Test serial port
00FD1F28= 00FD042A                3138              dc.l    VERIFY_RAM              ;V;Verify two memory regions are the same
00FD1F2C= 00FD0096                3139              dc.l    ERR                     ;W
00FD1F30= 00FD07DC                3140              dc.l    SIGNALS                 ;X;Setup for hardware S-100 bus signals test
00FD1F34= 00FD088A                3141              dc.l    PATCH                   ;Y;Quick patch to move RAM 4000H-9000H to F4000H & JUMP to it
00FD1F38= 00FD07C4                3142              dc.l    JMP_Z80                 ;Z;Return back to Z80 master
00FD1F3C                          3143  
00FD1F3C                          3144  
00FD1F3C= 00FD09DC                3145  IDE_TABLE   dc.l    SET_DRIVE_A             ; "A"  Select Drive A
00FD1F40= 00FD09E4                3146              dc.l    SET_DRIVE_B             ; "B"  Select Drive B
00FD1F44= 00FD103A                3147              dc.l    COPY_AB                 ; "C"  Copy Drive A to Drive B
00FD1F48= 00FD183A                3148              dc.l    IDE_ERR                 ; "D"  
00FD1F4C= 00FD0BCE                3149              dc.l    FILL_SEC                ; "E"  Fill a sector with a byte value
00FD1F50= 00FD0F2C                3150              dc.l    FORMAT                  ; "F"  Format current disk
00FD1F54= 00FD183A                3151              dc.l    IDE_ERR                 ; "G" 
00FD1F58= 00FD183A                3152              dc.l    IDE_ERR                 ; "H"  
00FD1F5C= 00FD183A                3153              dc.l    IDE_ERR                 ; "I" 
00FD1F60= 00FD183A                3154              dc.l    IDE_ERR                 ; "J"  
00FD1F64= 00FD095A                3155              dc.l    IDE_LOOP                ; "K"  
00FD1F68= 00FD0C6C                3156              dc.l    SET_LBA                 ; "L"  Set LBA value (Set Track,sector)  
00FD1F6C= 00FD183A                3157              dc.l    IDE_ERR                 ; "M"  
00FD1F70= 00FD0C8A                3158              dc.l    NEXT_SECT               ; "N"  Next Sector
00FD1F74= 00FD0A1A                3159              dc.l    DRIVE_ID                ; "O"  Show current Drive ID
00FD1F78= 00FD0CAC                3160              dc.l    PREV_SECT               ; "P"  Previous sector
00FD1F7C= 00FD183A                3161              dc.l    IDE_ERR                 ; "Q"  
00FD1F80= 00FD0B0C                3162              dc.l    READ_SEC                ; "R"  Read sector to data buffer
00FD1F84= 00FD0CCE                3163              dc.l    SEQ_SEC_RD              ; "S"  Sequental sec read and display contents
00FD1F88= 00FD183A                3164              dc.l    IDE_ERR                 ; "T"  
00FD1F8C= 00FD183A                3165              dc.l    IDE_ERR                 ; "U"  
00FD1F90= 00FD1146                3166              dc.l    VERIFY_AB               ; "V"  Verify Drive A:= Drive B:
00FD1F94= 00FD0B5C                3167              dc.l    WRITE_SEC               ; "W"  Write data buffer to current sector
00FD1F98= 00FD0D7C                3168              dc.l    N_RD_SEC                ; "X"  Read N sectors to RAM
00FD1F9C= 00FD0E4A                3169              dc.l    N_WR_SEC                ; "Y"  Write N sectors
00FD1FA0= 00FD183A                3170              dc.l    IDE_ERR                 ; "Z"  
00FD1FA4                          3171              
00FD1FA4                          3172  
00FD1FA4                          3173              ;BOTH CONSOLE IO BOARD's SSC's are set for 19,200 BAUD
00FD1FA4= 04                      3174  SCCINIT_A:  dc.b    $04                     ;Point to WR4
00FD1FA5= 44                      3175              dc.b    $44                     ;X16 clock,1 Stop,NP
00FD1FA6= 03                      3176              dc.b    $03                     ;Point to WR3
00FD1FA7= C1                      3177              dc.b    $C1                     ;Enable reciever, Auto Enable, Recieve 8 bits
00FD1FA8                          3178  ;           dc.b    $E1                     ;Enable reciever, No Auto Enable, Recieve 8 bits (for CTS bit)
00FD1FA8= 05                      3179              dc.b    $05                     ;Point to WR5
00FD1FA9= EA                      3180              dc.b    $EA                     ;Enable, Transmit 8 bits
00FD1FAA= 0B                      3181              dc.b    $0B                     ;Set RTS,DTR, Enable. Point to WR11
00FD1FAB= 56                      3182              dc.b    $56                     ;Recieve/transmit clock = BRG
00FD1FAC= 0C                      3183              dc.b    $0C                     ;Point to WR12
00FD1FAD                          3184  ;           dc.b    $40                     ;Low Byte 2400 Baud 
00FD1FAD                          3185  ;           dc.b    $1E                     ;Low Byte 4800 Baud 
00FD1FAD                          3186  ;           dc.b    $0E                     ;Low Byte 9600 Baud 
00FD1FAD                          3187  ;           dc.b    $06                     ;Low byte 19,200 Baud 
00FD1FAD= 02                      3188              dc.b    $02                     ;Low byte 38,400 Baud <<<<<<<<<<< XModem I/O
00FD1FAE                          3189  ;           dc.b    $00                     ;Low byte 76,800 Baud  
00FD1FAE= 0D                      3190              dc.b    $0D                     ;Point to WR13
00FD1FAF= 00                      3191              dc.b    $00                     ;High byte for Baud
00FD1FB0= 0E                      3192              dc.b    $0E                     ;Point to WR14
00FD1FB1= 01                      3193              dc.b    $01                     ;Use 4.9152 MHz Clock. Note SD Systems uses a 2.4576 MHz clock, enable BRG
00FD1FB2= 0F                      3194              dc.b    $0F                     ;Point to WR15
00FD1FB3= 00                      3195              dc.b    $00                     ;Generate Int with CTS going high
00FD1FB4                          3196  
00FD1FB4                          3197  SCCINIT_B:
00FD1FB4= 04                      3198              dc.b    $04                     ;Point to WR4
00FD1FB5= 44                      3199              dc.b    $44                     ;X16 clock,1 Stop,NP
00FD1FB6= 03                      3200              dc.b    $03                     ;Point to WR3
00FD1FB7= C1                      3201              dc.b    $C1                     ;Enable reciever, Auto Enable, Recieve 8 bits
00FD1FB8= 05                      3202              dc.b    $05                     ;Point to WR5
00FD1FB9= EA                      3203              dc.b    $EA                     ;Enable, Transmit 8 bits
00FD1FBA= 0B                      3204              dc.b    $0B                     ;Set RTS,DTR, Enable. Point to WR11
00FD1FBB= 56                      3205              dc.b    $56                     ;Recieve/transmit clock = BRG
00FD1FBC= 0C                      3206              dc.b    $0C                     ;Point to WR12
00FD1FBD= 06                      3207              dc.b    $06                     ;Low byte 19,200 Baud <<<<<<<<<<< Note Speech synthizer defaults to this value
00FD1FBE= 0D                      3208              dc.b    $0D                     ;Point to WR13
00FD1FBF= 00                      3209              dc.b    $00                     ;High byte for Baud
00FD1FC0= 0E                      3210              dc.b    $0E                     ;Point to WR14
00FD1FC1= 01                      3211              dc.b    $01                     ;Use 4.9152 MHz Clock. Note SD Systems uses a 2.4576 MHz clock, enable BRG
00FD1FC2= 0F                      3212              dc.b    $0F                     ;Point to WR15
00FD1FC3= 00                      3213              dc.b    $00                     ;Generate Int with CTS going high
00FD1FC4                          3214  
00FD1FC4                          3215              
00FD1FC4= 0D 0A 0D 0A 36 38 ...   3216  Signon      dc.b   CR,LF,CR,LF,'68000 Monitor V3.11 John Monahan 2/6/2021',CR,LF,0
00FD1FF4= 0D 0A 3E 00             3217  Prompt      dc.b   CR,LF,'>',0              
00FD1FF8= 0D 0A                   3218  Menu        dc.b   CR,LF
00FD1FFA= 41 3D 4D 65 6D 6D ...   3219              dc.b   'A=Memmap    C=XMODEM(Bin) D=Disp RAM    E=Echo        F=Fill RAM'
00FD203A= 0D 0A                   3220              dc.b   CR,LF
00FD203C= 47 3D 47 6F 74 6F ...   3221              dc.b   'G=Goto RAM  H=Math        I=Time        K=Menu        L=Test Ints'
00FD207D= 0D 0A                   3222              dc.b   CR,LF
00FD207F= 4D 3D 4D 6F 76 65 ...   3223              dc.b   'M=Move RAM  N=IDE Menu    Q=Port I/O    U=Serial Test S=Subs RAM'
00FD20BF= 0D 0A                   3224              dc.b   CR,LF
00FD20C1= 54 3D 54 79 70 65 ...   3225              dc.b   'T=Type RAM  V=Verify RAM  X=Signals     Y=Patch       Z=Back to Z80'
00FD2104= 0D 0A 0A 00             3226              dc.b   CR,LF,LF,0
00FD2108                          3227  
00FD2108= 54 48 45 20 36 38 ...   3228  SMSG        dc.b   'THE 68 THOUSAND ROM MONITOR, VERSION 3.11 IS NOW ACTIVE',0
00FD2140                          3229              
00FD2140= 0D 0A 07 42 61 64 ...   3230  BadCmdMsg   dc.b   CR,LF,BELL,'Bad Command. Got a vlaue of ',0
00FD2160= 0D 0A 07 49 6E 76 ...   3231  ErrorMsg    dc.b   CR,LF,BELL,'Invalid entry',CR,LF,0 
00FD2173= 0D 0A 50 6F 72 74 ...   3232  PortMsg     dc.b   CR,LF,'Port ',0
00FD217B= 0D 0A 53 65 6E 64 ...   3233  PortMsg2    dc.b   CR,LF,'Send to Port ',0
00FD218B= 0D 0A 07 53 6F 72 ...   3234  NotDoneMsg  dc.b   CR,LF,BELL,'Sorry code for this command has not been written yet',CR,LF,0
00FD21C5= 0D 0A 53 75 6D 20 ...   3235  HEX_Data    dc.b   CR,LF,'Sum = ',0
00FD21CE= 48 20 20 44 69 66 ...   3236  HEX_Data2   dc.b   'H  Difference = ',0
00FD21DF                          3237  
00FD21DF= 0D 0A 49 6E 74 2E ...   3238  BUS_ERROR_MSG       dc.b   CR,LF,'Int. Error',CR,LF,0
00FD21EE= 0D 0A 49 6E 74 2E ...   3239  ADDRESS_ERROR_MSG   dc.b   CR,LF,'Int. Address Error',CR,LF,0
00FD2205= 0D 0A 49 6C 6C 65 ...   3240  ILLEGAL_ERROR_MSG   dc.b   CR,LF,'Illegal Opcode Int.',CR,LF,0
00FD221D= 0D 0A 5A 65 72 6F ...   3241  ZERO_ERROR_MSG      dc.b   CR,LF,'Zero Error Int.',CR,LF,0
00FD2231= 0D 0A 50 72 69 76 ...   3242  PRIVILEGE_ERROR_MSG dc.b   CR,LF,'Priviledge Error Int.',CR,LF,0
00FD224B= 0D 0A 54 72 61 63 ...   3243  TRACE_ERROR_MSG     dc.b   CR,LF,'Trace Error Int.',CR,LF,0
00FD2260= 0D 0A 53 70 75 72 ...   3244  SPURIOUS_INT_MSG    dc.b   CR,LF,'Spurious Int.',CR,LF,0
00FD2272= 0D 0A 4C 31 20 28 ...   3245  L1_INTERRUPT_MSG    dc.b   CR,LF,'L1 (or NMI) Int.',CR,LF,0
00FD2287= 0D 0A 4C 32 20 49 ...   3246  L2_INTERRUPT_MSG    dc.b   CR,LF,'L2 Int.',CR,LF,0
00FD2293= 0D 0A 4C 33 20 49 ...   3247  L3_INTERRUPT_MSG    dc.b   CR,LF,'L3 Int.',CR,LF,0
00FD229F= 0D 0A 4C 34 20 49 ...   3248  L4_INTERRUPT_MSG    dc.b   CR,LF,'L4 Int.',CR,LF,0
00FD22AB= 0D 0A 4C 35 20 49 ...   3249  L5_INTERRUPT_MSG    dc.b   CR,LF,'L5 Int.',CR,LF,0
00FD22B7= 0D 0A 4C 36 20 49 ...   3250  L6_INTERRUPT_MSG    dc.b   CR,LF,'L6 Int.',CR,LF,0
00FD22C3= 0D 0A 4C 37 20 49 ...   3251  L7_INTERRUPT_MSG    dc.b   CR,LF,'L7 Int.',CR,LF,0
00FD22CF= 0D 0A 55 6E 64 65 ...   3252  INT_ERR_MSG dc.b   CR,LF,'Undefined Int.',CR,LF,0
00FD22E2= 0D 0A 55 6E 64 65 ...   3253  TRAPS_ERR_MSG       dc.b   CR,LF,'Undefined TRAP Int.',CR,LF,0
00FD22FA= 0D 0A 49 6E 74 65 ...   3254  INTS_DONE_MSG       dc.b   CR,LF,'Interrupts in RAM (0-400H) initilized'
00FD2321= 0D 0A 57 69 6C 6C ...   3255              dc.b   CR,LF,'Will continously print ".", any keyboard character will cause an interrupt'
00FD236D= 0D 0A 48 69 74 20 ...   3256              dc.b   CR,LF,'Hit CR key to start, any other key to abort.',0
00FD239C                          3257              
00FD239C= 0D 0A 53 6F 72 72 ...   3258  TIME_MSG    dc.b   CR,LF,'Sorry, time module not written yet',CR,LF,0
00FD23C3                          3259  
00FD23C3= 0D 0A 50 75 74 20 ...   3260  SIGNALS_MSG dc.b   CR,LF,'Put CPU in hardware loop to test (pDBIN or pWR*)'
00FD23F5= 0D 0A 45 6E 74 65 ...   3261              dc.b   CR,LF,'Enter test RAM Location: ',0
00FD2411= 0D 0A 45 6E 74 65 ...   3262  Menu_1or2_MSG       dc.b   CR,LF,'Enter 1=pDBIN, 2=pWR* :',0
00FD242B= 0D 0A 53 69 67 6E ...   3263  SIG_STARTED_MSG     dc.b   CR,LF,'Signal test started......(Hit Reset to Abort)',0
00FD245B= 0D 0A 57 69 6C 6C ...   3264  ECHO_MSG    dc.b   CR,LF,'Will echo each ASCII char typed on keyboard. ESC to abort',CR,LF,0
00FD2499= 0D 0A 57 69 6C 6C ...   3265  PATCH_MSG           dc.b   CR,LF,'Will move Code at 4000H-9000H to F4000H, Then jump to that location'
00FD24DE= 0D 0A 48 69 74 20 ...   3266              dc.b   CR,LF,'Hit CR key to start, any other key to abort.',0
00FD250D                          3267               
00FD250D= 0D 0A 43 68 61 72 ...   3268  SERIAL_TEST_MSG     dc.b   CR,LF,'Chars entered via serial IN port will appear on serial OUT port.'
00FD254F= 0D 0A 50 72 65 73 ...   3269              dc.b   CR,LF,'Press ESC to abort',CR,LF,0
00FD2566= 0D 0A 53 65 72 69 ...   3270  SERIAL_TEST_DONE_MSG dc.b   CR,LF,'Serial test done.',CR,LF,0
00FD257C                          3271  
00FD257C= 0D 0A 0A 49 44 45 ...   3272  IDE_SIGNON0 dc.b   CR,LF,LF,'IDE HDisk Test Menu Routines.    ',0
00FD25A1= 41 3D 53 65 6C 65 ...   3273  IDE_SIGNON1 dc.b   'A=Select Drive A   B=Select Drive B  E=Fill Sec        F=Format Disk',CR,LF
00FD25E7= 4E 3D 4E 65 78 74 ...   3274              dc.b   'N=Next Sec         P=Previous Sec    L=Set LBA Value   O=Disk ID',CR,LF
00FD2629= 52 3D 52 65 61 64 ...   3275              dc.b   'R=Read Sector      S=Seq Sec Rd      X=Sectors to RAM  W=Write Sector.',CR,LF
00FD2671= 59 3D 52 41 4D 20 ...   3276              dc.b   'Y=RAM to Sectors   C=Copy A->B       V=Verify A=B      (ESC) Main Menu',CR,LF
00FD26B9= 0D 0A 43 75 72 72 ...   3277              dc.b   CR,LF,'Current settings:- ',0
00FD26CF                          3278  
00FD26CF= 45 6E 74 65 72 20 ...   3279  IDE_MENU_CMDdc.b   'Enter a Command:- ',0
00FD26E2= 0D 0A 49 6E 69 74 ...   3280  IDE_HARDWAREdc.b   CR,LF,'Initilizing IDE Drive hardware.',0
00FD2704= 0D 0A 49 6E 69 74 ...   3281  INIT_1_ERRORdc.b   CR,LF,'Init of First Drive failed.',BELL,CR,LF,LF,0
00FD2726= 0D 0A 49 6E 69 74 ...   3282  INIT_2_ERRORdc.b   CR,LF,'Init of Second Drive failed. (Possibly not present).',BELL,CR,LF,LF,0
00FD2761                          3283  
00FD2761= 0D 0A 46 69 72 73 ...   3284  BAD_DRIVE:  dc.b   CR,LF,'First Drive ID Info appears invalid. '
00FD2788= 28 44 72 69 76 65 ...   3285              dc.b   '(Drive possibly not present).',CR,LF
00FD27A7= 41 62 6F 72 74 69 ...   3286              dc.b   'Aborting Command.',BELL,CR,LF,LF,0
00FD27BD= 0D 0A 07 42 61 64 ...   3287  BadIDECmdMsgdc.b   CR,LF,BELL,'Bad Command!',0
00FD27CD                          3288  
00FD27CD= 0D 0A 43 4D 44 20 ...   3289  NotDoneYet  dc.b   CR,LF,'CMD Not Done Yet',0
00FD27E0= 0D 0A 0A 07 57 69 ...   3290  CONFIRM_WR_MSG      dc.b   CR,LF,LF,BELL,'Will erase data on the current drive, '
00FD280A= 61 72 65 20 79 6F ...   3291              dc.b   'are you sure? (Y/N)...',0
00FD2821= 53 65 63 74 6F 72 ...   3292  msgrd       dc.b   'Sector Read OK',CR,LF,0
00FD2832= 53 65 63 74 6F 72 ...   3293  msgwr       dc.b   'Sector Write OK',CR,LF,0
00FD2844= 45 6E 74 65 72 20 ...   3294  SET_LBA_MSG dc.b   'Enter CPM style TRK & SEC values (in hex).',CR,LF,0
00FD2871= 53 74 61 72 74 69 ...   3295  ENTERRAM_SECL       dc.b   'Starting sector number,(xxH) = ',0
00FD2891= 54 72 61 63 6B 20 ...   3296  ENTERRAM_TRKL       dc.b   'Track number (LOW byte, xxH) = ',0
00FD28B1= 54 72 61 63 6B 20 ...   3297  ENTERRAM_TRKH       dc.b   'Track number (HIGH byte, xxH) = ',0
00FD28D2= 44 72 69 76 65 20 ...   3298  DRIVE_BUSY  dc.b   'Drive Busy (bit 7) stuck high.   Status = ',0
00FD28FD= 44 72 69 76 65 20 ...   3299  DRIVE_NOT_READY     dc.b   'Drive Ready (bit 6) stuck low.  Status = ',0
00FD2927= 44 72 69 76 65 20 ...   3300  DRIVE_WR_FAULT      dc.b   'Drive write fault.    Status = ',0
00FD2947= 55 6E 6B 6E 6F 77 ...   3301  UNKNOWN_ERROR       dc.b   'Unknown error in status register.   Status = ',0
00FD2975= 42 61 64 20 53 65 ...   3302  BAD_BLOCK   dc.b   'Bad Sector ID.    Error Register = ',0
00FD2999= 55 6E 63 6F 72 72 ...   3303  UNRECOVER_ERR       dc.b   'Uncorrectable data error.  Error Register = ',0
00FD29C6= 45 72 72 6F 72 20 ...   3304  READ_ID_ERROR       dc.b   'Error setting up to read Drive ID',CR,LF,0
00FD29EA= 53 65 63 74 6F 72 ...   3305  SEC_NOT_FOUND       dc.b   'Sector not found. Error Register = ',0
00FD2A0E= 49 6E 76 61 6C 69 ...   3306  INVALID_CMD dc.b   'Invalid Command. Error Register = ',0
00FD2A31= 54 72 61 63 6B 20 ...   3307  TRK0_ERR    dc.b   'Track Zero not found. Error Register = ',0
00FD2A59= 55 6E 6B 6E 6F 77 ...   3308  UNKNOWN_ERROR1      dc.b   'Unknown Error. Error Register = ',0
00FD2A7A= 0D 0A 54 6F 20 41 ...   3309  CONTINUE_MSGdc.b   CR,LF,'To Abort enter ESC. Any other key to continue. ',0
00FD2AAC= 0D 0A 46 6F 72 6D ...   3310  FORMAT_MSG_Adc.b   CR,LF,'Format Disk A: with E5Hs',0
00FD2AC7= 0D 0A 46 6F 72 6D ...   3311  FORMAT_MSG_Bdc.b   CR,LF,'Format Disk B: with E5Hs',0
00FD2AE2= 0D 0A 07 41 6C 72 ...   3312  ATHOME_MSG  dc.b   CR,LF,BELL,'Already on Track 0, Sector 0',0
00FD2B02= 0D 0A 07 41 6C 72 ...   3313  AT_START_MSGdc.b   CR,LF,BELL,'Already at start of disk!',0
00FD2B1F= 0D 0A 07 41 74 20 ...   3314  AT_END_MSG  dc.b   CR,LF,BELL,'At end of Disk!',0
00FD2B32= 20 2D 2D 2D 2D 3E ...   3315  READN_MSG   dc.b   ' ----> ',0
00FD2B3A= 48 20 2D 2D 2D 2D ...   3316  WRITEN_MSG  dc.b   'H ----> ',0
00FD2B43= 0D 0A 43 6F 70 79 ...   3317  DiskCopyMsg dc.b   CR,LF,'Copy Drive A to Drive B (Y/N)? ',0
00FD2B65= 0D 0A 57 69 6C 6C ...   3318  DiskVerifyMsg       dc.b   CR,LF,'Will verify Drive A = Drive B.',0
00FD2B86= 0D 0A 44 69 73 6B ...   3319  CopyDone    dc.b   CR,LF,'Disk Copy Done.',0
00FD2B98= 0D 0A 07 56 65 72 ...   3320  VERIFY_ERR  dc.b   CR,LF,BELL,'Verify Error at:- ',0
00FD2BAE= 0D 0A 44 69 73 6B ...   3321  VerifyDone  dc.b   CR,LF,'Disk Verify Done.',0
00FD2BC2= 0D 0A 48 69 74 20 ...   3322  CR_To_Continue      dc.b   CR,LF,'Hit any key to continue.',0
00FD2BDD= 20 4F 4B 0D 0A 00       3323  OK_CR_MSG   dc.b   ' OK',CR,LF,0
00FD2BE3= 0D 0A 07 53 65 63 ...   3324  COPY_ERR    dc.b   CR,LF,BELL,'Sector Copy Error.',0
00FD2BF9= 43 75 72 72 65 6E ...   3325  CURRENT_MSG_A       dc.b   'Current Drive = A:',0
00FD2C0C= 43 75 72 72 65 6E ...   3326  CURRENT_MSG_B       dc.b   'Current Drive = B:',0
00FD2C1F= 0D 0A 07 53 65 63 ...   3327  FORMAT_ERR  dc.b   CR,LF,BELL,'Sector Format Error',0
00FD2C36= 0D 0A 07 49 6E 76 ...   3328  ERR_MSG     dc.b   CR,LF,BELL,'Invalid Command (or code not yet done)',CR,LF,0
00FD2C62= 20 20 6F 6E 20 44 ...   3329  DRIVE1_MSG  dc.b   '  on Drive A',CR,LF,0
00FD2C71= 20 20 6F 6E 20 44 ...   3330  DRIVE2_MSG  dc.b   '  on Drive B',CR,LF,0
00FD2C80= 0D 0A 53 65 6C 65 ...   3331  IDE_SEL_A   dc.b   CR,LF,'Selecting IDE Drive A',0
00FD2C98= 0D 0A 53 65 6C 65 ...   3332  IDE_SEL_B   dc.b   CR,LF,'Selecting IDA Drive B',0
00FD2CB0= 0D 0A 54 68 65 20 ...   3333  FORMAT_STARTED_MSG  dc.b   CR,LF,'The current drive is being formatted. Use Esc to abort.',0
00FD2CEA= 0D 0A 45 6E 74 65 ...   3334  FILL_BYTE_MSG       dc.b   CR,LF,'Enter Fill byte (+CR):-',0
00FD2D04                          3335  
00FD2D04= 0D 0A 4C 6F 61 64 ...   3336  MODEM_BIN_SIGNON    dc.b   CR,LF,'Load a .bin File from a PC to RAM using Serial Board',CR,LF
00FD2D3C= 5A 69 6C 6F 67 20 ...   3337              dc.b   'Zilog SCC Ports A1H & A3H, 38,400 Baud.',CR,LF,0
00FD2D66= 0D 0A 45 6E 74 65 ...   3338  RAM_DESTINATION_MSG dc.b   CR,LF,'Enter destination in RAM for data (up to 8 digits): ',0
00FD2D9D= 44 6F 77 6E 6C 6F ...   3339  DOWNLOAD_MSGdc.b   'Downloading file Started.',0
00FD2DB7= 0D 0A 57 41 49 54 ...   3340  RMSG        dc.b   CR,LF,'WAITING FOR SECTOR #',0
00FD2DCE= 48 20 52 65 63 65 ...   3341  ERRSOH      dc.b   'H Received',CR,LF,'Bad SOH',CR,LF,0
00FD2DE4= 0D 0A 42 61 64 20 ...   3342  MODEM_ERR2          dc.b   CR,LF,'Bad Sector # in Header',CR,LF,0
00FD2DFF= 0D 0A 42 61 64 20 ...   3343  MODEM_ERR3  dc.b   CR,LF,'Bad Checksum for Sector',CR,LF,0
00FD2E1B= 0D 0A 54 69 6D 65 ...   3344  TOUTM       dc.b   CR,LF,'Timeout! Error count = ',0
00FD2E35= 0D 0A 2B 2B 2B 20 ...   3345  QUITM       dc.b   CR,LF,'+++ MULTIPLE ERRORS ENCOUNTERED +++'
00FD2E5A= 0D 0A 54 79 70 65 ...   3346              dc.b   CR,LF,'Type Q To Quit, R To Retry:',0
00FD2E78= 48 2E 20 20 49 66 ...   3347  RAM_MSG     dc.b   'H.  If OK will write to RAM location ',0
00FD2E9E= 44 6F 77 6E 20 6C ...   3348  FINISH_MSG  dc.b   'Down loading of file complete.  No Errors',0
00FD2EC8= 0D 0A 0A 44 61 74 ...   3349  TRANS_DONE  dc.b   CR,LF,LF,'Data Transfer Is Complete',CR,LF,LF,0
00FD2EE8= 0D 0A 55 6E 61 62 ...   3350  BAD_HEADER  dc.b   CR,LF,'Unable to get a valid file header!',CR,LF,0
00FD2F0F= 0D 0A 57 69 6C 6C ...   3351  START_B_POINTER_MSG dc.b   CR,LF,'Will load .bin file data starting at RAM location ',0
00FD2F44= 0D 0A 0A 49 6E 76 ...   3352  ABORT_MSG   dc.b   CR,LF,LF,'Invalid Character or Program Aborted',CR,LF,0
00FD2F6E= 48 00                   3353  H_MSG       dc.b   'H',0
00FD2F70= 0D 0A 45 6E 74 65 ...   3354  WILL_WR_MSG         dc.b   CR,LF,'Enter RAM location where data will be copied from (+CR) ',0 
00FD2FAB= 0D 0A 45 6E 74 65 ...   3355  SEC_COUNT_MSG       DC.b   CR,LF,'Enter sector count (+CR) ',0
00FD2FC7= 0D 0A 45 6E 74 65 ...   3356  WILL_RD_MSG         dc.b   CR,LF,'Enter RAM location where data will be placed (+CR) ',0 
00FD2FFD                          3357  
00FD2FFD= 0D 0A 0A 44 72 69 ...   3358  msgmdl      dc.b   CR,LF,LF,'Drive/CF Card Information:-',CR,LF
00FD301D= 4D 6F 64 65 6C 3A ...   3359              dc.b   'Model: ',0
00FD3025= 53 2F 4E 3A 20 20 ...   3360  msgsn       dc.b   'S/N:   ',0
00FD302D= 52 65 76 3A 20 20 ...   3361  msgrev      dc.b   'Rev:   ',0
00FD3035= 43 79 6C 69 6E 64 ...   3362  msgcy       dc.b   'Cylinders: ',0
00FD3041= 2C 20 48 65 61 64 ...   3363  msghd       dc.b   ', Heads: ',0
00FD304B= 2C 20 53 65 63 74 ...   3364  msgsc       dc.b   ', Sectors: ',0
00FD3057= 43 50 4D 20 54 52 ...   3365  msgCPMTRK   dc.b   'CPM TRK = ',0
00FD3062= 20 43 50 4D 20 53 ...   3366  msgCPMSEC   dc.b   ' CPM SEC = ',0
00FD306E= 20 20 28 4C 42 41 ...   3367  msgLBA      dc.b   '  (LBA = 00',0
00FD307A= 29 00                   3368  MSGBracket  dc.b   ')',0
00FD307C= 48 0D 0A 00             3369  H_MSG_CRLF  dc.b   'H',CR,LF,0
00FD3080= 48 0D 00                3370  H_MSG_CR    dc.b   'H',CR,0
00FD3083= 00 00 00 00             3371              dc.b   0,0,0,0
00FD3087                          3372              
00FD3087                          3373              
00FD3087                          3374  
00FD3087                          3375  
00FD3087                          3376  ;---------------------------------------------------------------------------------------------------------
00FD3087                 TRUE     3377     IFNE ROM_CODE    ;If ROM based Code
00FD80F0                          3378              ORG     $00FD80F0               ;Start of Supervisor Stack area, (FD80F0H down to FD8000H)
00FD80F0                          3379  SUPERVISOR_STACK 
00FD80F0= 0000                    3380              DC.W    0
00FD8100                          3381              ORG     $00FD8100               ;Start OF RAM Area on CPU Board, (beginning at FD8100 upwards)
00FD8100                          3382     ENDC
00FD8100                          3383   
00FD8100                          3384   
00FD8100                          3385  
00FD8100                          3386  
00FD8100                 FALSE    3387    IFNE S100_TEST    ;If S100 RAM based Code
00FD8100                          3388     ENDC
00FD8100                          3389    
00FD8100                          3390   
00FD8100                          3391  
00FD8100                          3392  
00FD8100                 FALSE    3393    IFNE SIMMULATOR   ;If SIMMULATOR  
00FD8100                          3394      ENDC    
00FD8100                          3395  
00FD8100                          3396  BeginRAM:
00FD8100                          3397  IDE_BUFFER  ds.b     512                    ;Buffer area for sector data 
00FD8300                          3398  IDE_BUFFER2 ds.b     512
00FD8500                          3399  
00FD8500= 0000                    3400  RAM_DMA:    dc.w     0                      ;Storage or DMA address
00FD8502= 00000000                3401  RAM_DMA_STORE       dc.l     0
00FD8506= 0000                    3402  SECTOR_COUNTdc.w     0
00FD8508= 0000                    3403  DISPLAY_TRK dc.w     0
00FD850A= 0000                    3404  DISPLAY_SEC dc.w     0
00FD850C                          3405  
00FD850C= 00                      3406  RAM_SEC:    dc.b     0                      
00FD850D= 00                      3407  RAM_TRK:    dc.b     0                      
00FD850E= 00                      3408  CURRENT_IDE_DRIVE   dc.b     0
00FD850F= 00                      3409  CURRENT_HEADdc.b     0
00FD8510= 00                      3410  CURRENT_TRACK_HIGH dc.b      0
00FD8511= 00                      3411  CURRENT_TRACK       dc.b     0
00FD8512= 00                      3412  CURRENT_SECTOR      dc.b     0
00FD8513= 00                      3413  SECTORS_TO_DO       dc.b     0
00FD8514                          3414  
00FD8514= 00                      3415  RECVD_SECT_NO       dc.b     0               ;For XMODEM
00FD8515= 00                      3416  SECTNO      dc.b     0               ;   "
00FD8516= 00                      3417  ERRCT       dc.b     0                       ;   "
00FD8518= 00000000                3418  S_FILE_ADDRESS      dc.l     0               ;Start location in RAM of S file
00FD851C                          3419  
00FD851C                          3420  
00FD851C                          3421  
00FD851C= 00                      3422  EndRAM:     dc.b     0                      ;End of 0 cleared RAM area
00FD851D                          3423  
00FD851D                 TRUE     3424     IFEQ SIMMULATOR  ;If SIMMULATOR = 0
00FD851D                          3425              END     $00FDFFFE

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABORTE              FD078E
ABORT_LONG          FD1B76
ABORT_MSG           FD2F44
ACK                 6
ACTL                FF00A1
ADDRESS_ERROR       FD0688
ADDRESS_ERROR_MSG   FD21EE
ADTA                FF00A3
AINBOUT8255CFG      98
ASCII_OK            FD03E8
ASCII_OK1           FD03FE
ASCII_OK2           FD0410
ASCII_RAM           FD03BC
ATHOME_MSG          FD2AE2
AT_00               FD146E
AT_DISK_END         FD1424
AT_END              FD0C9A
AT_END_MSG          FD2B1F
AT_START            FD0CBC
AT_START_MSG        FD2B02
BADCMDMSG           FD2140
BADIDECMDMSG        FD27BD
BAD_BLOCK           FD2975
BAD_DRIVE           FD2761
BAD_HEADER          FD2EE8
BAD_MATCH           FD0474
BCTL                FF00A0
BDTA                FF00A2
BEGINRAM            FD8100
BELL                7
BLANK               20
BUS_ERROR           FD0674
BUS_ERROR_MSG       FD21DF
CHECK_FOR_QUIT      FD1AF6
CLEAR0              FD0C1A
CLEAR2              FD0C3C
CLEAR3              FD1832
CLEARF              FD0F9E
CLEAR_BUFFER        FD0C10
CLEAR_ID_BUFFER     FD1824
CMOS_HOURS          4
CMOS_MINUTES        2
CMOS_PORT           FF0070
CMOS_REGA           FF000A
CMOS_SECONDS        0
CMOS_VALID          FF000D
COMMANDID           EC
COMMANDINIT         91
COMMANDREAD         20
COMMANDRECAL        10
COMMANDSPINDOWN     E0
COMMANDSPINUP       E1
COMMANDWRITE        30
CONFIRM_WR_MSG      FD27E0
CONTINUE_MSG        FD2A7A
COPYDONE            FD2B86
COPY_AB             FD103A
COPY_AB1            FD1058
COPY_ERR            FD2BE3
COPY_OK1            FD10CA
COPY_OK2            FD10DA
COPY_OK3            FD10E6
COUNTS_HOUR         7
COUNTS_MIN          444
COUNTS_SEC          18
CR                  D
CRLF                FD1DB2
CR_TO_CONTINUE      FD2BC2
CTABLE              FD1ED4
CURRENT_HEAD        FD850F
CURRENT_IDE_DRIVE   FD850E
CURRENT_MSG_A       FD2BF9
CURRENT_MSG_B       FD2C0C
CURRENT_SECTOR      FD8512
CURRENT_TRACK       FD8511
CURRENT_TRACK_HIGH  FD8510
C_DONE              FD10FC
C_NEXTSEC1          FD112E
C_NEXTSEC2          FD113A
DBIN_TEST           FD082A
DBIN_TEST1          FD0842
DELAY1              FD15DC
DELAY2              FD15D8
DELAY3              FD15F6
DELAY_32            FD15F2
DIAG_LEDS           FF0005
DISKCOPYMSG         FD2B43
DISKVERIFYMSG       FD2B65
DISK_END            FD0FFE
DISPLAY_POSITION    FD12A2
DISPLAY_RAM         FD012E
DISPLAY_SEC         FD850A
DISPLAY_SECTOR      FD1366
DISPLAY_TRK         FD8508
DONEDRQ             FD1820
DONEERR             FD156E
DONEINIT            FD15EE
DONERSEC            FD0E22
DONEWSEC            FD0F04
DONE_CHECK          FD1B44
DONE_LONG           FD1B8C
DONE_NOT_BUSY       FD17F6
DONE_TEST           FD0110
DOS_MAXCYL          400
DOS_MAXCYL_L        FF
DOS_MAXHEADS        10
DOS_MAXSEC          3E
DOS_MAXSEC_CYL      FF
DOS_WR_LBA          FD1766
DOWNLOAD_MSG        FD2D9D
DO_ACK              FD1AAC
DRIVE1_MSG          FD2C62
DRIVE2_MSG          FD2C71
DRIVE_BUSY          FD28D2
DRIVE_ID            FD0A1A
DRIVE_NOT_READY     FD28FD
DRIVE_WR_FAULT      FD2927
ECHO1               FD04EE
ECHO2               FD04C8
ECHO_ASCII          FD04BA
ECHO_MSG            FD245B
EMPTY               FD010C
ENDRAM              FD851C
ENTERRAM_SECL       FD2871
ENTERRAM_TRKH       FD28B1
ENTERRAM_TRKL       FD2891
EOT                 4
ERR                 FD0096
ERRCT               FD8516
ERROR               FD1DEE
ERRORMSG            FD2160
ERRSOH              FD2DCE
ERR_MSG             FD2C36
ESC                 1B
EXIT1               FD1AEA
EXIT2               FD1AE2
FILL_BYTE_MSG       FD2CEA
FILL_OK             FD01EC
FILL_OK1            FD01FA
FILL_RAM            FD01C0
FILL_SEC            FD0BCE
FINISH_MSG          FD2E9E
FORMAT              FD0F2C
FORMAT_BUFFER       FD0F6E
FORMAT_DONE         FD1008
FORMAT_ERR          FD2C1F
FORMAT_LOOP         FD0FA4
FORMAT_MSG_A        FD2AAC
FORMAT_MSG_B        FD2AC7
FORMAT_STARTED_MSG  FD2CB0
FORM_B              FD0F42
FORM_X              FD0F48
GEN_HEX32_LBA       FD125A
GETBYTE_D7          FD1B8E
GETCHAR             FD1CCC
GETCHAR0            FD1CEC
GETCHAR1            FD1CEE
GETLONG1            FD1B4A
GETLONG_D7          FD1B46
GETNIBBLE           FD1B9A
GETSTAT             FD1D00
GET_NEXT_SECT       FD13E8
GET_PREV_SECT       FD142E
GOTO_RAM            FD04FA
GOT_EOT             FD1AC6
GOT_SOH             FD1A1E
HEXOK2              FD1C1C
HEXOK3              FD1C34
HEXOK4              FD1C4C
HEXOK5              FD1C62
HEX_DATA            FD21C5
HEX_DATA2           FD21CE
HEX_MATH            FD050A
HOLD_STATE          80
H_MSG               FD2F6E
H_MSG_CR            FD3080
H_MSG_CRLF          FD307C
IDEA0LINE           1
IDEA1LINE           2
IDEA2LINE           4
IDECS0LINE          8
IDECS1LINE          10
IDECTRLPORT         FF0033
IDEDRIVEPORT        FF0034
IDEINIT             FD157C
IDEPORTA            FF0030
IDEPORTB            FF0031
IDEPORTC            FF0032
IDERD8D             FD1854
IDERDLINE           40
IDERSTLINE          80
IDEWAITDRQ          FD17FA
IDEWAITNOTBUSY      FD17D0
IDEWR8D             FD1878
IDEWR8D_X           FD18AC
IDEWRLINE           20
IDE_BUFFER          FD8100
IDE_BUFFER2         FD8300
IDE_ERR             FD183A
IDE_HARDWARE        FD26E2
IDE_LOOP            FD095A
IDE_LOOP0           FD0980
IDE_MENU_CMD        FD26CF
IDE_RESET_DELAY     80
IDE_SEL_A           FD2C80
IDE_SEL_B           FD2C98
IDE_SIGNON0         FD257C
IDE_SIGNON1         FD25A1
IDE_TABLE           FD1F3C
IDE_VERIFY_OK       FD11D8
ILLEGAL_ERROR       FD069C
ILLEGAL_ERROR_MSG   FD2205
INIT0               FD0602
INIT1               FD0652
INIT1_OK            FD08E8
INIT2               FD0668
INIT2_OK            FD0902
INIT3_OK            FD091C
INIT4_OK            FD0938
INITDELAY           FD1590
INIT_1_ERROR        FD2704
INIT_2_ERROR        FD2726
INTS_DONE_MSG       FD22FA
INT_ERR_MSG         FD22CF
INT_LOOP            FD0580
INT_LOOP1           FD05A4
INVALID_CMD         FD2A0E
IOBYTE              FF00EF
JMP_Z80             FD07C4
KEYIN               FF0001
KEYOUT              FF0001
KEYSTAT             FF0000
L1_INTERRUPT        FD0700
L1_INTERRUPT_MSG    FD2272
L2_INTERRUPT        FD0716
L2_INTERRUPT_MSG    FD2287
L3_INTERRUPT        FD072A
L3_INTERRUPT_MSG    FD2293
L4_INTERRUPT        FD073E
L4_INTERRUPT_MSG    FD229F
L5_INTERRUPT        FD0752
L5_INTERRUPT_MSG    FD22AB
L6_INTERRUPT        FD0766
L6_INTERRUPT_MSG    FD22B7
L7_INTERRUPT        FD077A
L7_INTERRUPT_MSG    FD22C3
LF                  A
LOOP                FD005C
LOW_RAM_INITILIZE   FD05B0
L_18                FD1614
L_19                FD162C
L_2                 FD1A00
L_20                FD1646
L_21                FD168E
L_22                FD16A2
L_23                FD16BC
L_24                FD1716
L_3                 FD1A0C
L_5                 FD0A28
L_6                 FD0A40
M0                  FD15FA
MAIN1B              FD0B28
MAIN2B              FD0B9E
MAIN3B              FD0C82
MASTERICW1          17
MASTERICW2          8
MASTERICW3          0
MASTERICW4          3
MASTER_PIC_PORT     FF0020
MAXSEC              FF
MEM_MAP             FD00C6
MENU                FD1FF8
MENU_1OR2_MSG       FD2411
MODEM_BIN_SIGNON    FD2D04
MODEM_DONE          FD1AE6
MODEM_ERR2          FD2DE4
MODEM_ERR3          FD2DFF
MODEM_ERR_LIMIT     8
MODL_5              FD1A92
MOREDRQ             FD17FE
MOREERROR           FD14E8
MORERD16            FD1650
MOREWAIT            FD17D4
MORE_SEC            FD0CDA
MOVE_OK             FD0294
MOVE_OK1            FD02A4
MOVE_RAM            FD0268
MSGBRACKET          FD307A
MSGCPMSEC           FD3062
MSGCPMTRK           FD3057
MSGCY               FD3035
MSGHD               FD3041
MSGLBA              FD306E
MSGMDL              FD2FFD
MSGRD               FD2821
MSGREV              FD302D
MSGSC               FD304B
MSGSN               FD3025
MSGWR               FD2832
MY_IDE              FD08CA
NAK                 15
NEWLINE             FD00CC
NEXTDCOPY           FD1078
NEXTRSEC            FD0DC4
NEXTVCOPY           FD1170
NEXTWSEC            FD0EAC
NEXTWSEC1           FD0EA8
NEXT_BIT            FD1C8E
NEXT_CMP            FD11B8
NEXT_SECT           FD0C8A
NEXT_SEC_DONE       FD141C
NEXT_SEC_NRD        FD0E12
NEXT_SEC_NWR        FD0EF4
NIBBLE1             FD1BDC
NIBBLE2             FD1BE0
NOASCII             FD04F4
NOT5                FD14DA
NOT6                FD14C4
NOT7                FD14AE
NOTDONEMSG          FD218B
NOTDONEYET          FD27CD
NOTE1               FD1564
NOTE2               FD154C
NOTE4               FD1508
NOTE6               FD1534
NOTE7               FD151E
NOT_DONE            FD1DFA
NOT_DONE_CHECK      FD1B42
NOT_ESC             FD09B4
NOT_RAM             FD00FC
NO_HOLD_STATE       7F
NO_WAIT             FD0D6C
NS_EOI              20
N_RD_SEC            FD0D7C
N_WR_SEC            FD0E4A
OK_CR_MSG           FD2BDD
PARMS_OK            FD015A
PARMS_OK1           FD0172
PARMS_OK2           FD0160
PARMS_OK4           FD0194
PARMS_OK5           FD015C
PARMS_OK6           FD01A6
PATCH               FD088A
PATCH0              FD08A8
PATCH1              FD08BE
PATCH_MSG           FD2499
PATCH_RAM           F40000
PORTA_8255          FF00A8
PORTB_8255          FF00A9
PORTCTRL_8255       FF00AB
PORTC_8255          FF00AA
PORTMSG             FD2173
PORTMSG2            FD217B
PREVIOUS_SEC_DONE   FD1466
PREVIOUS_TRACK      FD1444
PREV_SECT           FD0CAC
PRINTER_OUT         FF0005
PRINTER_STATUS      FF0005
PRINTER_STROBE      FF0004
PRINT_DONE          FD1DB0
PRINT_DOT           FD01BA
PRINT_ID_HEX        FD0AFC
PRINT_ID_INFO       FD0AE6
PRINT_STRING        FD1DA2
PRIVILEGE_ERROR     FD06C4
PRIVILEGE_ERROR_MSG  FD2231
PROMPT              FD1FF4
PUTBIT1             FD1C74
PUTBITS_D6          FD1C68
PUTBYTE_D6          FD1C38
PUTCHAR             FD1C9A
PUTCHAR0            FD1CBA
PUTCHAR1            FD1CBC
PUTLONG_D7          FD1BF6
PUTWORD_D6          FD1C06
PUT_TAB             FD1DC4
QUERY_IN            FD02CC
QUERY_OUT           FD033E
QUERY_PORT          FD02AE
QUITM               FD2E35
QUIT_IDE            FD1256
RAM_DESTINATION_MSG  FD2D66
RAM_DMA             FD8500
RAM_DMA_STORE       FD8502
RAM_MSG             FD2E78
RAM_SEC             FD850C
RAM_TRK             FD850D
READCFG8255         92
READN_MSG           FD2B32
READSECTOR          FD1604
READ_ID_ERROR       FD29C6
READ_SEC            FD0B0C
RECV                FD1D42
RECVD_SECT_NO       FD8514
RECV_CHAR           FD1A66
RECV_CKSUM_ERR      FD1AB8
RECV_HDR            FD1950
RECV_HDR_TIMEOUT    FD1992
RECV_LOOP           FD1948
RECV_SECTOR         FD1A5A
RECV_SECT_ERR       FD19AA
REGASTATUS          17
REGCOMMAND          F
REGCONTROL          16
REGCYLINDERLSB      C
REGCYLINDERMSB      D
REGDATA             8
REGERR              9
REGSECCNT           A
REGSECTOR           B
REGSHD              E
REGSTATUS           F
RESETDELAY          FD15A0
RHNTO               FD19EE
RMSG                FD2DB7
ROM_CODE            1
S100_TEST           0
SCCINIT_A           FD1FA4
SCCINIT_B           FD1FB4
SCC_1               FD1EAE
SCC_2               FD1EC8
SECTNO              FD8515
SECTORS_TO_DO       FD8513
SECTOR_COUNT        FD8506
SEC_COUNT_MSG       FD2FAB
SEC_FORMAT_OK       FD0FC6
SEC_NOT_FOUND       FD29EA
SELECT_DRIVE        FD09F8
SEL_DRIVE_A         FD09EC
SEL_DRIVE_B         FD0A06
SENDS               FD1E2E
SENDS1              FD1E3C
SEND_SERIAL         FD1D38
SEQOK               FD0D2A
SEQ_SEC_RD          FD0CCE
SERIAL_DONE         FD1D30
SERIAL_IN           FD1D4C
SERIAL_IN2          FD1D76
SERIAL_IN3          FD1D94
SERIAL_INITILIZE_A  FD1EA0
SERIAL_INITILIZE_B  FD1EBA
SERIAL_IN_CORE      FD1D5C
SERIAL_OUT          FD1D0A
SERIAL_OUT_STAT     FD1D1A
SERIAL_RETRYS       1F40
SERIAL_TEST_DONE_MSG  FD2566
SERIAL_TEST_MSG     FD250D
SET_DRIVE_A         FD09DC
SET_DRIVE_B         FD09E4
SET_LBA             FD0C6C
SET_LBA_MSG         FD2844
SF172               FD1376
SF175               FD1390
SHOWERRORS          FD1482
SHOW_0              FD1C86
SHOW_MENU           FD00BA
SHOW_TRACK          FD1346
SHOW_TRACK_SEC      FD1308
SIGNALS             FD07DC
SIGNALS_MSG         FD23C3
SIGNON              FD1FC4
SIGN_B              FD097A
SIG_STARTED_MSG     FD242B
SIMMULATOR          0
SKIP_SHOW_TRACK     FD0FE2
SLOOP2              FD13B6
SLOOP3              FD13CA
SLOOP4              FD13D4
SMSG                FD2108
SOH                 1
SOUT1               FD1E18
SOUT2               FD1E26
SPACE               FD1DCE
SPEAKER_DELAY       3E8
SPEAKOUT            FD1E06
SPEAK_DONE          FD1E6E
SPEAK_STRING        FD1E56
SPURIOUS_INT        FD06EC
SPURIOUS_INT_MSG    FD2260
START               FD002C
START1              FD00E2
START_B_POINTER_MSG  FD2F0F
SUBS_RAM            FD0206
SUBS_RAM1           FD0250
SUBS_RAM2           FD0214
SUBS_RAM3           FD022A
SUBS_RAM4           FD025C
SUPERVISOR_STACK    FD80F0
SW68K               FF00EE
S_FILE_ADDRESS      FD8518
TAB                 9
TEST_INTS           FD055A
TEST_SERIAL         FD1E76
TEST_SERIAL1        FD1E80
TEST_SERIAL_DONE    FD1E92
TIME                FD07B6
TIMER               FF0040
TIME_MSG            FD239C
TIM_CTL             FF0043
TOUPPER             FD1DD8
TOUTM               FD2E1B
TRACE_ERROR         FD06D8
TRACE_ERROR_MSG     FD224B
TRANS_DONE          FD2EC8
TRAPS               FD07A2
TRAPS_ERR_MSG       FD22E2
TRK0_ERR            FD2A31
UNKNOWN_ERROR       FD2947
UNKNOWN_ERROR1      FD2A59
UNPRINTABLE         FD0424
UNRECOVER_ERR       FD2999
UPDATE_TIMER        80
UPPER_DONE          FD1DEC
USB_DATA            FF00AC
USB_RXE             80
USB_STATUS          FF00AA
USB_TXE             40
VERIFYDONE          FD2BAE
VERIFYT             FD11E8
VERIFYT1            FD11F4
VERIFY_AB           FD1146
VERIFY_ERR          FD2B98
VERIFY_OK           FD0456
VERIFY_OK1          FD0466
VERIFY_OK2          FD046C
VERIFY_RAM          FD042A
VER_ERROR           FD11C6
V_NEXTSEC1          FD120E
V_NEXTSEC2          FD121A
V_NEXTSEC3          FD1224
WAITINIT            FD15C0
WILL_RD_MSG         FD2FC7
WILL_WR_MSG         FD2F70
WRITECFG8255        80
WRITEN_MSG          FD2B3A
WRITESECTOR         FD1690
WRITE_SEC           FD0B5C
WRSEC1_IDE          FD16D0
WR_LBA              FD1718
WR_SEC_OK1          FD0B7E
WR_TEST             FD0858
WR_TEST1            FD0874
XMODEM_BIN          FD18E0
ZERO_ERROR          FD06B0
ZERO_ERROR_MSG      FD221D
ZERO_RAM            FD0056
