00000408 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 2022-06-16 5:56:34 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : 68k Homebrew ROM Monitor
00000000                             3  * Written by : Hayden Kroepfl (ChartreuseK)
00000000                             4  * Date       : August 24th 2015
00000000                             5  * Description: A simple ROM monitor for my homebrew 68k
00000000                             6  *              breadboard computer.
00000000                             7  *-----------------------------------------------------------
00000000                             8  *
00000000                             9  * To make this responsive to different terminal widths we need to change the number of bytes printed
00000000                            10  * on a line from 16, which fits exactly on a 72 column screen, to an ammount based on a formula.
00000000                            11  *  Sizes: 
00000000                            12  *   Address:      "000000: " 8
00000000                            13  *   Each Byte:    "00 "      3
00000000                            14  *   Start ASCII:  "|"        1
00000000                            15  *   Each ASCII:   "."        1
00000000                            16  *   End ASCII:    "|"        1
00000000                            17  *
00000000                            18  *   Width = 8 + numBytes*(3 + 1) + 2
00000000                            19  *   numBytes = (Width - 10)/4 = (Width - 10)>>2
00000000                            20  *  Examples:
00000000                            21  *    (80 - 10)/4 = 70/4 = 16 Bytes
00000000                            22  *    (40 - 10)/4 = 30/4 =  7 Bytes
00000000                            23  *    (32 - 10)/4 = 22/4 =  5 Bytes
00000000                            24  * On small screens we should not show the start and end characters on the ASCII section
00000000                            25  * 40 Characters wide or less
00000000                            26  *    (40 - 8)/4  = 32/4 =  8 Bytes
00000000                            27  *    (32 - 8)/4  = 24/4 =  6 Bytes
00000000                            28  
00000000                            29  
00000000                            30  
00000000                            31  **********************************
00000000                            32  * Defines
00000000                            33  *
00000000  =00080000                 34  RAM_START           equ     $80000
00000000  =000FFFFF                 35  RAM_END             equ     $FFFFF
00000000  =00000050                 36  MAX_LINE_LENGTH     equ     80
00000000                            37  
00000000                            38  *********************************
00000000                            39  * 68681 Duart Register Addresses
00000000                            40  *
00000000  =00100000                 41  DUART equ $100000       * Base Addr of DUART
00000000  =00100000                 42  MRA   equ $100000       * Mode Register A           (R/W)
00000000  =00100001                 43  SRA   equ $100001       * Status Register A         (r)
00000000  =00100001                 44  CSRA  equ $100001       * Clock Select Register A   (w)
00000000  =00100002                 45  CRA   equ $100002       * Commands Register A       (w)
00000000  =00100003                 46  RBA   equ $100003       * Receiver Buffer A         (r)
00000000  =00100003                 47  TBA   equ $100003       * Transmitter Buffer A      (w)
00000000  =00100004                 48  ACR   equ $100004       * Aux. Control Register     (R/W)
00000000  =00100005                 49  ISR   equ $100005       * Interrupt Status Register (R)
00000000  =00100005                 50  IMR   equ $100005       * Interrupt Mask Register   (W)
00000000  =00100008                 51  MRB   equ $100008       * Mode Register B           (R/W)
00000000  =00100009                 52  SRB   equ $100009       * Status Register B         (R)
00000000  =00100009                 53  CSRB  equ $100009       * Clock Select Register B   (W)
00000000  =0010000A                 54  CRB   equ $10000A       * Commands Register B       (W)
00000000  =0010000B                 55  RBB   equ $10000B       * Reciever Buffer B         (R)
00000000  =0010000B                 56  TBB   equ $10000B       * Transmitter Buffer B      (W)
00000000  =0010000C                 57  IVR   equ $10000C       * Interrupt Vector Register (R/W)
00000000                            58  
00000000                            59  **********************************
00000000                            60  * ASCII Control Characters
00000000                            61  *
00000000  =00000007                 62  BEL   equ $07
00000000  =00000008                 63  BKSP  equ $08       * CTRL-H
00000000  =00000009                 64  TAB   equ $09
00000000  =0000000A                 65  LF    equ $0A
00000000  =0000000D                 66  CR    equ $0D
00000000  =0000001B                 67  ESC   equ $1B
00000000                            68  
00000000  =00000003                 69  CTRLC   EQU $03     
00000000  =00000018                 70  CTRLX   EQU $18     * Line Clear
00000000                            71  
00000000                            72  
00000000                            73  **********************************
00000000                            74  * Variables
00000000                            75  *
00000000  =000FFFFB                 76  varCurAddr  equ     RAM_END-4                        * Last address accessed
00000000  =000FFFA9                 77  varLineBuf  equ     varCurAddr-MAX_LINE_LENGTH-2     * Line buffer
00000000                            78  
00000000  =000FFFA9                 79  varLast     equ     varLineBuf
00000000                            80  
00000000                            81  
00000000                            82  
00000000                            83  **** PROGRAM STARTS HERE ****
00000000                            84      
00000400                            85      ORG     $400
00000400                            86      
00000400                            87  **** FIRST 8 bytes loaded after reset ****
00000400= 00100000                  88      DC.l    STACK        * Supervisor stack pointer
00000404= 00000408                  89      DC.l    START        * Initial PC    
00000408                            90      
00000408                            91     
00000408                            92  ********************************************
00000408                            93  * Cold start entry point
00000408                            94  *
00000408                            95  START:
00000408  4FF9 00100000             96      lea     STACK, SP           * Set our stack pointer to be sure
0000040E  4EB9 00000842             97      jsr     initDuart           * Setup the serial port
00000414                            98   
00000414                            99  ********************************************
00000414                           100  * Simple Ram Readback Test
00000414                           101  *    
00000414                           102  ramCheck:
00000414  41F9 00000945            103      lea     msgRamCheck, A0
0000041A  6100 039A                104      bsr.w   printString
0000041E  45F9 00080000            105      lea     RAM_START, A2
00000424                           106   .loop:
00000424  14BC 00AA                107      move.b  #$AA, (A2)   * First test with 10101010
00000428  0C12 00AA                108      cmp.b   #$AA, (A2)
0000042C  661E                     109      bne.s   .fail
0000042E  14BC 0055                110      move.b  #$55, (A2)   * Then with 01010101
00000432  0C12 0055                111      cmp.b   #$55, (A2)
00000436  6614                     112      bne.s   .fail
00000438  14BC 0000                113      move.b  #$00, (A2)   * And finally clear the memory
0000043C  0C1A 0000                114      cmp.b   #$00, (A2)+  * And move to the next byte
00000440  660A                     115      bne.s   .fail 
00000442  B5FC 000FFFFF            116      cmp.l   #RAM_END, A2  
00000448  6DDA                     117      blt.s   .loop        * While we're still below the end of ram to check
0000044A  6016                     118      bra.s   .succ
0000044C                           119   .fail:                  * One of the bytes of RAM failed to readback test
0000044C  41F9 00000957            120      lea     msgRamFail, A0
00000452  6100 0362                121      bsr.w   printString
00000456  200A                     122      move.l  A2, D0
00000458  6100 0378                123      bsr.w   printHexLong * Print out the address that failed
0000045C  6100 0352                124      bsr.w   printNewline
00000460                           125   .haltloop:              * Sit forever in the halt loop
00000460  60FE                     126      bra.s   .haltloop
00000462                           127   .succ:                  * All bytes passed the readback test
00000462  41F9 00000963            128      lea     msgRamPass, A0
00000468  6100 034C                129      bsr.w   printString
0000046C                           130  
0000046C                           131  
0000046C                           132  
0000046C                           133  **************************************************
0000046C                           134  * Warm Restart entry point
0000046C                           135  *
0000046C                           136  monitorStart:
0000046C  41F9 00000884            137      lea     msgBanner, A0   * Show our banner
00000472  6100 0342                138      bsr.w   printString
00000476  41F9 000008C7            139      lea     msgHelp,   A0   * And the command help message
0000047C  6100 0338                140      bsr.w   printString
00000480                           141  
00000480                           142  monitorLine:                * Our main monitor loop
00000480  41F9 0000090E            143      lea     msgPrompt, a0   * Prompt
00000486  6100 032E                144      bsr.w   printString     
0000048A  6100 0292                145      bsr.w   readLine        * Read in the line
0000048E  6100 0008                146      bsr.w   lineToUpper     * Convert to upper-case for ease of parsing
00000492  6100 0022                147      bsr.w   parseLine       * Then parse and respond to the line
00000496                           148      
00000496  60E8                     149      bra.s   monitorLine
00000498                           150      
00000498                           151      
00000498                           152      
00000498                           153      
00000498                           154  ***************************************
00000498                           155  * Converts input line to uppercase
00000498                           156  lineToUpper:
00000498  41F9 000FFFA9            157      lea     varLineBuf, a0   * Get the start of the line buffer
0000049E                           158   .loop:
0000049E  1010                     159      move.b  (a0), d0         * Read in a character
000004A0  B03C 0061                160      cmp.b   #'a', d0         
000004A4  6D0A                     161      blt.s   .next            * Is it less than lower-case 'a', then move on
000004A6  B03C 007A                162      cmp.b   #'z', d0
000004AA  6E04                     163      bgt.s   .next            * Is it greater than lower-case 'z', then move on
000004AC  0400 0020                164      sub.b   #$20, d0         * Then convert a to A, b to B, etc.
000004B0                           165   .next:
000004B0  10C0                     166      move.b  d0, (a0)+        * Store the character back into a0, and move to the next
000004B2  66EA                     167      bne.s   .loop            * Keep going till we hit a null terminator
000004B4  4E75                     168      rts
000004B6                           169  
000004B6                           170  ***************************************
000004B6                           171  * Parse Line
000004B6                           172  parseLine:
000004B6  48E7 0030                173      movem.l a2-a3, -(SP)        * Save registers
000004BA  41F9 000FFFA9            174      lea     varLineBuf, a0
000004C0                           175   .findCommand:
000004C0  1018                     176      move.b  (a0)+, d0
000004C2  B03C 0020                177      cmp.b   #' ', d0            * Ignore spaces
000004C6  6700 FFF8                178      beq.w   .findCommand    
000004CA  B03C 0045                179      cmp.b   #'E', d0            * Examine command
000004CE  6700 0030                180      beq.w   .examine
000004D2  B03C 0044                181      cmp.b   #'D', d0            * Deposit command
000004D6  6700 00B0                182      beq.w   .deposit
000004DA  B03C 0052                183      cmp.b   #'R', d0            * Run command
000004DE  6700 0106                184      beq.w   .run
000004E2  B03C 0048                185      cmp.b   #'H', d0            * Help command
000004E6  6700 010E                186      beq.w   .help
000004EA  B03C 0000                187      cmp.b   #0, d0              * Ignore blank lines
000004EE  670A                     188      beq.s   .exit               
000004F0                           189   .invalid:   
000004F0  41F9 00000911            190      lea     msgInvalidCommand, a0
000004F6  6100 02BE                191      bsr.w   printString
000004FA                           192   .exit:
000004FA  4CDF 0C00                193      movem.l (SP)+, a2-a3        * Restore registers
000004FE  4E75                     194      rts
00000500                           195  
00000500                           196  **********************
00000500                           197  * Examines memory addresses
00000500                           198  * Valid modes:
00000500                           199  *   e ADDR                  Displays a single byte
00000500                           200  *   e ADDR-ADDR             Dispalys all bytes between the two addresses
00000500                           201  *   e ADDR+LEN              Dispays LEN bytes after ADDR
00000500                           202  *   e ADDR;                 Interactive mode, space shows 16 lines, enter shows 1.
00000500                           203  *   e ADDR.                 Quick line, displays one line 
00000500                           204   .examine:
00000500  6100 011E                205      bsr.w   parseNumber         * Read in the start address
00000504  4A01                     206      tst.b   d1                  * Make sure it's valid (parseNumber returns non-zero in d1 for failure)
00000506  6600 00FC                207      bne.w   .invalidAddr        
0000050A  2640                     208      move.l  d0, a3              * Save the start address
0000050C                           209   .exloop:
0000050C  1018                     210      move.b  (a0)+, d0
0000050E  B03C 0020                211      cmp.b   #' ', d0            * Ignore spaces
00000512  67F8                     212      beq.s   .exloop
00000514  B03C 002D                213      cmp.b   #'-', d0            * Check if it's a range specifier
00000518  6716                     214      beq.s   .exrange
0000051A  B03C 002B                215      cmp.b   #'+', d0            * Check if it's a length specifier
0000051E  6722                     216      beq.s   .exlength
00000520  B03C 003B                217      cmp.b   #';', d0            * Check if we're going interactive
00000524  672E                     218      beq.s   .exinter
00000526  B03C 002E                219      cmp.b   #'.', d0            * Check if quick 16 
0000052A  6712                     220      beq.s   .exquick
0000052C  7001                     221      move.l  #1, d0              * Otherwise read in a single byte
0000052E  601C                     222      bra.s   .exend              
00000530                           223   .exrange:
00000530  6100 00EE                224      bsr.w   parseNumber         * Find the end address
00000534  4A01                     225      tst.b   d1                  * Check if we found a valid address
00000536  6600 00CC                226      bne.w   .invalidAddr
0000053A  908B                     227      sub.l   a3, d0              * Get the length
0000053C  600E                     228      bra.s   .exend
0000053E                           229   .exquick:                      * Quick mode means show one line of 16 bytes
0000053E  7010                     230      move.l  #$10, d0
00000540  600A                     231      bra.s   .exend
00000542                           232   .exlength:                     * Length mode means a length is specified
00000542  6100 00DC                233      bsr.w   parseNumber         * Find the length
00000546  4A01                     234      tst.b   d1
00000548  6600 00BA                235      bne.w   .invalidAddr
0000054C                           236   .exend:                        * We're done parsing, give the parameters to dumpRAM and exit
0000054C  204B                     237      move.l  a3, a0
0000054E  6100 0130                238      bsr.w   dumpRAM
00000552  60A6                     239      bra.s   .exit
00000554                           240   .exinter:                      * Interactive mode, Space shows 16 lines, enter shows 1.
00000554  204B                     241      move.l  a3, a0              * Current Address
00000556  7010                     242      move.l  #$10, d0            * 16 bytes
00000558  6100 0126                243      bsr.w   dumpRAM             * Dump this line
0000055C  D7FC 00000010            244      add.l   #$10, a3            * Move up the current address 16 bytes
00000562                           245   .exinterend:
00000562  6100 02CC                246      bsr.w   inChar
00000566  B03C 000D                247      cmp.b   #CR, d0             * Display another line
0000056A  67E8                     248      beq.s   .exinter
0000056C  B03C 0020                249      cmp.b   #' ', d0            * Display a page (256 bytes at a time)
00000570  6702                     250      beq.s   .exinterpage
00000572  6086                     251      bra.s   .exit               * Otherwise exit
00000574                           252   .exinterpage:
00000574  204B                     253      move.l  a3, a0
00000576  203C 00000100            254      move.l  #$100, d0           * 256 bytes
0000057C  6100 0102                255      bsr.w   dumpRAM             * Dump 16 lines of RAM
00000580  D7FC 00000100            256      add.l   #$100, a3           * Move up the current address by 256
00000586  60DA                     257      bra.s   .exinterend
00000588                           258  
00000588                           259  ****************************************
00000588                           260  * Deposit values into RAM
00000588                           261  * d ADDR VAL VAL            Deposit value(s) into RAM
00000588                           262  * d ADDR VAL VAL;           Deposit values, continue with values on next line
00000588                           263  *  VAL VAL VAL;              - Continuing with further continue
00000588                           264  * d: VAL VAL                Continue depositing values after the last address written to
00000588                           265   .deposit:
00000588  1010                     266      move.b  (a0), d0
0000058A  B03C 003A                267      cmp.b   #':', d0            * Check if we want to continue from last
0000058E  6728                     268      beq.s   .depCont
00000590                           269      
00000590  6100 008E                270      bsr.w   parseNumber         * Otherwise read the address
00000594  4A01                     271      tst.b   d1
00000596  666C                     272      bne.s   .invalidAddr
00000598  2640                     273      move.l  d0, a3              * Save the start address
0000059A                           274   .depLoop:
0000059A  1010                     275      move.b  (a0), d0            
0000059C  B03C 003B                276      cmp.b   #';', d0            * Check for continue
000005A0  6720                     277      beq.s   .depMultiline
000005A2  4A40                     278      tst     d0                  * Check for the end of line
000005A4  6700 0036                279      beq     .depEnd
000005A8                           280      
000005A8  6176                     281      bsr.s   parseNumber         * Otherwise read a value
000005AA  4A01                     282      tst.b   d1
000005AC  6664                     283      bne.s   .invalidVal
000005AE  B07C 00FF                284      cmp.w   #255, d0            * Make sure it's a byte
000005B2  6E5E                     285      bgt.s   .invalidVal
000005B4                           286      
000005B4  16C0                     287      move.b  d0, (a3)+           * Store the value into memory
000005B6  60E2                     288      bra.s   .depLoop
000005B8                           289      
000005B8                           290   .depCont:
000005B8  2679 000FFFFB            291      move.l  varCurAddr, a3      * Read in the last address 
000005BE  5288                     292      addq.l  #1, a0              * Skip over the ':'
000005C0  60D8                     293      bra.s   .depLoop
000005C2                           294      
000005C2                           295   .depMultiline:
000005C2  41F9 0000090B            296      lea     msgDepositPrompt, a0
000005C8  6100 01EC                297      bsr.w   printString
000005CC  6100 0150                298      bsr.w   readLine            * Read in the next line to be parsed
000005D0  6100 FEC6                299      bsr.w   lineToUpper         * Convert to uppercase
000005D4  41F9 000FFFA9            300      lea     varLineBuf, a0      * Reset our buffer pointer
000005DA  60BE                     301      bra.s   .depLoop            * And jump back to decoding
000005DC                           302   .depEnd:
000005DC  23CB 000FFFFB            303      move.l  a3, varCurAddr
000005E2  6000 FF16                304      bra.w   .exit
000005E6                           305  ****************************************
000005E6                           306  * 
000005E6                           307   .run:
000005E6  6100 0038                308      bsr.w   parseNumber         * Otherwise read the address
000005EA  4A01                     309      tst.b   d1
000005EC  6616                     310      bne.s   .invalidAddr
000005EE  2040                     311      move.l  d0, a0
000005F0  4E90                     312      jsr     (a0)                * Jump to the code! 
000005F2                           313                                  * Go as subroutine to allow code to return to us
000005F2  4EB8 046C                314      jsr     monitorStart        * Warm start after returning so everything is in
000005F6                           315                                  * a known state.
000005F6                           316      
000005F6                           317   .help:
000005F6  41F9 000008C7            318      lea     msgHelp, a0
000005FC  6100 01B8                319      bsr.w   printString
00000600  6000 FEF8                320      bra.w   .exit
00000604                           321   .invalidAddr:
00000604  41F9 00000923            322      lea     msgInvalidAddress, a0
0000060A  6100 01AA                323      bsr.w   printString
0000060E  6000 FEEA                324      bra.w   .exit
00000612                           325   .invalidVal:
00000612  41F9 00000935            326      lea     msgInvalidValue, a0
00000618  6100 019C                327      bsr.w   printString
0000061C  6000 FEDC                328      bra.w   .exit
00000620                           329      
00000620                           330      
00000620                           331  **************************************
00000620                           332  * Find and parse a hex number
00000620                           333  *  Starting address in A0
00000620                           334  *  Number returned in D0
00000620                           335  *  Status in D1   (0 success, 1 fail)
00000620                           336  *  TODO: Try and merge first digit code with remaining digit code
00000620                           337  parseNumber:
00000620  B180                     338      eor.l   d0, d0           * Zero out d0
00000622  1018                     339      move.b  (a0)+, d0
00000624  B03C 0020                340      cmp.b   #' ', d0         * Ignore all leading spaces
00000628  67F6                     341      beq.s   parseNumber
0000062A  B03C 0030                342      cmp.b   #'0', d0         * Look for hex digits 0-9
0000062E  6D12                     343      blt.s   .invalid
00000630  B03C 0039                344      cmp.b   #'9', d0
00000634  6F16                     345      ble.s   .firstdigit1
00000636                           346  
00000636  B03C 0041                347      cmp.b   #'A', d0         * Look for hex digits A-F
0000063A  6D06                     348      blt.s   .invalid    
0000063C  B03C 0046                349      cmp.b   #'F', d0
00000640  6F04                     350      ble.s   .firstdigit2
00000642                           351   .invalid:
00000642  7201                     352      move.l  #1, d1          * Invalid character, mark failure and return
00000644  4E75                     353      rts
00000646                           354   .firstdigit2:
00000646  0400 0037                355      sub.b   #'7', d0        * Turn 'A' to 10
0000064A  6004                     356      bra.s   .loop
0000064C                           357   .firstdigit1:
0000064C  0400 0030                358      sub.b   #'0', d0        * Turn '0' to 0
00000650                           359   .loop:
00000650  1218                     360      move.b  (a0)+, d1       * Read in a digit
00000652  B23C 0030                361      cmp.b   #'0', d1        * Look for hex digits 0-9
00000656  6D12                     362      blt.s   .end            * Any other characters mean we're done reading
00000658  B23C 0039                363      cmp.b   #'9', d1
0000065C  6F18                     364      ble.s   .digit1
0000065E  B23C 0041                365      cmp.b   #'A', d1        * Look for hex digits A-F
00000662  6D06                     366      blt.s   .end
00000664  B23C 0046                367      cmp.b   #'F', d1
00000668  6F06                     368      ble.s   .digit2
0000066A                           369  
0000066A                           370  .end:                       * We hit a non-hex digit character, we're done parsing
0000066A  5388                     371      subq.l  #1, a0          * Move the pointer back before the end character we read
0000066C  7200                     372      move.l  #0, d1
0000066E  4E75                     373      rts
00000670                           374   .digit2:
00000670  0401 0037                375      sub.b   #'7', d1        * Turn 'A' to 10
00000674  6004                     376      bra.s   .digit3
00000676                           377   .digit1:
00000676  0401 0030                378      sub.b   #'0', d1        * Turn '0' to 0
0000067A                           379   .digit3:
0000067A  E988                     380      lsl.l   #4, d0          * Shift over to the next nybble
0000067C  D001                     381      add.b   d1, d0          * Place in our current nybble (could be or.b instead)
0000067E  60D0                     382      bra.s   .loop
00000680                           383      
00000680                           384      
00000680                           385  ****************************************
00000680                           386  * Dumps a section of RAM to the screen
00000680                           387  * Displays both hex values and ASCII characters
00000680                           388  * d0 - Number of bytes to dump
00000680                           389  * a0 - Start Address
00000680                           390  dumpRAM:
00000680  48E7 3820                391      movem.l d2-d4/a2, -(SP)  * Save registers
00000684  2448                     392      move.l  a0, a2           * Save the start address
00000686  2400                     393      move.l  d0, d2           * And the number of bytes
00000688                           394   .line:
00000688  200A                     395      move.l  a2, d0          
0000068A  6100 013E                396      bsr.w   printHexAddr     * Starting address of this line
0000068E  41F9 00000970            397      lea     msgColonSpace, a0
00000694  6100 0120                398      bsr.w   printString
00000698  7610                     399      move.l  #16, d3          * 16 Bytes can be printed on a line
0000069A  2803                     400      move.l  d3, d4           * Save number of bytes on this line
0000069C                           401   .hexbyte:
0000069C  4A82                     402      tst.l   d2               * Check if we're out of bytes
0000069E  6718                     403      beq.s   .endbytesShort
000006A0  4A03                     404      tst.b   d3               * Check if we're done this line
000006A2  673A                     405      beq.s   .endbytes    
000006A4  101A                     406      move.b  (a2)+, d0        * Read a byte in from RAM
000006A6  6100 014A                407      bsr.w   printHexByte     * Display it
000006AA  103C 0020                408      move.b  #' ', d0
000006AE  6100 016E                409      bsr.w   outChar          * Space out bytes
000006B2  5383                     410      subq.l  #1, d3    
000006B4  5382                     411      subq.l  #1, d2        
000006B6  60E4                     412      bra.s   .hexbyte
000006B8                           413   .endbytesShort:
000006B8  9803                     414      sub.b   d3, d4           * Make d4 the actual number of bytes on this line
000006BA  103C 0020                415      move.b  #' ', d0
000006BE                           416   .endbytesShortLoop:
000006BE  4A03                     417      tst.b   d3               * Check if we ended the line
000006C0  671C                     418      beq.s   .endbytes
000006C2  103C 0020                419      move.b  #' ', d0
000006C6  6100 0156                420      bsr.w   outChar          * Three spaces to pad out
000006CA  103C 0020                421      move.b  #' ', d0
000006CE  6100 014E                422      bsr.w   outChar
000006D2  103C 0020                423      move.b  #' ', d0
000006D6  6100 0146                424      bsr.w   outChar
000006DA                           425      
000006DA  5303                     426      subq.b  #1, d3
000006DC  60E0                     427      bra.s   .endbytesShortLoop
000006DE                           428   .endbytes:
000006DE  95C4                     429      suba.l  d4, a2           * Return to the start address of this line
000006E0                           430   .endbytesLoop:
000006E0  4A04                     431      tst.b   d4               * Check if we're done printing ascii
000006E2  6700 0022                432      beq     .endline    
000006E6  5304                     433      subq.b  #1, d4
000006E8  101A                     434      move.b  (a2)+, d0        * Read the byte again
000006EA  B03C 0020                435      cmp.b   #' ', d0         * Lowest printable character
000006EE  6D0C                     436      blt.s   .unprintable
000006F0  B03C 007E                437      cmp.b   #'~', d0         * Highest printable character
000006F4  6E06                     438      bgt.s   .unprintable
000006F6  6100 0126                439      bsr.w   outChar
000006FA  60E4                     440      bra.s   .endbytesLoop
000006FC                           441   .unprintable:
000006FC  103C 002E                442      move.b  #'.', d0
00000700  6100 011C                443      bsr.w   outChar
00000704  60DA                     444      bra.s   .endbytesLoop
00000706                           445   .endline:
00000706  41F9 0000096D            446      lea     msgNewline, a0
0000070C  6100 00A8                447      bsr.w   printString
00000710  4A82                     448      tst.l   d2
00000712  6F04                     449      ble.s   .end
00000714  6000 FF72                450      bra.w   .line
00000718                           451   .end:
00000718  4CDF 041C                452      movem.l (SP)+, d2-d4/a2  * Restore registers
0000071C  4E75                     453      rts
0000071E                           454      
0000071E                           455      
0000071E                           456          
0000071E                           457      
0000071E                           458  ******
0000071E                           459  * Read in a line into the line buffer
0000071E                           460  readLine:
0000071E  48E7 2020                461      movem.l d2/a2, -(SP)     * Save changed registers
00000722  45F9 000FFFA9            462      lea     varLineBuf, a2   * Start of the lineBuffer
00000728  B542                     463      eor.w   d2, d2           * Clear the character counter
0000072A                           464   .loop:
0000072A  6100 0104                465      bsr.w   inChar           * Read a character from the serial port
0000072E  B03C 0008                466      cmp.b   #BKSP, d0        * Is it a backspace?
00000732  6722                     467      beq.s   .backspace
00000734  B03C 0018                468      cmp.b   #CTRLX, d0       * Is it Ctrl-H (Line Clear)?
00000738  673A                     469      beq.s   .lineclear
0000073A  B03C 000D                470      cmp.b   #CR, d0          * Is it a carriage return?
0000073E  6758                     471      beq.s   .endline
00000740  B03C 000A                472      cmp.b   #LF, d0          * Is it anything else but a LF?
00000744  67E4                     473      beq.s   .loop            * Ignore LFs and get the next character
00000746                           474   .char:                      * Normal character to be inserted into the buffer
00000746  B47C 0050                475      cmp.w   #MAX_LINE_LENGTH, d2
0000074A  6CDE                     476      bge.s   .loop            * If the buffer is full ignore the character
0000074C  14C0                     477      move.b  d0, (a2)+        * Otherwise store the character
0000074E  5242                     478      addq.w  #1, d2           * Increment character count
00000750  6100 00CC                479      bsr.w   outChar          * Echo the character
00000754  60D4                     480      bra.s   .loop            * And get the next one
00000756                           481   .backspace:
00000756  4A42                     482      tst.w   d2               * Are we at the beginning of the line?
00000758  67D0                     483      beq.s   .loop            * Then ignore it
0000075A  6100 00C2                484      bsr.w   outChar          * Backspace
0000075E  103C 0020                485      move.b  #' ', d0
00000762  6100 00BA                486      bsr.w   outChar          * Space
00000766  103C 0008                487      move.b  #BKSP, d0
0000076A  6100 00B2                488      bsr.w   outChar          * Backspace
0000076E  538A                     489      subq.l  #1, a2           * Move back in the buffer
00000770  5382                     490      subq.l  #1, d2           * And current character count
00000772  60B6                     491      bra.s   .loop            * And goto the next character
00000774                           492   .lineclear:
00000774  4A42                     493      tst     d2               * Anything to clear?
00000776  67B2                     494      beq.s   .loop            * If not, fetch the next character
00000778  95C2                     495      suba.l  d2, a2           * Return to the start of the buffer
0000077A                           496   .lineclearloop:
0000077A  103C 0008                497      move.b  #BKSP, d0
0000077E  6100 009E                498      bsr.w   outChar          * Backspace
00000782  103C 0020                499      move.b  #' ', d0
00000786  6100 0096                500      bsr.w   outChar          * Space
0000078A  103C 0008                501      move.b  #BKSP, d0
0000078E  6100 008E                502      bsr.w   outChar          * Backspace
00000792  5342                     503      subq.w  #1, d2          
00000794  66E4                     504      bne.s   .lineclearloop   * Go till the start of the line
00000796  6092                     505      bra.s   .loop   
00000798                           506   .endline:
00000798  6100 0084                507      bsr.w   outChar          * Echo the CR
0000079C  103C 000A                508      move.b  #LF, d0
000007A0  6100 007C                509      bsr.w   outChar          * Line feed to be safe
000007A4  14BC 0000                510      move.b  #0, (a2)         * Terminate the line (Buffer is longer than max to allow this at full length)
000007A8  204A                     511      movea.l a2, a0           * Ready the pointer to return (if needed)
000007AA  4CDF 0404                512      movem.l (SP)+, d2/a2     * Restore registers
000007AE  4E75                     513      rts                      * And return
000007B0                           514  
000007B0                           515  
000007B0                           516  
000007B0                           517  
000007B0                           518      
000007B0                           519  ******
000007B0                           520  * Prints a newline (CR, LF)
000007B0                           521  printNewline:
000007B0  41F9 0000096D            522      lea     msgNewline, a0
000007B6                           523  ******
000007B6                           524  * Print a null terminated string
000007B6                           525  *
000007B6                           526  printString:
000007B6                           527   .loop:
000007B6  1018                     528      move.b  (a0)+, d0    * Read in character
000007B8  6704                     529      beq.s   .end         * Check for the null
000007BA                           530      
000007BA  6162                     531      bsr.s   outChar      * Otherwise write the character
000007BC  60F8                     532      bra.s   .loop        * And continue
000007BE                           533   .end:
000007BE  4E75                     534      rts
000007C0                           535  
000007C0                           536  ** KEEP All printHex functions together **
000007C0                           537  ******
000007C0                           538  * Print a hex word
000007C0                           539  printHexWord:
000007C0  2F02                     540      move.l  d2, -(SP)    * Save D2
000007C2  2400                     541      move.l  d0, d2       * Save the address in d2
000007C4                           542      
000007C4  E19A                     543      rol.l   #8, d2       * 4321 -> 3214
000007C6  E19A                     544      rol.l   #8, d2       * 3214 -> 2143 
000007C8  6018                     545      bra.s   printHex_wordentry  * Print out the last 16 bits
000007CA                           546  *****
000007CA                           547  * Print a hex 24-bit address
000007CA                           548  printHexAddr:
000007CA  2F02                     549      move.l d2, -(SP)     * Save D2
000007CC  2400                     550      move.l d0, d2          * Save the address in d2
000007CE                           551      
000007CE  E19A                     552      rol.l   #8, d2       * 4321 -> 3214
000007D0  600A                     553      bra.s   printHex_addrentry  * Print out the last 24 bits
000007D2                           554  ******
000007D2                           555  * Print a hex long
000007D2                           556  printHexLong:
000007D2  2F02                     557      move.l  d2, -(SP)     * Save D2
000007D4  2400                     558      move.l  d0, d2        * Save the address in d2
000007D6                           559      
000007D6  E19A                     560      rol.l   #8, d2        * 4321 -> 3214 high byte in low
000007D8  2002                     561      move.l  d2, d0
000007DA  6116                     562      bsr.s   printHexByte  * Print the high byte (24-31)
000007DC                           563  printHex_addrentry:     
000007DC  E19A                     564      rol.l   #8, d2        * 3214 -> 2143 middle-high byte in low
000007DE  2002                     565      move.l  d2, d0              
000007E0  6110                     566      bsr.s   printHexByte  * Print the high-middle byte (16-23)
000007E2                           567  printHex_wordentry:    
000007E2  E19A                     568      rol.l   #8, d2        * 2143 -> 1432 Middle byte in low
000007E4  2002                     569      move.l  d2, d0
000007E6  610A                     570      bsr.s   printHexByte  * Print the middle byte (8-15)
000007E8  E19A                     571      rol.l   #8, d2
000007EA  2002                     572      move.l  d2, d0
000007EC  6104                     573      bsr.s   printHexByte  * Print the low byte (0-7)
000007EE                           574      
000007EE  241F                     575      move.l (SP)+, d2      * Restore D2
000007F0  4E75                     576      RTS
000007F2                           577      
000007F2                           578  ******
000007F2                           579  * Print a hex byte
000007F2                           580  *  - Takes byte in D0
000007F2                           581  printHexByte:
000007F2  2F02                     582      move.l  D2, -(SP)
000007F4  1400                     583      move.b  D0, D2
000007F6  E808                     584      lsr.b   #$4, D0
000007F8  0600 0030                585      add.b   #'0', D0
000007FC  B03C 0039                586      cmp.b   #'9', D0     * Check if the hex number was from 0-9
00000800  6F02                     587      ble.s   .second
00000802  5E00                     588      add.b   #7, D0       * Shift 0xA-0xF from ':' to 'A'
00000804                           589  .second:
00000804  6118                     590      bsr.s   outChar      * Print the digit
00000806  0202 000F                591      andi.b  #$0F, D2     * Now we want the lower digit Mask only the lower digit
0000080A  0602 0030                592      add.b   #'0', D2
0000080E  B43C 0039                593      cmp.b   #'9', D2     * Same as before    
00000812  6F02                     594      ble.s   .end
00000814  5E02                     595      add.b   #7, D2
00000816                           596  .end:
00000816  1002                     597      move.b  D2, D0
00000818  6104                     598      bsr.s   outChar      * Print the lower digit
0000081A  241F                     599      move.l  (SP)+, D2
0000081C  4E75                     600      rts
0000081E                           601      
0000081E                           602      
0000081E                           603      
0000081E                           604      
0000081E                           605      
0000081E                           606      
0000081E                           607  *****
0000081E                           608  * Writes a character to Port A, blocking if not ready (Full buffer)
0000081E                           609  *  - Takes a character in D0
0000081E                           610  outChar:
0000081E  0839 0002 00100001       611      btst    #2, SRA      * Check if transmitter ready bit is set
00000826  67F6                     612      beq     outChar     
00000828  13C0 00100003            613      move.b  d0, TBA      * Transmit Character
0000082E  4E75                     614      rts
00000830                           615  
00000830                           616  *****
00000830                           617  * Reads in a character from Port A, blocking if none available
00000830                           618  *  - Returns character in D0
00000830                           619  *    
00000830                           620  inChar:
00000830  0839 0000 00100001       621      btst    #0,  SRA     * Check if receiver ready bit is set
00000838  67F6                     622      beq     inChar
0000083A  1039 00100003            623      move.b  RBA, d0      * Read Character into D0
00000840  4E75                     624      rts
00000842                           625      
00000842                           626  *****
00000842                           627  * Initializes the 68681 DUART port A as 9600 8N1 
00000842                           628  initDuart:
00000842  13FC 0030 00100002       629      move.b  #$30, CRA       * Reset Transmitter
0000084A  13FC 0020 00100002       630      move.b  #$20, CRA       * Reset Reciever
00000852  13FC 0010 00100002       631      move.b  #$10, CRA       * Reset Mode Register Pointer
0000085A                           632      
0000085A  13FC 0080 00100004       633      move.b  #$80, ACR       * Baud Rate Set #2
00000862  13FC 00BB 00100001       634      move.b  #$BB, CSRA      * Set Tx and Rx rates to 9600
0000086A  13FC 0093 00100000       635      move.b  #$93, MRA       * 7-bit, No Parity ($93 for 8-bit, $92 for 7-bit)
00000872  13FC 0007 00100000       636      move.b  #$07, MRA       * Normal Mode, Not CTS/RTS, 1 stop bit
0000087A                           637      
0000087A  13FC 0005 00100002       638      move.b  #$05, CRA       * Enable Transmit/Recieve
00000882  4E75                     639      rts    
00000884                           640  
00000884                           641  
00000884                           642  
00000884                           643  
00000884                           644  
00000884                           645  
00000884                           646  **********************************
00000884                           647  * Strings
00000884                           648  *
00000884                           649  msgBanner:
00000884= 0D 0A 43 68 61 72 ...    650      dc.b CR,LF,'Chartreuse''s 68000 ROM Monitor',CR,LF
000008A6= 3D 3D 3D 3D 3D 3D ...    651      dc.b       '==============================',CR,LF,0
000008C7                           652  msgHelp:
000008C7= 41 76 61 69 6C 61 ...    653      dc.b 'Available Commands: ',CR,LF
000008DD= 20 28 45 29 78 61 ...    654      dc.b ' (E)xamine    (D)eposit    (R)un     (H)elp',CR,LF,0
0000090B                           655  msgDepositPrompt:
0000090B= 3A 20 00                 656      dc.b ': ',0
0000090E                           657  msgPrompt:
0000090E= 3E 20 00                 658      dc.b '> ',0
00000911                           659  msgInvalidCommand:
00000911= 49 6E 76 61 6C 69 ...    660      dc.b 'Invalid Command',CR,LF,0
00000923                           661  msgInvalidAddress:
00000923= 49 6E 76 61 6C 69 ...    662      dc.b 'Invalid Address',CR,LF,0
00000935                           663  msgInvalidValue:
00000935= 49 6E 76 61 6C 69 ...    664      dc.b 'Invalid Value',CR,LF,0
00000945                           665  msgRamCheck:
00000945= 43 68 65 63 6B 69 ...    666      dc.b 'Checking RAM...',CR,LF,0
00000957                           667  msgRamFail:
00000957= 46 61 69 6C 65 64 ...    668      dc.b 'Failed at: ',0
00000963                           669  msgRamPass:
00000963= 50 61 73 73 65 64 ...    670      dc.b 'Passed.',CR,LF,0
0000096D                           671  msgNewline:
0000096D= 0D 0A 00                 672      dc.b CR,LF,0
00000970                           673  msgColonSpace:
00000970= 3A 20 00                 674      dc.b ': ',0
00000973                           675  
00100000                           676      ORG $100000
00100000                           677  STACK:
00100000                           678      
00100000                           679      END    START            * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACR                 100004
BEL                 7
BKSP                8
CR                  D
CRA                 100002
CRB                 10000A
CSRA                100001
CSRB                100009
CTRLC               3
CTRLX               18
DUART               100000
DUMPRAM             680
DUMPRAM:END         718
DUMPRAM:ENDBYTES    6DE
DUMPRAM:ENDBYTESLOOP  6E0
DUMPRAM:ENDBYTESSHORT  6B8
DUMPRAM:ENDBYTESSHORTLOOP  6BE
DUMPRAM:ENDLINE     706
DUMPRAM:HEXBYTE     69C
DUMPRAM:LINE        688
DUMPRAM:UNPRINTABLE  6FC
ESC                 1B
IMR                 100005
INCHAR              830
INITDUART           842
ISR                 100005
IVR                 10000C
LF                  A
LINETOUPPER         498
LINETOUPPER:LOOP    49E
LINETOUPPER:NEXT    4B0
MAX_LINE_LENGTH     50
MONITORLINE         480
MONITORSTART        46C
MRA                 100000
MRB                 100008
MSGBANNER           884
MSGCOLONSPACE       970
MSGDEPOSITPROMPT    90B
MSGHELP             8C7
MSGINVALIDADDRESS   923
MSGINVALIDCOMMAND   911
MSGINVALIDVALUE     935
MSGNEWLINE          96D
MSGPROMPT           90E
MSGRAMCHECK         945
MSGRAMFAIL          957
MSGRAMPASS          963
OUTCHAR             81E
PARSELINE           4B6
PARSELINE:DEPCONT   5B8
PARSELINE:DEPEND    5DC
PARSELINE:DEPLOOP   59A
PARSELINE:DEPMULTILINE  5C2
PARSELINE:DEPOSIT   588
PARSELINE:EXAMINE   500
PARSELINE:EXEND     54C
PARSELINE:EXINTER   554
PARSELINE:EXINTEREND  562
PARSELINE:EXINTERPAGE  574
PARSELINE:EXIT      4FA
PARSELINE:EXLENGTH  542
PARSELINE:EXLOOP    50C
PARSELINE:EXQUICK   53E
PARSELINE:EXRANGE   530
PARSELINE:FINDCOMMAND  4C0
PARSELINE:HELP      5F6
PARSELINE:INVALID   4F0
PARSELINE:INVALIDADDR  604
PARSELINE:INVALIDVAL  612
PARSELINE:RUN       5E6
PARSENUMBER         620
PARSENUMBER:DIGIT1  676
PARSENUMBER:DIGIT2  670
PARSENUMBER:DIGIT3  67A
PARSENUMBER:END     66A
PARSENUMBER:FIRSTDIGIT1  64C
PARSENUMBER:FIRSTDIGIT2  646
PARSENUMBER:INVALID  642
PARSENUMBER:LOOP    650
PRINTHEXADDR        7CA
PRINTHEXBYTE        7F2
PRINTHEXBYTE:END    816
PRINTHEXBYTE:SECOND  804
PRINTHEXLONG        7D2
PRINTHEXWORD        7C0
PRINTHEX_ADDRENTRY  7DC
PRINTHEX_WORDENTRY  7E2
PRINTNEWLINE        7B0
PRINTSTRING         7B6
PRINTSTRING:END     7BE
PRINTSTRING:LOOP    7B6
RAMCHECK            414
RAMCHECK:FAIL       44C
RAMCHECK:HALTLOOP   460
RAMCHECK:LOOP       424
RAMCHECK:SUCC       462
RAM_END             FFFFF
RAM_START           80000
RBA                 100003
RBB                 10000B
READLINE            71E
READLINE:BACKSPACE  756
READLINE:CHAR       746
READLINE:ENDLINE    798
READLINE:LINECLEAR  774
READLINE:LINECLEARLOOP  77A
READLINE:LOOP       72A
SRA                 100001
SRB                 100009
STACK               100000
START               408
TAB                 9
TBA                 100003
TBB                 10000B
VARCURADDR          FFFFB
VARLAST             FFFA9
VARLINEBUF          FFFA9
